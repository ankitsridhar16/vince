"use strict"; (() => {
    var wo = Object.defineProperty; var u = (e, l) => wo(e, "name", { value: l, configurable: !0 }); var ke = "u-", So = "uplot", _o = ke + "hz", yo = ke + "vt", vo = ke + "title", bo = ke + "wrap", Mo = ke + "under", ko = ke + "over", xo = ke + "axis", Ft = ke + "off", Eo = ke + "select", To = ke + "cursor-x", Do = ke + "cursor-y", Ao = ke + "cursor-pt", Lo = ke + "legend", Po = ke + "live", Co = ke + "inline", zo = ke + "thead", Ro = ke + "series", Fo = ke + "marker", bi = ke + "label", Vo = ke + "value", Ml = "width", kl = "height", vl = "top", Mi = "bottom", Jt = "left", xn = "right", On = "#000", ki = On + "0", xi = "mousemove", Ei = "mousedown", En = "mouseup", Ti = "mouseenter", Di = "mouseleave", Ai = "dblclick", No = "resize", Oo = "scroll", Li = "change", Ul = "dppxchange", Hn = "--", il = typeof window < "u", Pn = il ? document : null, Qt = il ? window : null, Ho = il ? navigator : null, ie, Wl; function Cn() { let e = devicePixelRatio; ie != e && (ie = e, Wl && Rn(Li, Wl, Cn), Wl = matchMedia(`(min-resolution: ${ie - .001}dppx) and (max-resolution: ${ie + .001}dppx)`), xt(Li, Wl, Cn), Qt.dispatchEvent(new CustomEvent(Ul))) } u(Cn, "setPxRatio"); function Ze(e, l) { if (l != null) { let s = e.classList; !s.contains(l) && s.add(l) } } u(Ze, "addClass"); function zn(e, l) { let s = e.classList; s.contains(l) && s.remove(l) } u(zn, "remClass"); function we(e, l, s) { e.style[l] = s + "px" } u(we, "setStylePx"); function gt(e, l, s, i) { let o = Pn.createElement(e); return l != null && Ze(o, l), s?.insertBefore(o, i), o } u(gt, "placeTag"); function tt(e, l) { return gt("div", e, l) } u(tt, "placeDiv"); var Pi = new WeakMap; function Zt(e, l, s, i, o) { let h = "translate(" + l + "px," + s + "px)", c = Pi.get(e); h != c && (e.style.transform = h, Pi.set(e, h), l < 0 || s < 0 || l > i || s > o ? Ze(e, Ft) : zn(e, Ft)) } u(Zt, "elTrans"); var Ci = new WeakMap; function Wo(e, l, s) { let i = l + s, o = Ci.get(e); i != o && (Ci.set(e, i), e.style.background = l, e.style.borderColor = s) } u(Wo, "elColor"); var zi = new WeakMap; function Go(e, l, s, i) { let o = l + "" + s, h = zi.get(e); o != h && (zi.set(e, o), e.style.height = s + "px", e.style.width = l + "px", e.style.marginLeft = i ? -l / 2 + "px" : 0, e.style.marginTop = i ? -s / 2 + "px" : 0) } u(Go, "elSize"); var Wn = { passive: !0 }, rs = { ...Wn, capture: !0 }; function xt(e, l, s, i) { l.addEventListener(e, s, i ? rs : Wn) } u(xt, "on"); function Rn(e, l, s, i) { l.removeEventListener(e, s, i ? rs : Wn) } u(Rn, "off"); il && Cn(); function kt(e, l, s, i) { let o; s = s || 0, i = i || l.length - 1; let h = i <= 2147483647; for (; i - s > 1;)o = h ? s + i >> 1 : lt((s + i) / 2), l[o] < e ? s = o : i = o; return e - l[s] <= l[i] - e ? s : i } u(kt, "closestIdx"); function Xt(e, l, s, i) { for (let o = i == 1 ? l : s; o >= l && o <= s; o += i)if (e[o] != null) return o; return -1 } u(Xt, "nonNullIdx"); function Io(e, l, s, i) { let o = Q, h = -Q; if (i == 1) o = e[l], h = e[s]; else if (i == -1) o = e[s], h = e[l]; else for (let c = l; c <= s; c++)e[c] != null && (o = Ye(o, e[c]), h = xe(h, e[c])); return [o, h] } u(Io, "getMinMax"); function Bo(e, l, s) { let i = Q, o = -Q; for (let h = l; h <= s; h++)e[h] > 0 && (i = Ye(i, e[h]), o = xe(o, e[h])); return [i == Q ? 1 : i, o == -Q ? 10 : o] } u(Bo, "getMinMaxLog"); function Jl(e, l, s, i) { let o = Vi(e), h = Vi(l), c = s == 10 ? dt : fs; e == l && (o == -1 ? (e *= s, l /= s) : (e /= s, l *= s)); let w = o == 1 ? lt : Kl, d = h == 1 ? Kl : lt, g = w(c(Ge(e))), _ = d(c(Ge(l))), y = el(s, g), p = el(s, _); return s == 10 && (g < 0 && (y = he(y, -g)), _ < 0 && (p = he(p, -_))), i || s == 2 ? (e = y * o, l = p * h) : (e = cs(e, y), l = ll(l, p)), [e, l] } u(Jl, "rangeLog"); function Gn(e, l, s, i) { let o = Jl(e, l, s, i); return e == 0 && (o[0] = 0), l == 0 && (o[1] = 0), o } u(Gn, "rangeAsinh"); var In = .1, Ri = { mode: 3, pad: In }, El = { pad: 0, soft: null, mode: 0 }, Uo = { min: El, max: El }; function Yl(e, l, s, i) { return $l(s) ? Fi(e, l, s) : (El.pad = s, El.soft = i ? 0 : null, El.mode = i ? 3 : 0, Fi(e, l, Uo)) } u(Yl, "rangeNum"); function se(e, l) { return e ?? l } u(se, "ifNull"); function Yo(e, l, s) { for (l = se(l, 0), s = se(s, e.length - 1); l <= s;) { if (e[l] != null) return !0; l++ } return !1 } u(Yo, "hasData"); function Fi(e, l, s) { let i = s.min, o = s.max, h = se(i.pad, 0), c = se(o.pad, 0), w = se(i.hard, -Q), d = se(o.hard, Q), g = se(i.soft, Q), _ = se(o.soft, -Q), y = se(i.mode, 0), p = se(o.mode, 0), A = l - e, z = dt(A), T = xe(Ge(e), Ge(l)), R = dt(T), Z = Ge(R - z); (A < 1e-9 || Z > 10) && (A = 0, (e == 0 || l == 0) && (A = 1e-9, y == 2 && g != Q && (h = 0), p == 2 && _ != -Q && (c = 0))); let F = A || T || 1e3, k = dt(F), P = el(10, lt(k)), E = F * (A == 0 ? e == 0 ? .1 : 1 : h), H = he(cs(e - E, P / 10), 9), D = e >= g && (y == 1 || y == 3 && H <= g || y == 2 && H >= g) ? g : Q, B = xe(w, H < D && e >= D ? D : Ye(D, H)), I = F * (A == 0 ? l == 0 ? .1 : 1 : c), N = he(ll(l + I, P / 10), 9), M = l <= _ && (p == 1 || p == 3 && N >= _ || p == 2 && N <= _) ? _ : -Q, O = Ye(d, N > M && l <= M ? M : xe(M, N)); return B == O && B == 0 && (O = 100), [B, O] } u(Fi, "_rangeNum"); var Ko = new Intl.NumberFormat(il ? Ho.language : "en-US"), Bn = u(e => Ko.format(e), "fmtNum"), $e = Math, Bl = $e.PI, Ge = $e.abs, lt = $e.floor, Ne = $e.round, Kl = $e.ceil, Ye = $e.min, xe = $e.max, el = $e.pow, Vi = $e.sign, dt = $e.log10, fs = $e.log2, jo = u((e, l = 1) => $e.sinh(e) * l, "sinh"), Tn = u((e, l = 1) => $e.asinh(e / l), "asinh"), Q = 1 / 0; function Ni(e) { return (dt((e ^ e >> 31) - (e >> 31)) | 0) + 1 } u(Ni, "numIntDigits"); function Oi(e, l, s) { return Ye(xe(e, l), s) } u(Oi, "clamp"); function $(e) { return typeof e == "function" ? e : () => e } u($, "fnOrSelf"); var qo = u(() => { }, "noop"), Jo = u(e => e, "retArg0"), us = u((e, l) => l, "retArg1"), Zo = u(e => null, "retNull"), Hi = u(e => !0, "retTrue"), Wi = u((e, l) => e == l, "retEq"), tl = u(e => he(e, 14), "fixFloat"); function Rt(e, l) { return tl(he(tl(e / l)) * l) } u(Rt, "incrRound"); function ll(e, l) { return tl(Kl(tl(e / l)) * l) } u(ll, "incrRoundUp"); function cs(e, l) { return tl(lt(tl(e / l)) * l) } u(cs, "incrRoundDn"); function he(e, l = 0) { if (Qo(e)) return e; let s = 10 ** l, i = e * s * (1 + Number.EPSILON); return Ne(i) / s } u(he, "roundDec"); var Zl = new Map; function $o(e) { return (("" + e).split(".")[1] || "").length } u($o, "guessDec"); function Dl(e, l, s, i) { let o = [], h = i.map($o); for (let c = l; c < s; c++) { let w = Ge(c), d = he(el(e, c), w); for (let g = 0; g < i.length; g++) { let _ = i[g] * d, y = (_ >= 0 && c >= 0 ? 0 : w) + (c >= h[g] ? 0 : h[g]), p = he(_, y); o.push(p), Zl.set(p, y) } } return o } u(Dl, "genIncrs"); var Tl = {}, as = [], nl = [null, null], Vt = Array.isArray, Qo = Number.isInteger, Xo = u(e => e === void 0, "isUndef"); function Gi(e) { return typeof e == "string" } u(Gi, "isStr"); function $l(e) { let l = !1; if (e != null) { let s = e.constructor; l = s == null || s == Object } return l } u($l, "isObj"); function Ii(e) { return e != null && typeof e == "object" } u(Ii, "fastIsObj"); var er = Object.getPrototypeOf(Uint8Array); function Nt(e, l = $l) { let s; if (Vt(e)) { let i = e.find(o => o != null); if (Vt(i) || l(i)) { s = Array(e.length); for (let o = 0; o < e.length; o++)s[o] = Nt(e[o], l) } else s = e.slice() } else if (e instanceof er) s = e.slice(); else if (l(e)) { s = {}; for (let i in e) s[i] = Nt(e[i], l) } else s = e; return s } u(Nt, "copy"); function Me(e) { let l = arguments; for (let s = 1; s < l.length; s++) { let i = l[s]; for (let o in i) $l(e[o]) ? Me(e[o], Nt(i[o])) : e[o] = Nt(i[o]) } return e } u(Me, "assign"); var tr = 0, lr = 1, nr = 2; function ir(e, l, s) { for (let i = 0, o, h = -1; i < l.length; i++) { let c = l[i]; if (c > h) { for (o = c - 1; o >= 0 && e[o] == null;)e[o--] = null; for (o = c + 1; o < s && e[o] == null;)e[h = o++] = null } } } u(ir, "nullExpand"); function sr(e, l) { let s = new Set; for (let c = 0; c < e.length; c++) { let d = e[c][0], g = d.length; for (let _ = 0; _ < g; _++)s.add(d[_]) } let i = [Array.from(s).sort((c, w) => c - w)], o = i[0].length, h = new Map; for (let c = 0; c < o; c++)h.set(i[0][c], c); for (let c = 0; c < e.length; c++) { let w = e[c], d = w[0]; for (let g = 1; g < w.length; g++) { let _ = w[g], y = Array(o).fill(void 0), p = l ? l[c][g] : lr, A = []; for (let z = 0; z < _.length; z++) { let T = _[z], R = h.get(d[z]); T === null ? p != tr && (y[R] = T, p == nr && A.push(R)) : y[R] = T } ir(y, A, o), i.push(y) } } return i } u(sr, "join"); var or = typeof queueMicrotask > "u" ? e => Promise.resolve().then(e) : queueMicrotask, hs = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], ps = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]; function ms(e) { return e.slice(0, 3) } u(ms, "slice3"); var rr = ps.map(ms), fr = hs.map(ms), ur = { MMMM: hs, MMM: fr, WWWW: ps, WWW: rr }; function bl(e) { return (e < 10 ? "0" : "") + e } u(bl, "zeroPad2"); function cr(e) { return (e < 10 ? "00" : e < 100 ? "0" : "") + e } u(cr, "zeroPad3"); var ar = { YYYY: e => e.getFullYear(), YY: e => (e.getFullYear() + "").slice(2), MMMM: (e, l) => l.MMMM[e.getMonth()], MMM: (e, l) => l.MMM[e.getMonth()], MM: e => bl(e.getMonth() + 1), M: e => e.getMonth() + 1, DD: e => bl(e.getDate()), D: e => e.getDate(), WWWW: (e, l) => l.WWWW[e.getDay()], WWW: (e, l) => l.WWW[e.getDay()], HH: e => bl(e.getHours()), H: e => e.getHours(), h: e => { let l = e.getHours(); return l == 0 ? 12 : l > 12 ? l - 12 : l }, AA: e => e.getHours() >= 12 ? "PM" : "AM", aa: e => e.getHours() >= 12 ? "pm" : "am", a: e => e.getHours() >= 12 ? "p" : "a", mm: e => bl(e.getMinutes()), m: e => e.getMinutes(), ss: e => bl(e.getSeconds()), s: e => e.getSeconds(), fff: e => cr(e.getMilliseconds()) }; function Un(e, l) { l = l || ur; let s = [], i = /\{([a-z]+)\}|[^{]+/gi, o; for (; o = i.exec(e);)s.push(o[0][0] == "{" ? ar[o[1]] : o[0]); return h => { let c = ""; for (let w = 0; w < s.length; w++)c += typeof s[w] == "string" ? s[w] : s[w](h, l); return c } } u(Un, "fmtDate"); var hr = new Intl.DateTimeFormat().resolvedOptions().timeZone; function pr(e, l) { let s; return l == "UTC" || l == "Etc/UTC" ? s = new Date(+e + e.getTimezoneOffset() * 6e4) : l == hr ? s = e : (s = new Date(e.toLocaleString("en-US", { timeZone: l })), s.setMilliseconds(e.getMilliseconds())), s } u(pr, "tzDate"); var gs = u(e => e % 1 == 0, "onlyWhole"), jl = [1, 2, 2.5, 5], mr = Dl(10, -16, 0, jl), ds = Dl(10, 0, 16, jl), gr = ds.filter(gs), dr = mr.concat(ds), Yn = `
`, ws = "{YYYY}", Bi = Yn + ws, Ss = "{M}/{D}", xl = Yn + Ss, Gl = xl + "/{YY}", _s = "{aa}", wr = "{h}:{mm}", $t = wr + _s, Ui = Yn + $t, Yi = ":{ss}", ue = null; function ys(e) { let l = e * 1e3, s = l * 60, i = s * 60, o = i * 24, h = o * 30, c = o * 365, d = (e == 1 ? Dl(10, 0, 3, jl).filter(gs) : Dl(10, -3, 0, jl)).concat([l, l * 5, l * 10, l * 15, l * 30, s, s * 5, s * 10, s * 15, s * 30, i, i * 2, i * 3, i * 4, i * 6, i * 8, i * 12, o, o * 2, o * 3, o * 4, o * 5, o * 6, o * 7, o * 8, o * 9, o * 10, o * 15, h, h * 2, h * 3, h * 4, h * 6, c, c * 2, c * 5, c * 10, c * 25, c * 50, c * 100]), g = [[c, ws, ue, ue, ue, ue, ue, ue, 1], [o * 28, "{MMM}", Bi, ue, ue, ue, ue, ue, 1], [o, Ss, Bi, ue, ue, ue, ue, ue, 1], [i, "{h}" + _s, Gl, ue, xl, ue, ue, ue, 1], [s, $t, Gl, ue, xl, ue, ue, ue, 1], [l, Yi, Gl + " " + $t, ue, xl + " " + $t, ue, Ui, ue, 1], [e, Yi + ".{fff}", Gl + " " + $t, ue, xl + " " + $t, ue, Ui, ue, 1]]; function _(y) { return (p, A, z, T, R, Z) => { let F = [], k = R >= c, P = R >= h && R < c, E = y(z), H = he(E * e, 3), D = Dn(E.getFullYear(), k ? 0 : E.getMonth(), P || k ? 1 : E.getDate()), B = he(D * e, 3); if (P || k) { let I = P ? R / h : 0, N = k ? R / c : 0, M = H == B ? H : he(Dn(D.getFullYear() + N, D.getMonth() + I, 1) * e, 3), O = new Date(Ne(M / e)), X = O.getFullYear(), ee = O.getMonth(); for (let Y = 0; M <= T; Y++) { let ce = Dn(X + N * Y, ee + I * Y, 1), U = ce - y(he(ce * e, 3)); M = he((+ce + U) * e, 3), M <= T && F.push(M) } } else { let I = R >= o ? o : R, N = lt(z) - lt(H), M = B + N + ll(H - B, I); F.push(M); let O = y(M), X = O.getHours() + O.getMinutes() / s + O.getSeconds() / i, ee = R / i, Y = p.axes[A]._space, ce = Z / Y; for (; M = he(M + R, e == 1 ? 0 : 3), !(M > T);)if (ee > 1) { let U = lt(he(X + ee, 6)) % 24, te = y(M).getHours() - U; te > 1 && (te = -1), M -= te * i, X = (X + ee) % 24; let oe = F[F.length - 1]; he((M - oe) / R, 3) * ce >= .7 && F.push(M) } else F.push(M) } return F } } return u(_, "timeAxisSplits"), [d, g, _] } u(ys, "genTimeStuffs"); var [Sr, _r, yr] = ys(1), [vr, br, Mr] = ys(.001); Dl(2, -53, 53, [1]); function Ki(e, l) { return e.map(s => s.map((i, o) => o == 0 || o == 8 || i == null ? i : l(o == 1 || s[8] == 0 ? i : s[1] + i))) } u(Ki, "timeAxisStamps"); function ji(e, l) { return (s, i, o, h, c) => { let w = l.find(z => c >= z[0]) || l[l.length - 1], d, g, _, y, p, A; return i.map(z => { let T = e(z), R = T.getFullYear(), Z = T.getMonth(), F = T.getDate(), k = T.getHours(), P = T.getMinutes(), E = T.getSeconds(), H = R != d && w[2] || Z != g && w[3] || F != _ && w[4] || k != y && w[5] || P != p && w[6] || E != A && w[7] || w[1]; return d = R, g = Z, _ = F, y = k, p = P, A = E, H(T) }) } } u(ji, "timeAxisVals"); function kr(e, l) { let s = Un(l); return (i, o, h, c, w) => o.map(d => s(e(d))) } u(kr, "timeAxisVal"); function Dn(e, l, s) { return new Date(e, l, s) } u(Dn, "mkDate"); function qi(e, l) { return l(e) } u(qi, "timeSeriesStamp"); var xr = "{YYYY}-{MM}-{DD} {h}:{mm}{aa}"; function Ji(e, l) { return (s, i, o, h) => h == null ? Hn : l(e(i)) } u(Ji, "timeSeriesVal"); function Er(e, l) { let s = e.series[l]; return s.width ? s.stroke(e, l) : s.points.width ? s.points.stroke(e, l) : null } u(Er, "legendStroke"); function Tr(e, l) { return e.series[l].fill(e, l) } u(Tr, "legendFill"); var Dr = { show: !0, live: !0, isolate: !1, mount: qo, markers: { show: !0, width: 2, stroke: Er, fill: Tr, dash: "solid" }, idx: null, idxs: null, values: [] }; function Ar(e, l) { let s = e.cursor.points, i = tt(), o = s.size(e, l); we(i, Ml, o), we(i, kl, o); let h = o / -2; we(i, "marginLeft", h), we(i, "marginTop", h); let c = s.width(e, l, o); return c && we(i, "borderWidth", c), i } u(Ar, "cursorPointShow"); function Lr(e, l) { let s = e.series[l].points; return s._fill || s._stroke } u(Lr, "cursorPointFill"); function Pr(e, l) { let s = e.series[l].points; return s._stroke || s._fill } u(Pr, "cursorPointStroke"); function Cr(e, l) { return e.series[l].points.size } u(Cr, "cursorPointSize"); function zr(e, l, s) { return s } u(zr, "dataIdx"); var An = [0, 0]; function Rr(e, l, s) { return An[0] = l, An[1] = s, An } u(Rr, "cursorMove"); function Il(e, l, s) { return i => { i.button == 0 && s(i) } } u(Il, "filtBtn0"); function Ln(e, l, s) { return s } u(Ln, "passThru"); var Fr = { show: !0, x: !0, y: !0, lock: !1, move: Rr, points: { show: Ar, size: Cr, width: 0, stroke: Pr, fill: Lr }, bind: { mousedown: Il, mouseup: Il, click: Il, dblclick: Il, mousemove: Ln, mouseleave: Ln, mouseenter: Ln }, drag: { setScale: !0, x: !0, y: !1, dist: 0, uni: null, click: (e, l) => { l.stopPropagation(), l.stopImmediatePropagation() }, _x: !1, _y: !1 }, focus: { prox: -1, bias: 0 }, left: -10, top: -10, idx: null, dataIdx: zr, idxs: null }, vs = { show: !0, stroke: "rgba(0,0,0,0.07)", width: 2 }, Kn = Me({}, vs, { filter: us }), bs = Me({}, Kn, { size: 10 }), Ms = Me({}, vs, { show: !1 }), jn = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"', ks = "bold " + jn, Vr = 1.5, Zi = { show: !0, scale: "x", stroke: On, space: 50, gap: 5, size: 50, labelGap: 0, labelSize: 30, labelFont: ks, side: 2, grid: Kn, ticks: bs, border: Ms, font: jn, rotate: 0 }, Nr = "Value", Or = "Time", $i = { show: !0, scale: "x", auto: !1, sorted: 1, min: Q, max: -Q, idxs: [] }; function Hr(e, l, s, i, o) { return l.map(h => h == null ? "" : Bn(h)) } u(Hr, "numAxisVals"); function Wr(e, l, s, i, o, h, c) { let w = [], d = Zl.get(o) || 0; s = c ? s : he(ll(s, o), d); for (let g = s; g <= i; g = he(g + o, d))w.push(Object.is(g, -0) ? 0 : g); return w } u(Wr, "numAxisSplits"); function Fn(e, l, s, i, o, h, c) { let w = [], d = e.scales[e.axes[l].scale].log, g = d == 10 ? dt : fs, _ = lt(g(s)); o = el(d, _), d == 10 && _ < 0 && (o = he(o, -_)); let y = s; do w.push(y), y = y + o, d == 10 && (y = he(y, Zl.get(o))), y >= o * d && (o = y); while (y <= i); return w } u(Fn, "logAxisSplits"); function Gr(e, l, s, i, o, h, c) { let d = e.scales[e.axes[l].scale].asinh, g = i > d ? Fn(e, l, xe(d, s), i, o) : [d], _ = i >= 0 && s <= 0 ? [0] : []; return (s < -d ? Fn(e, l, xe(d, -i), -s, o) : [d]).reverse().map(p => -p).concat(_, g) } u(Gr, "asinhAxisSplits"); var Ir = /./, Br = /[12357]/, Ur = /[125]/, Yr = /1/; function Kr(e, l, s, i, o) { let h = e.axes[s], c = h.scale, w = e.scales[c]; if (w.distr == 3 && w.log == 2) return l; let d = e.valToPos, g = h._space, _ = d(10, c), y = d(9, c) - _ >= g ? Ir : d(7, c) - _ >= g ? Br : d(5, c) - _ >= g ? Ur : Yr; return l.map(p => w.distr == 4 && p == 0 || y.test(p) ? p : null) } u(Kr, "log10AxisValsFilt"); function jr(e, l, s, i) { return i == null ? Hn : l == null ? "" : Bn(l) } u(jr, "numSeriesVal"); var Qi = { show: !0, scale: "y", stroke: On, space: 30, gap: 5, size: 50, labelGap: 0, labelSize: 30, labelFont: ks, side: 3, grid: Kn, ticks: bs, border: Ms, font: jn, rotate: 0 }; function qr(e, l) { let s = 3 + (e || 1) * 2; return he(s * l, 3) } u(qr, "ptDia"); function Jr(e, l) { let { scale: s, idxs: i } = e.series[0], o = e._data[0], h = e.valToPos(o[i[0]], s, !0), c = e.valToPos(o[i[1]], s, !0), w = Ge(c - h), d = e.series[l], g = w / (d.points.space * ie); return i[1] - i[0] <= g } u(Jr, "seriesPointsShow"); var Xi = { scale: null, auto: !0, sorted: 0, min: Q, max: -Q }, xs = u((e, l, s, i, o) => o, "gaps"), es = { show: !0, auto: !0, sorted: 0, gaps: xs, alpha: 1, facets: [Me({}, Xi, { scale: "x" }), Me({}, Xi, { scale: "y" })] }, ts = { scale: "y", auto: !0, sorted: 0, show: !0, spanGaps: !1, gaps: xs, alpha: 1, points: { show: Jr, filter: null }, values: null, min: Q, max: -Q, idxs: [], path: null, clip: null }; function Zr(e, l, s, i, o) { return s / 10 } u(Zr, "clampScale"); var Es = { time: !0, auto: !0, distr: 1, log: 10, asinh: 1, min: null, max: null, dir: 1, ori: 0 }, $r = Me({}, Es, { time: !1, ori: 1 }), ls = {}; function Ts(e, l) { let s = ls[e]; return s || (s = { key: e, plots: [], sub(i) { s.plots.push(i) }, unsub(i) { s.plots = s.plots.filter(o => o != i) }, pub(i, o, h, c, w, d, g) { for (let _ = 0; _ < s.plots.length; _++)s.plots[_] != o && s.plots[_].pub(i, o, h, c, w, d, g) } }, e != null && (ls[e] = s)), s } u(Ts, "_sync"); var Ot = 1, ql = 2; function Ht(e, l, s) { let i = e.mode, o = e.series[l], h = i == 2 ? e._data[l] : e._data, c = e.scales, w = e.bbox, d = h[0], g = i == 2 ? h[1] : h[l], _ = i == 2 ? c[o.facets[0].scale] : c[e.series[0].scale], y = i == 2 ? c[o.facets[1].scale] : c[o.scale], p = w.left, A = w.top, z = w.width, T = w.height, R = e.valToPosH, Z = e.valToPosV; return _.ori == 0 ? s(o, d, g, _, y, R, Z, p, A, z, T, en, sl, ln, As, Ps) : s(o, d, g, _, y, Z, R, A, p, T, z, tn, ol, Jn, Ls, Cs) } u(Ht, "orient"); function Ql(e, l) { let s = 0, i = 0, o = se(e.bands, as); for (let h = 0; h < o.length; h++) { let c = o[h]; c.series[0] == l ? s = c.dir : c.series[1] == l && (c.dir == 1 ? i |= 1 : i |= 2) } return [s, i == 1 ? -1 : i == 2 ? 1 : i == 3 ? 2 : 0] } u(Ql, "bandFillClipDirs"); function Qr(e, l, s, i, o) { let h = e.mode, c = e.series[l], w = h == 2 ? c.facets[1].scale : c.scale, d = e.scales[w]; return o == -1 ? d.min : o == 1 ? d.max : d.distr == 3 ? d.dir == 1 ? d.min : d.max : 0 } u(Qr, "seriesFillTo"); function wt(e, l, s, i, o, h) { return Ht(e, l, (c, w, d, g, _, y, p, A, z, T, R) => { let Z = c.pxRound, F = g.dir * (g.ori == 0 ? 1 : -1), k = g.ori == 0 ? sl : ol, P, E; F == 1 ? (P = s, E = i) : (P = i, E = s); let H = Z(y(w[P], g, T, A)), D = Z(p(d[P], _, R, z)), B = Z(y(w[E], g, T, A)), I = Z(p(h == 1 ? _.max : _.min, _, R, z)), N = new Path2D(o); return k(N, B, I), k(N, H, I), k(N, H, D), N }) } u(wt, "clipBandLine"); function Xl(e, l, s, i, o, h) { let c = null; if (e.length > 0) { c = new Path2D; let w = l == 0 ? ln : Jn, d = s; for (let _ = 0; _ < e.length; _++) { let y = e[_]; if (y[1] > y[0]) { let p = y[0] - d; p > 0 && w(c, d, i, p, i + h), d = y[1] } } let g = s + o - d; g > 0 && w(c, d, i, g, i + h) } return c } u(Xl, "clipGaps"); function Xr(e, l, s) { let i = e[e.length - 1]; i && i[0] == l ? i[1] = s : e.push([l, s]) } u(Xr, "addGap"); function qn(e, l, s, i, o, h, c) { let w = [], d = e.length; for (let g = o == 1 ? s : i; g >= s && g <= i; g += o)if (l[g] === null) { let y = g, p = g; if (o == 1) for (; ++g <= i && l[g] === null;)p = g; else for (; --g >= s && l[g] === null;)p = g; let A = h(e[y]), z = p == y ? A : h(e[p]), T = y - o; A = c <= 0 && T >= 0 && T < d ? h(e[T]) : A; let Z = p + o; z = c >= 0 && Z >= 0 && Z < d ? h(e[Z]) : z, z >= A && w.push([A, z]) } return w } u(qn, "findGaps"); function ns(e) { return e == 0 ? Jo : e == 1 ? Ne : l => Rt(l, e) } u(ns, "pxRoundGen"); function Ds(e) { let l = e == 0 ? en : tn, s = e == 0 ? (o, h, c, w, d, g) => { o.arcTo(h, c, w, d, g) } : (o, h, c, w, d, g) => { o.arcTo(c, h, d, w, g) }, i = e == 0 ? (o, h, c, w, d) => { o.rect(h, c, w, d) } : (o, h, c, w, d) => { o.rect(c, h, d, w) }; return (o, h, c, w, d, g = 0, _ = 0) => { g == 0 && _ == 0 ? i(o, h, c, w, d) : (g = Ye(g, w / 2, d / 2), _ = Ye(_, w / 2, d / 2), l(o, h + g, c), s(o, h + w, c, h + w, c + d, g), s(o, h + w, c + d, h, c + d, _), s(o, h, c + d, h, c, _), s(o, h, c, h + w, c, g), o.closePath()) } } u(Ds, "rect"); var en = u((e, l, s) => { e.moveTo(l, s) }, "moveToH"), tn = u((e, l, s) => { e.moveTo(s, l) }, "moveToV"), sl = u((e, l, s) => { e.lineTo(l, s) }, "lineToH"), ol = u((e, l, s) => { e.lineTo(s, l) }, "lineToV"), ln = Ds(0), Jn = Ds(1), As = u((e, l, s, i, o, h) => { e.arc(l, s, i, o, h) }, "arcH"), Ls = u((e, l, s, i, o, h) => { e.arc(s, l, i, o, h) }, "arcV"), Ps = u((e, l, s, i, o, h, c) => { e.bezierCurveTo(l, s, i, o, h, c) }, "bezierCurveToH"), Cs = u((e, l, s, i, o, h, c) => { e.bezierCurveTo(s, l, o, i, c, h) }, "bezierCurveToV"); function zs(e) { return (l, s, i, o, h) => Ht(l, s, (c, w, d, g, _, y, p, A, z, T, R) => { let { pxRound: Z, points: F } = c, k, P; g.ori == 0 ? (k = en, P = As) : (k = tn, P = Ls); let E = he(F.width * ie, 3), H = (F.size - F.width) / 2 * ie, D = he(H * 2, 3), B = new Path2D, I = new Path2D, { left: N, top: M, width: O, height: X } = l.bbox; ln(I, N - D, M - D, O + D * 2, X + D * 2); let ee = u(Y => { if (d[Y] != null) { let ce = Z(y(w[Y], g, T, A)), U = Z(p(d[Y], _, R, z)); k(B, ce + H, U), P(B, ce, U, H, 0, Bl * 2) } }, "drawPoint"); if (h) h.forEach(ee); else for (let Y = i; Y <= o; Y++)ee(Y); return { stroke: E > 0 ? B : null, fill: B, clip: I, flags: Ot | ql } }) } u(zs, "points"); function Rs(e) { return (l, s, i, o, h, c) => { i != o && (h != i && c != i && e(l, s, i), h != o && c != o && e(l, s, o), e(l, s, c)) } } u(Rs, "_drawAcc"); var ef = Rs(sl), tf = Rs(ol); function Fs(e) { let l = se(e?.alignGaps, 0); return (s, i, o, h) => Ht(s, i, (c, w, d, g, _, y, p, A, z, T, R) => { let Z = c.pxRound, F = u(V => Z(y(V, g, T, A)), "pixelForX"), k = u(V => Z(p(V, _, R, z)), "pixelForY"), P, E; g.ori == 0 ? (P = sl, E = ef) : (P = ol, E = tf); let H = g.dir * (g.ori == 0 ? 1 : -1), D = { stroke: new Path2D, fill: null, clip: null, band: null, gaps: null, flags: Ot }, B = D.stroke, I = Q, N = -Q, M, O, X, ee = F(w[H == 1 ? o : h]), Y = Xt(d, o, h, 1 * H), ce = Xt(d, o, h, -1 * H), U = F(w[Y]), Qe = F(w[ce]), ze = !1; for (let V = H == 1 ? o : h; V >= o && V <= h; V += H) { let me = F(w[V]), W = d[V]; me == ee ? W != null ? (O = k(W), I == Q && (P(B, me, O), M = O), I = Ye(O, I), N = xe(O, N)) : W === null && (ze = !0) : (I != Q && (E(B, ee, I, N, M, O), X = ee), W != null ? (O = k(W), P(B, me, O), I = N = M = O) : (I = Q, N = -Q, W === null && (ze = !0)), ee = me) } I != Q && I != N && X != ee && E(B, ee, I, N, M, O); let [te, oe] = Ql(s, i); if (c.fill != null || te != 0) { let V = D.fill = new Path2D(B), me = c.fillTo(s, i, c.min, c.max, te), W = k(me); P(V, Qe, W), P(V, U, W) } if (!c.spanGaps) { let V = []; ze && V.push(...qn(w, d, o, h, H, F, l)), D.gaps = V = c.gaps(s, i, o, h, V), D.clip = Xl(V, g.ori, A, z, T, R) } return oe != 0 && (D.band = oe == 2 ? [wt(s, i, o, h, B, -1), wt(s, i, o, h, B, 1)] : wt(s, i, o, h, B, oe)), D }) } u(Fs, "linear"); function lf(e) { let l = se(e.align, 1), s = se(e.ascDesc, !1), i = se(e.alignGaps, 0), o = se(e.extend, !1); return (h, c, w, d) => Ht(h, c, (g, _, y, p, A, z, T, R, Z, F, k) => { let P = g.pxRound, { left: E, width: H } = h.bbox, D = u(te => P(z(te, p, F, R)), "pixelForX"), B = u(te => P(T(te, A, k, Z)), "pixelForY"), I = p.ori == 0 ? sl : ol, N = { stroke: new Path2D, fill: null, clip: null, band: null, gaps: null, flags: Ot }, M = N.stroke, O = p.dir * (p.ori == 0 ? 1 : -1); w = Xt(y, w, d, 1), d = Xt(y, w, d, -1); let X = B(y[O == 1 ? w : d]), ee = D(_[O == 1 ? w : d]), Y = ee, ce = ee; o && l == -1 && (ce = E, I(M, ce, X)), I(M, ee, X); for (let te = O == 1 ? w : d; te >= w && te <= d; te += O) { let oe = y[te]; if (oe == null) continue; let V = D(_[te]), me = B(oe); l == 1 ? I(M, V, X) : I(M, Y, me), I(M, V, me), X = me, Y = V } let U = Y; o && l == 1 && (U = E + H, I(M, U, X)); let [Qe, ze] = Ql(h, c); if (g.fill != null || Qe != 0) { let te = N.fill = new Path2D(M), oe = g.fillTo(h, c, g.min, g.max, Qe), V = B(oe); I(te, U, V), I(te, ce, V) } if (!g.spanGaps) { let te = []; te.push(...qn(_, y, w, d, O, D, i)); let oe = g.width * ie / 2, V = s || l == 1 ? oe : -oe, me = s || l == -1 ? -oe : oe; te.forEach(W => { W[0] += V, W[1] += me }), N.gaps = te = g.gaps(h, c, w, d, te), N.clip = Xl(te, p.ori, R, Z, F, k) } return ze != 0 && (N.band = ze == 2 ? [wt(h, c, w, d, M, -1), wt(h, c, w, d, M, 1)] : wt(h, c, w, d, M, ze)), N }) } u(lf, "stepped"); function nf(e) { e = e || Tl; let l = se(e.size, [.6, Q, 1]), s = e.align || 0, i = (e.gap || 0) * ie, o = e.radius; o = o == null ? [0, 0] : typeof o == "number" ? [o, 0] : o; let h = $(o), c = 1 - l[0], w = se(l[1], Q) * ie, d = se(l[2], 1) * ie, g = se(e.disp, Tl), _ = se(e.each, A => { }), { fill: y, stroke: p } = g; return (A, z, T, R) => Ht(A, z, (Z, F, k, P, E, H, D, B, I, N, M) => { let O = Z.pxRound, X, ee; P.ori == 0 ? [X, ee] = h(A, z) : [ee, X] = h(A, z); let Y = P.dir * (P.ori == 0 ? 1 : -1), ce = E.dir * (E.ori == 1 ? 1 : -1), U = P.ori == 0 ? ln : Jn, Qe = P.ori == 0 ? _ : (j, Se, He, Ee, Ie, Te, it) => { _(j, Se, He, Ie, Ee, it, Te) }, [ze, te] = Ql(A, z), oe = E.distr == 3 ? ze == 1 ? E.max : E.min : 0, V = D(oe, E, M, I), me, W, ae = O(Z.width * ie), nt = !1, St = null, ht = null, Xe = null, _t = null; y != null && (ae == 0 || p != null) && (nt = !0, St = y.values(A, z, T, R), ht = new Map, new Set(St).forEach(j => { j != null && ht.set(j, new Path2D) }), ae > 0 && (Xe = p.values(A, z, T, R), _t = new Map, new Set(Xe).forEach(j => { j != null && _t.set(j, new Path2D) }))); let { x0: rl, size: Wt } = g; if (rl != null && Wt != null) { F = rl.values(A, z, T, R), rl.unit == 2 && (F = F.map(Se => A.posToVal(B + Se * N, P.key, !0))); let j = Wt.values(A, z, T, R); Wt.unit == 2 ? W = j[0] * N : W = H(j[0], P, N, B) - H(0, P, N, B), W = O(W - ae), me = Y == 1 ? -ae / 2 : W + ae / 2 } else { let j = N; if (F.length > 1) { let He = null; for (let Ee = 0, Ie = 1 / 0; Ee < F.length; Ee++)if (k[Ee] !== void 0) { if (He != null) { let Te = Ge(F[Ee] - F[He]); Te < Ie && (Ie = Te, j = Ge(H(F[Ee], P, N, B) - H(F[He], P, N, B))) } He = Ee } } let Se = j * c; W = O(Ye(w, xe(d, j - Se)) - ae - i), me = (s == 0 ? W / 2 : s == Y ? 0 : W) - s * Y * i / 2 } let Et = { stroke: null, fill: null, clip: null, band: null, gaps: null, flags: Ot | ql }, fl; te != 0 && (Et.band = new Path2D, fl = O(D(te == 1 ? E.max : E.min, E, M, I))); let pt = nt ? null : new Path2D, ft = Et.band, { y0: ul, y1: Tt } = g, yt = null; ul != null && Tt != null && (k = Tt.values(A, z, T, R), yt = ul.values(A, z, T, R)); let le = X * W, ne = ee * W; for (let j = Y == 1 ? T : R; j >= T && j <= R; j += Y) { let Se = k[j]; if (Se === void 0) continue; let He = P.distr != 2 || g != null ? F[j] : j, Ee = H(He, P, N, B), Ie = D(se(Se, oe), E, M, I); yt != null && Se != null && (V = D(yt[j], E, M, I)); let Te = O(Ee - me), it = O(xe(Ie, V)), Be = O(Ye(Ie, V)), Je = it - Be; if (Se != null) { let ut = Se < 0 ? ne : le, Dt = Se < 0 ? le : ne; nt ? (ae > 0 && Xe[j] != null && U(_t.get(Xe[j]), Te, Be + lt(ae / 2), W, xe(0, Je - ae), ut, Dt), St[j] != null && U(ht.get(St[j]), Te, Be + lt(ae / 2), W, xe(0, Je - ae), ut, Dt)) : U(pt, Te, Be + lt(ae / 2), W, xe(0, Je - ae), ut, Dt), Qe(A, z, j, Te - ae / 2, Be, W + ae, Je) } te != 0 && (ce * te == 1 ? (it = Be, Be = fl) : (Be = it, it = fl), Je = it - Be, U(ft, Te - ae / 2, Be, W + ae, xe(0, Je), 0, 0)) } return ae > 0 && (Et.stroke = nt ? _t : pt), Et.fill = nt ? ht : pt, Et }) } u(nf, "bars"); function sf(e, l) { let s = se(l?.alignGaps, 0); return (i, o, h, c) => Ht(i, o, (w, d, g, _, y, p, A, z, T, R, Z) => { let F = w.pxRound, k = u(U => F(p(U, _, R, z)), "pixelForX"), P = u(U => F(A(U, y, Z, T)), "pixelForY"), E, H, D; _.ori == 0 ? (E = en, D = sl, H = Ps) : (E = tn, D = ol, H = Cs); let B = _.dir * (_.ori == 0 ? 1 : -1); h = Xt(g, h, c, 1), c = Xt(g, h, c, -1); let I = k(d[B == 1 ? h : c]), N = I, M = [], O = []; for (let U = B == 1 ? h : c; U >= h && U <= c; U += B)if (g[U] != null) { let ze = d[U], te = k(ze); M.push(N = te), O.push(P(g[U])) } let X = { stroke: e(M, O, E, D, H, F), fill: null, clip: null, band: null, gaps: null, flags: Ot }, ee = X.stroke, [Y, ce] = Ql(i, o); if (w.fill != null || Y != 0) { let U = X.fill = new Path2D(ee), Qe = w.fillTo(i, o, w.min, w.max, Y), ze = P(Qe); D(U, N, ze), D(U, I, ze) } if (!w.spanGaps) { let U = []; U.push(...qn(d, g, h, c, B, k, s)), X.gaps = U = w.gaps(i, o, h, c, U), X.clip = Xl(U, _.ori, z, T, R, Z) } return ce != 0 && (X.band = ce == 2 ? [wt(i, o, h, c, ee, -1), wt(i, o, h, c, ee, 1)] : wt(i, o, h, c, ee, ce)), X }) } u(sf, "splineInterp"); function of(e) { return sf(rf, e) } u(of, "monotoneCubic"); function rf(e, l, s, i, o, h) { let c = e.length; if (c < 2) return null; let w = new Path2D; if (s(w, e[0], l[0]), c == 2) i(w, e[1], l[1]); else { let d = Array(c), g = Array(c - 1), _ = Array(c - 1), y = Array(c - 1); for (let p = 0; p < c - 1; p++)_[p] = l[p + 1] - l[p], y[p] = e[p + 1] - e[p], g[p] = _[p] / y[p]; d[0] = g[0]; for (let p = 1; p < c - 1; p++)g[p] === 0 || g[p - 1] === 0 || g[p - 1] > 0 != g[p] > 0 ? d[p] = 0 : (d[p] = 3 * (y[p - 1] + y[p]) / ((2 * y[p] + y[p - 1]) / g[p - 1] + (y[p] + 2 * y[p - 1]) / g[p]), isFinite(d[p]) || (d[p] = 0)); d[c - 1] = g[c - 2]; for (let p = 0; p < c - 1; p++)o(w, e[p] + y[p] / 3, l[p] + d[p] * y[p] / 3, e[p + 1] - y[p] / 3, l[p + 1] - d[p + 1] * y[p] / 3, e[p + 1], l[p + 1]) } return w } u(rf, "_monotoneCubic"); var Vn = new Set; function is() { for (let e of Vn) e.syncRect(!0) } u(is, "invalidateRects"); il && (xt(No, Qt, is), xt(Oo, Qt, is, !0), xt(Ul, Qt, () => { Oe.pxRatio = ie })); var ff = Fs(), uf = zs(); function ss(e, l, s, i) { return (i ? [e[0], e[1]].concat(e.slice(2)) : [e[0]].concat(e.slice(1))).map((h, c) => Nn(h, c, l, s)) } u(ss, "setDefaults"); function cf(e, l) { return e.map((s, i) => i == 0 ? null : Me({}, l, s)) } u(cf, "setDefaults2"); function Nn(e, l, s, i) { return Me({}, l == 0 ? s : i, e) } u(Nn, "setDefault"); function Vs(e, l, s) { return l == null ? nl : [l, s] } u(Vs, "snapNumX"); var af = Vs; function hf(e, l, s) { return l == null ? nl : Yl(l, s, In, !0) } u(hf, "snapNumY"); function Ns(e, l, s, i) { return l == null ? nl : Jl(l, s, e.scales[i].log, !1) } u(Ns, "snapLogY"); var pf = Ns; function Os(e, l, s, i) { return l == null ? nl : Gn(l, s, e.scales[i].log, !1) } u(Os, "snapAsinhY"); var mf = Os; function gf(e, l, s, i, o) { let h = xe(Ni(e), Ni(l)), c = l - e, w = kt(o / i * c, s); do { let d = s[w], g = i * d / c; if (g >= o && h + (d < 5 ? Zl.get(d) : 0) <= 17) return [d, g] } while (++w < s.length); return [0, 0] } u(gf, "findIncr"); function os(e) { let l, s; return e = e.replace(/(\d+)px/, (i, o) => (l = Ne((s = +o) * ie)) + "px"), [e, l, s] } u(os, "pxRatioFont"); function df(e) { e.show && [e.font, e.labelFont].forEach(l => { let s = he(l[2] * ie, 1); l[0] = l[0].replace(/[0-9.]+px/, s + "px"), l[1] = s }) } u(df, "syncFontSize"); function Oe(e, l, s) {
        let i = { mode: se(e.mode, 1) }, o = i.mode; function h(t, n) { return ((n.distr == 3 ? dt(t > 0 ? t : n.clamp(i, t, n.min, n.max, n.key)) : n.distr == 4 ? Tn(t, n.asinh) : t) - n._min) / (n._max - n._min) } u(h, "getValPct"); function c(t, n, r, f) { let a = h(t, n); return f + r * (n.dir == -1 ? 1 - a : a) } u(c, "getHPos"); function w(t, n, r, f) { let a = h(t, n); return f + r * (n.dir == -1 ? a : 1 - a) } u(w, "getVPos"); function d(t, n, r, f) { return n.ori == 0 ? c(t, n, r, f) : w(t, n, r, f) } u(d, "getPos"), i.valToPosH = c, i.valToPosV = w; let g = !1; i.status = 0; let _ = i.root = tt(So); if (e.id != null && (_.id = e.id), Ze(_, e.class), e.title) { let t = tt(vo, _); t.textContent = e.title } let y = gt("canvas"), p = i.ctx = y.getContext("2d"), A = tt(bo, _); xt("click", A, t => { (ge != It || de != Bt) && Re.click(i, t) }, !0); let z = i.under = tt(Mo, A); A.appendChild(y); let T = i.over = tt(ko, A); e = Nt(e); let R = +se(e.pxAlign, 1), Z = ns(R); (e.plugins || []).forEach(t => { t.opts && (e = t.opts(i, e) || e) }); let F = e.ms || .001, k = i.series = o == 1 ? ss(e.series || [], $i, ts, !1) : cf(e.series || [null], es), P = i.axes = ss(e.axes || [], Zi, Qi, !0), E = i.scales = {}, H = i.bands = e.bands || []; H.forEach(t => { t.fill = $(t.fill || null), t.dir = se(t.dir, -1) }); let D = o == 2 ? k[1].facets[0].scale : k[0].scale, B = { axes: to, series: Zs }, I = (e.drawOrder || ["axes", "series"]).map(t => B[t]); function N(t) { let n = E[t]; if (n == null) { let r = (e.scales || Tl)[t] || Tl; if (r.from != null) N(r.from), E[t] = Me({}, E[r.from], r, { key: t }); else { n = E[t] = Me({}, t == D ? Es : $r, r), n.key = t; let f = n.time, a = n.range, m = Vt(a); if ((t != D || o == 2 && !f) && (m && (a[0] == null || a[1] == null) && (a = { min: a[0] == null ? Ri : { mode: 1, hard: a[0], soft: a[0] }, max: a[1] == null ? Ri : { mode: 1, hard: a[1], soft: a[1] } }, m = !1), !m && $l(a))) { let S = a; a = u((b, x, C) => x == null ? nl : Yl(x, C, S), "rn") } n.range = $(a || (f ? af : t == D ? n.distr == 3 ? pf : n.distr == 4 ? mf : Vs : n.distr == 3 ? Ns : n.distr == 4 ? Os : hf)), n.auto = $(m ? !1 : n.auto), n.clamp = $(n.clamp || Zr), n._min = n._max = null } } } u(N, "initScale"), N("x"), N("y"), o == 1 && k.forEach(t => { N(t.scale) }), P.forEach(t => { N(t.scale) }); for (let t in e.scales) N(t); let M = E[D], O = M.distr, X, ee; M.ori == 0 ? (Ze(_, _o), X = c, ee = w) : (Ze(_, yo), X = w, ee = c); let Y = {}; for (let t in E) { let n = E[t]; (n.min != null || n.max != null) && (Y[t] = { min: n.min, max: n.max }, n.min = n.max = null) } let ce = e.tzDate || (t => new Date(Ne(t / F))), U = e.fmtDate || Un, Qe = F == 1 ? yr(ce) : Mr(ce), ze = ji(ce, Ki(F == 1 ? _r : br, U)), te = Ji(ce, qi(xr, U)), oe = [], V = i.legend = Me({}, Dr, e.legend), me = V.show, W = V.markers; V.idxs = oe, W.width = $(W.width), W.dash = $(W.dash), W.stroke = $(W.stroke), W.fill = $(W.fill); let ae, nt = [], St = [], ht, Xe = !1, _t = {}; if (V.live) { let t = k[1] ? k[1].values : null; Xe = t != null, ht = Xe ? t(i, 1, 0) : { _: 0 }; for (let n in ht) _t[n] = Hn } if (me) if (ae = gt("table", Lo, _), V.mount(i, ae), Xe) { let t = gt("tr", zo, ae); gt("th", null, t); for (var rl in ht) gt("th", bi, t).textContent = rl } else Ze(ae, Co), V.live && Ze(ae, Po); let Wt = { show: !0 }, Et = { show: !1 }; function fl(t, n) { if (n == 0 && (Xe || !V.live || o == 2)) return nl; let r = [], f = gt("tr", Ro, ae, ae.childNodes[n]); Ze(f, t.class), t.show || Ze(f, Ft); let a = gt("th", null, f); if (W.show) { let b = tt(Fo, a); if (n > 0) { let x = W.width(i, n); x && (b.style.border = x + "px " + W.dash(i, n) + " " + W.stroke(i, n)), b.style.background = W.fill(i, n) } } let m = tt(bi, a); m.textContent = t.label, n > 0 && (W.show || (m.style.color = t.width > 0 ? W.stroke(i, n) : W.fill(i, n)), ft("click", a, b => { if (G._lock) return; let x = k.indexOf(t); if ((b.ctrlKey || b.metaKey) != V.isolate) { let C = k.some((v, L) => L > 0 && L != x && v.show); k.forEach((v, L) => { L > 0 && ct(L, C ? L == x ? Wt : Et : Wt, !0, Ve.setSeries) }) } else ct(x, { show: !t.show }, !0, Ve.setSeries) }), cl && ft(Ti, a, b => { G._lock || ct(k.indexOf(t), Yt, !0, Ve.setSeries) })); for (var S in ht) { let b = gt("td", Vo, f); b.textContent = "--", r.push(b) } return [f, r] } u(fl, "initLegendRow"); let pt = new Map; function ft(t, n, r) { let f = pt.get(n) || {}, a = G.bind[t](i, n, r); a && (xt(t, n, f[t] = a), pt.set(n, f)) } u(ft, "onMouse"); function ul(t, n, r) { let f = pt.get(n) || {}; for (let a in f) (t == null || a == t) && (Rn(a, n, f[a]), delete f[a]); t == null && pt.delete(n) } u(ul, "offMouse"); let Tt = 0, yt = 0, le = 0, ne = 0, j = 0, Se = 0, He = 0, Ee = 0, Ie = 0, Te = 0; i.bbox = {}; let it = !1, Be = !1, Je = !1, ut = !1, Dt = !1, et = !1; function nn(t, n, r) { (r || t != i.width || n != i.height) && Zn(t, n), pl(!1), Je = !0, Be = !0, G.left >= 0 && (ut = et = !0), Pt() } u(nn, "_setSize"); function Zn(t, n) { i.width = Tt = le = t, i.height = yt = ne = n, j = Se = 0, Is(), Bs(); let r = i.bbox; He = r.left = Rt(j * ie, .5), Ee = r.top = Rt(Se * ie, .5), Ie = r.width = Rt(le * ie, .5), Te = r.height = Rt(ne * ie, .5) } u(Zn, "calcSize"); let Hs = 3; function Ws() { let t = !1, n = 0; for (; !t;) { n++; let r = Xs(n), f = eo(n); t = n == Hs || r && f, t || (Zn(i.width, i.height), Be = !0) } } u(Ws, "convergeSize"); function Gs({ width: t, height: n }) { nn(t, n) } u(Gs, "setSize"), i.setSize = Gs; function Is() { let t = !1, n = !1, r = !1, f = !1; P.forEach((a, m) => { if (a.show && a._show) { let { side: S, _size: b } = a, x = S % 2, C = a.label != null ? a.labelSize : 0, v = b + C; v > 0 && (x ? (le -= v, S == 3 ? (j += v, f = !0) : r = !0) : (ne -= v, S == 0 ? (Se += v, t = !0) : n = !0)) } }), Lt[0] = t, Lt[1] = r, Lt[2] = n, Lt[3] = f, le -= vt[1] + vt[3], j += vt[3], ne -= vt[2] + vt[0], Se += vt[0] } u(Is, "calcPlotRect"); function Bs() { let t = j + le, n = Se + ne, r = j, f = Se; function a(m, S) { switch (m) { case 1: return t += S, t - S; case 2: return n += S, n - S; case 3: return r -= S, r + S; case 0: return f -= S, f + S } } u(a, "incrOffset"), P.forEach((m, S) => { if (m.show && m._show) { let b = m.side; m._pos = a(b, m._size), m.label != null && (m._lpos = a(b, m.labelSize)) } }) } u(Bs, "calcAxesRects"); let G = i.cursor = Me({}, Fr, { drag: { y: o == 2 } }, e.cursor); { G.idxs = oe, G._lock = !1; let t = G.points; t.show = $(t.show), t.size = $(t.size), t.stroke = $(t.stroke), t.width = $(t.width), t.fill = $(t.fill) } let At = i.focus = Me({}, e.focus || { alpha: .3 }, G.focus); At.bias != 0 && (At.prox = 1e5); let cl = At.prox >= 0, Ke = [null]; function Us(t, n) { if (n > 0) { let r = G.points.show(i, n); if (r) return Ze(r, Ao), Ze(r, t.class), Zt(r, -10, -10, le, ne), T.insertBefore(r, Ke[n]), r } } u(Us, "initCursorPt"); function $n(t, n) { if (o == 1 || n > 0) { let r = o == 1 && E[t.scale].time, f = t.value; t.value = r ? Gi(f) ? Ji(ce, qi(f, U)) : f || te : f || jr, t.label = t.label || (r ? Or : Nr) } if (n > 0) { t.width = t.width == null ? 1 : t.width, t.paths = t.paths || ff || Zo, t.fillTo = $(t.fillTo || Qr), t.pxAlign = +se(t.pxAlign, R), t.pxRound = ns(t.pxAlign), t.stroke = $(t.stroke || null), t.fill = $(t.fill || null), t._stroke = t._fill = t._paths = t._focus = null; let r = qr(xe(1, t.width), 1), f = t.points = Me({}, { size: r, width: xe(1, r * .2), stroke: t.stroke, space: r * 2, paths: uf, _stroke: null, _fill: null }, t.points); f.show = $(f.show), f.filter = $(f.filter), f.fill = $(f.fill), f.stroke = $(f.stroke), f.paths = $(f.paths), f.pxAlign = t.pxAlign } if (me) { let r = fl(t, n); nt.splice(n, 0, r[0]), St.splice(n, 0, r[1]), V.values.push(null) } if (G.show) { oe.splice(n, 0, null); let r = Us(t, n); r && Ke.splice(n, 0, r) } Fe("addSeries", n) } u($n, "initSeries"); function Ys(t, n) { n = n ?? k.length, t = o == 1 ? Nn(t, n, $i, ts) : Nn(t, n, null, es), k.splice(n, 0, t), $n(k[n], n) } u(Ys, "addSeries"), i.addSeries = Ys; function Ks(t) { if (k.splice(t, 1), me) { V.values.splice(t, 1), St.splice(t, 1); let n = nt.splice(t, 1)[0]; ul(null, n.firstChild), n.remove() } G.show && (oe.splice(t, 1), Ke.length > 1 && Ke.splice(t, 1)[0].remove()), Fe("delSeries", t) } u(Ks, "delSeries"), i.delSeries = Ks; let Lt = [!1, !1, !1, !1]; function js(t, n) { if (t._show = t.show, t.show) { let r = t.side % 2, f = E[t.scale]; f == null && (t.scale = r ? k[1].scale : D, f = E[t.scale]); let a = f.time; t.size = $(t.size), t.space = $(t.space), t.rotate = $(t.rotate), t.incrs = $(t.incrs || (f.distr == 2 ? gr : a ? F == 1 ? Sr : vr : dr)), t.splits = $(t.splits || (a && f.distr == 1 ? Qe : f.distr == 3 ? Fn : f.distr == 4 ? Gr : Wr)), t.stroke = $(t.stroke), t.grid.stroke = $(t.grid.stroke), t.ticks.stroke = $(t.ticks.stroke), t.border.stroke = $(t.border.stroke); let m = t.values; t.values = Vt(m) && !Vt(m[0]) ? $(m) : a ? Vt(m) ? ji(ce, Ki(m, U)) : Gi(m) ? kr(ce, m) : m || ze : m || Hr, t.filter = $(t.filter || (f.distr >= 3 && f.log == 10 ? Kr : us)), t.font = os(t.font), t.labelFont = os(t.labelFont), t._size = t.size(i, null, n, 0), t._space = t._rotate = t._incrs = t._found = t._splits = t._values = null, t._size > 0 && (Lt[n] = !0, t._el = tt(xo, A)) } } u(js, "initAxis"); function al(t, n, r, f) { let [a, m, S, b] = r, x = n % 2, C = 0; return x == 0 && (b || m) && (C = n == 0 && !a || n == 2 && !S ? Ne(Zi.size / 3) : 0), x == 1 && (a || S) && (C = n == 1 && !m || n == 3 && !b ? Ne(Qi.size / 2) : 0), C } u(al, "autoPadSide"); let Qn = i.padding = (e.padding || [al, al, al, al]).map(t => $(se(t, al))), vt = i._padding = Qn.map((t, n) => t(i, n, Lt, 0)), De, Ae = null, Le = null, Al = o == 1 ? k[0].idxs : null, st = null, Ll = !1; function Xn(t, n) { if (l = t == null ? [] : Nt(t, Ii), o == 2) { De = 0; for (let r = 1; r < k.length; r++)De += l[r][0].length; i.data = l = t } else if (l[0] == null && (l[0] = []), i.data = l.slice(), st = l[0], De = st.length, O == 2) { l[0] = Array(De); for (let r = 0; r < De; r++)l[0][r] = r } if (i._data = l, pl(!0), Fe("setData"), O == 2 && (Je = !0), n !== !1) { let r = M; r.auto(i, Ll) ? sn() : Ut(D, r.min, r.max), ut = G.left >= 0, et = !0, Pt() } } u(Xn, "setData"), i.setData = Xn; function sn() { Ll = !0; let t, n; o == 1 && (De > 0 ? (Ae = Al[0] = 0, Le = Al[1] = De - 1, t = l[0][Ae], n = l[0][Le], O == 2 ? (t = Ae, n = Le) : De == 1 && (O == 3 ? [t, n] = Jl(t, t, M.log, !1) : O == 4 ? [t, n] = Gn(t, t, M.log, !1) : M.time ? n = t + Ne(86400 / F) : [t, n] = Yl(t, n, In, !0))) : (Ae = Al[0] = t = null, Le = Al[1] = n = null)), Ut(D, t, n) } u(sn, "autoScaleX"); let Pl, Gt, on, rn, fn, un, cn, an, hn, hl; function ei(t, n, r, f, a, m) { t ??= ki, r ??= as, f ??= "butt", a ??= ki, m ??= "round", t != Pl && (p.strokeStyle = Pl = t), a != Gt && (p.fillStyle = Gt = a), n != on && (p.lineWidth = on = n), m != fn && (p.lineJoin = fn = m), f != un && (p.lineCap = un = f), r != rn && p.setLineDash(rn = r) } u(ei, "setCtxStyle"); function ti(t, n, r, f) { n != Gt && (p.fillStyle = Gt = n), t != cn && (p.font = cn = t), r != an && (p.textAlign = an = r), f != hn && (p.textBaseline = hn = f) } u(ti, "setFontStyle"); function pn(t, n, r, f, a = 0) { if (f.length > 0 && t.auto(i, Ll) && (n == null || n.min == null)) { let m = se(Ae, 0), S = se(Le, f.length - 1), b = r.min == null ? t.distr == 3 ? Bo(f, m, S) : Io(f, m, S, a) : [r.min, r.max]; t.min = Ye(t.min, r.min = b[0]), t.max = xe(t.max, r.max = b[1]) } } u(pn, "accScale"); function qs() { let t = Nt(E, Ii); for (let f in t) { let a = t[f], m = Y[f]; if (m != null && m.min != null) Me(a, m), f == D && pl(!0); else if (f != D || o == 2) if (De == 0 && a.from == null) { let S = a.range(i, null, null, f); a.min = S[0], a.max = S[1] } else a.min = Q, a.max = -Q } if (De > 0) { k.forEach((f, a) => { if (o == 1) { let m = f.scale, S = t[m], b = Y[m]; if (a == 0) { let x = S.range(i, S.min, S.max, m); S.min = x[0], S.max = x[1], Ae = kt(S.min, l[0]), Le = kt(S.max, l[0]), Le - Ae > 1 && (l[0][Ae] < S.min && Ae++, l[0][Le] > S.max && Le--), f.min = st[Ae], f.max = st[Le] } else f.show && f.auto && pn(S, b, f, l[a], f.sorted); f.idxs[0] = Ae, f.idxs[1] = Le } else if (a > 0 && f.show && f.auto) { let [m, S] = f.facets, b = m.scale, x = S.scale, [C, v] = l[a]; pn(t[b], Y[b], m, C, m.sorted), pn(t[x], Y[x], S, v, S.sorted), f.min = S.min, f.max = S.max } }); for (let f in t) { let a = t[f], m = Y[f]; if (a.from == null && (m == null || m.min == null)) { let S = a.range(i, a.min == Q ? null : a.min, a.max == -Q ? null : a.max, f); a.min = S[0], a.max = S[1] } } } for (let f in t) { let a = t[f]; if (a.from != null) { let m = t[a.from]; if (m.min == null) a.min = a.max = null; else { let S = a.range(i, m.min, m.max, f); a.min = S[0], a.max = S[1] } } } let n = {}, r = !1; for (let f in t) { let a = t[f], m = E[f]; if (m.min != a.min || m.max != a.max) { m.min = a.min, m.max = a.max; let S = m.distr; m._min = S == 3 ? dt(m.min) : S == 4 ? Tn(m.min, m.asinh) : m.min, m._max = S == 3 ? dt(m.max) : S == 4 ? Tn(m.max, m.asinh) : m.max, n[f] = r = !0 } } if (r) { k.forEach((f, a) => { o == 2 ? a > 0 && n.y && (f._paths = null) : n[f.scale] && (f._paths = null) }); for (let f in n) Je = !0, Fe("setScale", f); G.show && G.left >= 0 && (ut = et = !0) } for (let f in Y) Y[f] = null } u(qs, "setScales"); function Js(t) { let n = Oi(Ae - 1, 0, De - 1), r = Oi(Le + 1, 0, De - 1); for (; t[n] == null && n > 0;)n--; for (; t[r] == null && r < De - 1;)r++; return [n, r] } u(Js, "getOuterIdxs"); function Zs() { De > 0 && (k.forEach((t, n) => { if (n > 0 && t.show && t._paths == null) { let r = o == 2 ? [0, l[n][0].length - 1] : Js(l[n]); t._paths = t.paths(i, n, r[0], r[1]) } }), k.forEach((t, n) => { if (n > 0 && t.show) { hl != t.alpha && (p.globalAlpha = hl = t.alpha), li(n, !1), t._paths && ni(n, !1); { li(n, !0); let r = t._paths ? t._paths.gaps : null, f = t.points.show(i, n, Ae, Le, r), a = t.points.filter(i, n, f, r); (f || a) && (t.points._paths = t.points.paths(i, n, Ae, Le, a), ni(n, !0)) } hl != 1 && (p.globalAlpha = hl = 1), Fe("drawSeries", n) } })) } u(Zs, "drawSeries"); function li(t, n) { let r = n ? k[t].points : k[t]; r._stroke = r.stroke(i, t), r._fill = r.fill(i, t) } u(li, "cacheStrokeFill"); function ni(t, n) { let r = n ? k[t].points : k[t], f = r._stroke, a = r._fill, { stroke: m, fill: S, clip: b, flags: x } = r._paths, C = null, v = he(r.width * ie, 3), L = v % 2 / 2; n && a == null && (a = v > 0 ? "#fff" : f); let K = r.pxAlign == 1; if (K && p.translate(L, L), !n) { let _e = He, q = Ee, re = Ie, J = Te, fe = v * ie / 2; r.min == 0 && (J += fe), r.max == 0 && (q -= fe, J += fe), C = new Path2D, C.rect(_e, q, re, J) } n ? mn(f, v, r.dash, r.cap, a, m, S, x, b) : $s(t, f, v, r.dash, r.cap, a, m, S, x, C, b), K && p.translate(-L, -L) } u(ni, "drawPath"); function $s(t, n, r, f, a, m, S, b, x, C, v) { let L = !1; H.forEach((K, _e) => { if (K.series[0] == t) { let q = k[K.series[1]], re = l[K.series[1]], J = (q._paths || Tl).band; Vt(J) && (J = K.dir == 1 ? J[0] : J[1]); let fe, ve = null; q.show && J && Yo(re, Ae, Le) ? (ve = K.fill(i, _e) || m, fe = q._paths.clip) : J = null, mn(n, r, f, a, ve, S, b, x, C, v, fe, J), L = !0 } }), L || mn(n, r, f, a, m, S, b, x, C, v) } u($s, "fillStroke"); let ii = Ot | ql; function mn(t, n, r, f, a, m, S, b, x, C, v, L) { ei(t, n, r, f, a), (x || C || L) && (p.save(), x && p.clip(x), C && p.clip(C)), L ? (b & ii) == ii ? (p.clip(L), v && p.clip(v), zl(a, S), Cl(t, m, n)) : b & ql ? (zl(a, S), p.clip(L), Cl(t, m, n)) : b & Ot && (p.save(), p.clip(L), v && p.clip(v), zl(a, S), p.restore(), Cl(t, m, n)) : (zl(a, S), Cl(t, m, n)), (x || C || L) && p.restore() } u(mn, "strokeFill"); function Cl(t, n, r) { r > 0 && (n instanceof Map ? n.forEach((f, a) => { p.strokeStyle = Pl = a, p.stroke(f) }) : n != null && t && p.stroke(n)) } u(Cl, "doStroke"); function zl(t, n) { n instanceof Map ? n.forEach((r, f) => { p.fillStyle = Gt = f, p.fill(r) }) : n != null && t && p.fill(n) } u(zl, "doFill"); function Qs(t, n, r, f) { let a = P[t], m; if (f <= 0) m = [0, 0]; else { let S = a._space = a.space(i, t, n, r, f), b = a._incrs = a.incrs(i, t, n, r, f, S); m = gf(n, r, b, f, S) } return a._found = m } u(Qs, "getIncrSpace"); function gn(t, n, r, f, a, m, S, b, x, C) { let v = S % 2 / 2; R == 1 && p.translate(v, v), ei(b, S, x, C, b), p.beginPath(); let L, K, _e, q, re = a + (f == 0 || f == 3 ? -m : m); r == 0 ? (K = a, q = re) : (L = a, _e = re); for (let J = 0; J < t.length; J++)n[J] != null && (r == 0 ? L = _e = t[J] : K = q = t[J], p.moveTo(L, K), p.lineTo(_e, q)); p.stroke(), R == 1 && p.translate(-v, -v) } u(gn, "drawOrthoLines"); function Xs(t) { let n = !0; return P.forEach((r, f) => { if (!r.show) return; let a = E[r.scale]; if (a.min == null) { r._show && (n = !1, r._show = !1, pl(!1)); return } else r._show || (n = !1, r._show = !0, pl(!1)); let m = r.side, S = m % 2, { min: b, max: x } = a, [C, v] = Qs(f, b, x, S == 0 ? le : ne); if (v == 0) return; let L = a.distr == 2, K = r._splits = r.splits(i, f, b, x, C, v, L), _e = a.distr == 2 ? K.map(fe => st[fe]) : K, q = a.distr == 2 ? st[K[1]] - st[K[0]] : C, re = r._values = r.values(i, r.filter(i, _e, f, v, q), f, v, q); r._rotate = m == 2 ? r.rotate(i, re, f, v) : 0; let J = r._size; r._size = Kl(r.size(i, re, f, t)), J != null && r._size != J && (n = !1) }), n } u(Xs, "axesCalc"); function eo(t) { let n = !0; return Qn.forEach((r, f) => { let a = r(i, f, Lt, t); a != vt[f] && (n = !1), vt[f] = a }), n } u(eo, "paddingCalc"); function to() {
            for (let t = 0; t < P.length; t++) {
                let n = P[t]; if (!n.show || !n._show) continue; let r = n.side, f = r % 2, a, m, S = n.stroke(i, t), b = r == 0 || r == 3 ? -1 : 1; if (n.label) { let rt = n.labelGap * b, mt = Ne((n._lpos + rt) * ie); ti(n.labelFont[0], S, "center", r == 2 ? vl : Mi), p.save(), f == 1 ? (a = m = 0, p.translate(mt, Ne(Ee + Te / 2)), p.rotate((r == 3 ? -Bl : Bl) / 2)) : (a = Ne(He + Ie / 2), m = mt), p.fillText(n.label, a, m), p.restore() } let [x, C] = n._found; if (C == 0) continue; let v = E[n.scale], L = f == 0 ? Ie : Te, K = f == 0 ? He : Ee, _e = Ne(n.gap * ie), q = n._splits, re = v.distr == 2 ? q.map(rt => st[rt]) : q, J = v.distr == 2 ? st[q[1]] - st[q[0]] : x, fe = n.ticks, ve = n.border, qe = fe.show ? Ne(fe.size * ie) : 0, pe = n._rotate * -Bl / 180, be = Z(n._pos * ie), We = (qe + _e) * b, ye = be + We; m = f == 0 ? ye : 0, a = f == 1 ? ye : 0; let Ue = n.font[0], ot = n.align == 1 ? Jt : n.align == 2 ? xn : pe > 0 ? Jt : pe < 0 ? xn : f == 0 ? "center" : r == 3 ? xn : Jt, Mt = pe || f == 1 ? "middle" : r == 2 ? vl : Mi; ti(Ue, S, ot, Mt); let Si = n.font[1] * Vr, Hl = q.map(rt => Z(d(rt, v, L, K))), _i = n._values; for (let rt = 0; rt < _i.length; rt++) {
                    let mt = _i[rt]; if (mt != null) {
                        f == 0 ? a = Hl[rt] : m = Hl[rt], mt = "" + mt; let yi = mt.indexOf(`
`) == -1 ? [mt] : mt.split(/\n/gm); for (let yl = 0; yl < yi.length; yl++) { let vi = yi[yl]; pe ? (p.save(), p.translate(a, m + yl * Si), p.rotate(pe), p.fillText(vi, 0, 0), p.restore()) : p.fillText(vi, a, m + yl * Si) }
                    }
                } fe.show && gn(Hl, fe.filter(i, re, t, C, J), f, r, be, qe, he(fe.width * ie, 3), fe.stroke(i, t), fe.dash, fe.cap); let qt = n.grid; qt.show && gn(Hl, qt.filter(i, re, t, C, J), f, f == 0 ? 2 : 1, f == 0 ? Ee : He, f == 0 ? Te : Ie, he(qt.width * ie, 3), qt.stroke(i, t), qt.dash, qt.cap), ve.show && gn([be], [1], f == 0 ? 1 : 0, f == 0 ? 1 : 2, f == 1 ? Ee : He, f == 1 ? Te : Ie, he(ve.width * ie, 3), ve.stroke(i, t), ve.dash, ve.cap)
            } Fe("drawAxes")
        } u(to, "drawAxesGrid"); function pl(t) { k.forEach((n, r) => { r > 0 && (n._paths = null, t && (o == 1 ? (n.min = null, n.max = null) : n.facets.forEach(f => { f.min = null, f.max = null }))) }) } u(pl, "resetYSeries"); let dn = !1; function Pt() { dn || (or(lo), dn = !0) } u(Pt, "commit"); function lo() { it && (qs(), it = !1), Je && (Ws(), Je = !1), Be && (we(z, Jt, j), we(z, vl, Se), we(z, Ml, le), we(z, kl, ne), we(T, Jt, j), we(T, vl, Se), we(T, Ml, le), we(T, kl, ne), we(A, Ml, Tt), we(A, kl, yt), y.width = Ne(Tt * ie), y.height = Ne(yt * ie), P.forEach(({ _el: t, _show: n, _size: r, _pos: f, side: a }) => { if (t != null) if (n) { let m = a === 3 || a === 0 ? r : 0, S = a % 2 == 1; we(t, S ? "left" : "top", f - m), we(t, S ? "width" : "height", r), we(t, S ? "top" : "left", S ? Se : j), we(t, S ? "height" : "width", S ? ne : le), zn(t, Ft) } else Ze(t, Ft) }), Pl = Gt = on = fn = un = cn = an = hn = rn = null, hl = 1, Nl(!0), Fe("setSize"), Be = !1), Tt > 0 && yt > 0 && (p.clearRect(0, 0, y.width, y.height), Fe("drawClear"), I.forEach(t => t()), Fe("draw")), je.show && Dt && (Vl(je), Dt = !1), G.show && ut && (zt(null, !0, !1), ut = !1), V.show && V.live && et && (yn(), et = !1), g || (g = !0, i.status = 1, Fe("ready")), Ll = !1, dn = !1 } u(lo, "_commit"), i.redraw = (t, n) => { Je = n || !1, t !== !1 ? Ut(D, M.min, M.max) : Pt() }; function wn(t, n) { let r = E[t]; if (r.from == null) { if (De == 0) { let f = r.range(i, n.min, n.max, t); n.min = f[0], n.max = f[1] } if (n.min > n.max) { let f = n.min; n.min = n.max, n.max = f } if (De > 1 && n.min != null && n.max != null && n.max - n.min < 1e-16) return; t == D && r.distr == 2 && De > 0 && (n.min = kt(n.min, l[0]), n.max = kt(n.max, l[0]), n.min == n.max && n.max++), Y[t] = n, it = !0, Pt() } } u(wn, "setScale"), i.setScale = wn; let Sn, _n, Rl, Fl, si, oi, It, Bt, ri, fi, ge, de, bt = !1, Re = G.drag, Pe = Re.x, Ce = Re.y; G.show && (G.x && (Sn = tt(To, T)), G.y && (_n = tt(Do, T)), M.ori == 0 ? (Rl = Sn, Fl = _n) : (Rl = _n, Fl = Sn), ge = G.left, de = G.top); let je = i.select = Me({ show: !0, over: !0, left: 0, width: 0, top: 0, height: 0 }, e.select), ml = je.show ? tt(Eo, je.over ? T : z) : null; function Vl(t, n) { if (je.show) { for (let r in t) je[r] = t[r], r in hi && we(ml, r, t[r]); n !== !1 && Fe("setSelect") } } u(Vl, "setSelect"), i.setSelect = Vl; function no(t, n) { let r = k[t], f = me ? nt[t] : null; r.show ? f && zn(f, Ft) : (f && Ze(f, Ft), Ke.length > 1 && Zt(Ke[t], -10, -10, le, ne)) } u(no, "toggleDOM"); function Ut(t, n, r) { wn(t, { min: n, max: r }) } u(Ut, "_setScale"); function ct(t, n, r, f) { n.focus != null && fo(t), n.show != null && k.forEach((a, m) => { m > 0 && (t == m || t == null) && (a.show = n.show, no(m, n.show), Ut(o == 2 ? a.facets[1].scale : a.scale, null, null), Pt()) }), r !== !1 && Fe("setSeries", t, n), f && _l("setSeries", i, t, n) } u(ct, "setSeries"), i.setSeries = ct; function io(t, n) { Me(H[t], n) } u(io, "setBand"); function so(t, n) { t.fill = $(t.fill || null), t.dir = se(t.dir, -1), n = n ?? H.length, H.splice(n, 0, t) } u(so, "addBand"); function oo(t) { t == null ? H.length = 0 : H.splice(t, 1) } u(oo, "delBand"), i.addBand = so, i.setBand = io, i.delBand = oo; function ro(t, n) { k[t].alpha = n, G.show && Ke[t] && (Ke[t].style.opacity = n), me && nt[t] && (nt[t].style.opacity = n) } u(ro, "setAlpha"); let Ct, gl, dl, Yt = { focus: !0 }; function fo(t) { if (t != dl) { let n = t == null, r = At.alpha != 1; k.forEach((f, a) => { let m = n || a == 0 || a == t; f._focus = n ? null : m, r && ro(a, m ? 1 : At.alpha) }), dl = t, r && Pt() } } u(fo, "setFocus"), me && cl && xt(Di, ae, t => { G._lock || dl != null && ct(null, Yt, !0, Ve.setSeries) }); function at(t, n, r) { let f = E[n]; r && (t = t / ie - (f.ori == 1 ? Se : j)); let a = le; f.ori == 1 && (a = ne, t = a - t), f.dir == -1 && (t = a - t); let m = f._min, S = f._max, b = t / a, x = m + (S - m) * b, C = f.distr; return C == 3 ? el(10, x) : C == 4 ? jo(x, f.asinh) : x } u(at, "posToVal"); function uo(t, n) { let r = at(t, D, n); return kt(r, l[0], Ae, Le) } u(uo, "closestIdxFromXpos"), i.valToIdx = t => kt(t, l[0]), i.posToIdx = uo, i.posToVal = at, i.valToPos = (t, n, r) => E[n].ori == 0 ? c(t, E[n], r ? Ie : le, r ? He : 0) : w(t, E[n], r ? Te : ne, r ? Ee : 0); function co(t) { t(i), Pt() } u(co, "batch"), i.batch = co, i.setCursor = (t, n, r) => { ge = t.left, de = t.top, zt(null, n, r) }; function ui(t, n) { we(ml, Jt, je.left = t), we(ml, Ml, je.width = n) } u(ui, "setSelH"); function ci(t, n) { we(ml, vl, je.top = t), we(ml, kl, je.height = n) } u(ci, "setSelV"); let wl = M.ori == 0 ? ui : ci, Sl = M.ori == 1 ? ui : ci; function ao() { if (me && V.live) for (let t = o == 2 ? 1 : 0; t < k.length; t++) { if (t == 0 && Xe) continue; let n = V.values[t], r = 0; for (let f in n) St[t][r++].firstChild.nodeValue = n[f] } } u(ao, "syncLegend"); function yn(t, n) { t != null && (t.idxs ? t.idxs.forEach((r, f) => { oe[f] = r }) : Xo(t.idx) || oe.fill(t.idx), V.idx = oe[0]); for (let r = 0; r < k.length; r++)(r > 0 || o == 1 && !Xe) && ho(r, oe[r]); me && V.live && ao(), et = !1, n !== !1 && Fe("setLegend") } u(yn, "setLegend"), i.setLegend = yn; function ho(t, n) { let r = k[t], f = t == 0 && O == 2 ? st : l[t], a; Xe ? a = r.values(i, t, n) ?? _t : (a = r.value(i, n == null ? null : f[n], t, n), a = a == null ? _t : { _: a }), V.values[t] = a } u(ho, "setLegendValues"); function zt(t, n, r) { ri = ge, fi = de, [ge, de] = G.move(i, ge, de), G.show && (Rl && Zt(Rl, Ne(ge), 0, le, ne), Fl && Zt(Fl, 0, Ne(de), le, ne)); let f, a = Ae > Le; Ct = Q; let m = M.ori == 0 ? le : ne, S = M.ori == 1 ? le : ne; if (ge < 0 || De == 0 || a) { f = null; for (let b = 0; b < k.length; b++)b > 0 && Ke.length > 1 && Zt(Ke[b], -10, -10, le, ne); cl && ct(null, Yt, !0, t == null && Ve.setSeries), V.live && (oe.fill(f), et = !0) } else { let b, x, C; o == 1 && (b = M.ori == 0 ? ge : de, x = at(b, D), f = kt(x, l[0], Ae, Le), C = X(l[0][f], M, m, 0)); for (let v = o == 2 ? 1 : 0; v < k.length; v++) { let L = k[v], K = oe[v], _e = o == 1 ? l[v][K] : l[v][1][K], q = G.dataIdx(i, v, f, x), re = o == 1 ? l[v][q] : l[v][1][q]; et = et || re != _e || q != K, oe[v] = q; let J = ll(q == f ? C : X(o == 1 ? l[0][q] : l[v][0][q], M, m, 0), 1); if (v > 0 && L.show) { let fe = re == null ? -10 : ll(ee(re, o == 1 ? E[L.scale] : E[L.facets[1].scale], S, 0), 1); if (cl && fe >= 0 && o == 1) { let pe = Ge(fe - de), be = At.bias; if (be != 0) { let We = M.ori == 1 ? ge : de, ye = at(We, L.scale), Ue = re >= 0 ? 1 : -1, ot = ye >= 0 ? 1 : -1; ot == Ue && pe < Ct && (ot == 1 ? be == 1 ? re >= ye : re <= ye : be == 1 ? re <= ye : re >= ye) && (Ct = pe, gl = v) } else pe < Ct && (Ct = pe, gl = v) } let ve, qe; if (M.ori == 0 ? (ve = J, qe = fe) : (ve = fe, qe = J), et && Ke.length > 1) { Wo(Ke[v], G.points.fill(i, v), G.points.stroke(i, v)); let pe, be, We, ye, Ue = !0, ot = G.points.bbox; if (ot != null) { Ue = !1; let Mt = ot(i, v); We = Mt.left, ye = Mt.top, pe = Mt.width, be = Mt.height } else We = ve, ye = qe, pe = be = G.points.size(i, v); Go(Ke[v], pe, be, Ue), Zt(Ke[v], We, ye, le, ne) } } } } if (G.idx = f, G.left = ge, G.top = de, et && (V.idx = f, yn()), je.show && bt) if (t != null) { let [b, x] = Ve.scales, [C, v] = Ve.match, [L, K] = t.cursor.sync.scales, _e = t.cursor.drag; if (Pe = _e._x, Ce = _e._y, Pe || Ce) { let { left: q, top: re, width: J, height: fe } = t.select, ve = t.scales[b].ori, qe = t.posToVal, pe, be, We, ye, Ue, ot = b != null && C(b, L), Mt = x != null && v(x, K); ot && Pe ? (ve == 0 ? (pe = q, be = J) : (pe = re, be = fe), We = E[b], ye = X(qe(pe, L), We, m, 0), Ue = X(qe(pe + be, L), We, m, 0), wl(Ye(ye, Ue), Ge(Ue - ye))) : wl(0, m), Mt && Ce ? (ve == 1 ? (pe = q, be = J) : (pe = re, be = fe), We = E[x], ye = ee(qe(pe, K), We, S, 0), Ue = ee(qe(pe + be, K), We, S, 0), Sl(Ye(ye, Ue), Ge(Ue - ye))) : Sl(0, S) } else bn() } else { let b = Ge(ri - si), x = Ge(fi - oi); if (M.ori == 1) { let K = b; b = x, x = K } Pe = Re.x && b >= Re.dist, Ce = Re.y && x >= Re.dist; let C = Re.uni; C != null ? Pe && Ce && (Pe = b >= C, Ce = x >= C, !Pe && !Ce && (x > b ? Ce = !0 : Pe = !0)) : Re.x && Re.y && (Pe || Ce) && (Pe = Ce = !0); let v, L; Pe && (M.ori == 0 ? (v = It, L = ge) : (v = Bt, L = de), wl(Ye(v, L), Ge(L - v)), Ce || Sl(0, S)), Ce && (M.ori == 1 ? (v = It, L = ge) : (v = Bt, L = de), Sl(Ye(v, L), Ge(L - v)), Pe || wl(0, m)), !Pe && !Ce && (wl(0, 0), Sl(0, 0)) } if (Re._x = Pe, Re._y = Ce, t == null) { if (r) { if (wi != null) { let [b, x] = Ve.scales; Ve.values[0] = b != null ? at(M.ori == 0 ? ge : de, b) : null, Ve.values[1] = x != null ? at(M.ori == 1 ? ge : de, x) : null } _l(xi, i, ge, de, le, ne, f) } if (cl) { let b = r && Ve.setSeries, x = At.prox; dl == null ? Ct <= x && ct(gl, Yt, !0, b) : Ct > x ? ct(null, Yt, !0, b) : gl != dl && ct(gl, Yt, !0, b) } } n !== !1 && Fe("setCursor") } u(zt, "updateCursor"); let Kt = null; function Nl(t) { t === !0 ? Kt = null : (Kt = T.getBoundingClientRect(), Fe("syncRect", Kt)) } u(Nl, "syncRect"); function ai(t, n, r, f, a, m, S) { G._lock || bt && t != null && t.movementX == 0 && t.movementY == 0 || (vn(t, n, r, f, a, m, S, !1, t != null), t != null ? zt(null, !0, !0) : zt(n, !0, !1)) } u(ai, "mouseMove"); function vn(t, n, r, f, a, m, S, b, x) { if (Kt == null && Nl(!1), t != null) r = t.clientX - Kt.left, f = t.clientY - Kt.top; else { if (r < 0 || f < 0) { ge = -10, de = -10; return } let [C, v] = Ve.scales, L = n.cursor.sync, [K, _e] = L.values, [q, re] = L.scales, [J, fe] = Ve.match, ve = n.axes[0].side % 2 == 1, qe = M.ori == 0 ? le : ne, pe = M.ori == 1 ? le : ne, be = ve ? m : a, We = ve ? a : m, ye = ve ? f : r, Ue = ve ? r : f; if (q != null ? r = J(C, q) ? d(K, E[C], qe, 0) : -10 : r = qe * (ye / be), re != null ? f = fe(v, re) ? d(_e, E[v], pe, 0) : -10 : f = pe * (Ue / We), M.ori == 1) { let ot = r; r = f, f = ot } } x && ((r <= 1 || r >= le - 1) && (r = Rt(r, le)), (f <= 1 || f >= ne - 1) && (f = Rt(f, ne))), b ? (si = r, oi = f, [It, Bt] = G.move(i, r, f)) : (ge = r, de = f) } u(vn, "cacheMouse"); let hi = { width: 0, height: 0, left: 0, top: 0 }; function bn() { Vl(hi, !1) } u(bn, "hideSelect"); function pi(t, n, r, f, a, m, S) { bt = !0, Pe = Ce = Re._x = Re._y = !1, vn(t, n, r, f, a, m, S, !0, !1), t != null && (ft(En, Pn, mi), _l(Ei, i, It, Bt, le, ne, null)) } u(pi, "mouseDown"); function mi(t, n, r, f, a, m, S) { bt = Re._x = Re._y = !1, vn(t, n, r, f, a, m, S, !1, !0); let { left: b, top: x, width: C, height: v } = je, L = C > 0 || v > 0; if (L && Vl(je), Re.setScale && L) { let K = b, _e = C, q = x, re = v; if (M.ori == 1 && (K = x, _e = v, q = b, re = C), Pe && Ut(D, at(K, D), at(K + _e, D)), Ce) for (let J in E) { let fe = E[J]; J != D && fe.from == null && fe.min != Q && Ut(J, at(q + re, J), at(q, J)) } bn() } else G.lock && (G._lock = !G._lock, G._lock || zt(null, !0, !1)); t != null && (ul(En, Pn), _l(En, i, ge, de, le, ne, null)) } u(mi, "mouseUp"); function po(t, n, r, f, a, m, S) { if (!G._lock) { let b = bt; if (bt) { let x = !0, C = !0, v = 10, L, K; M.ori == 0 ? (L = Pe, K = Ce) : (L = Ce, K = Pe), L && K && (x = ge <= v || ge >= le - v, C = de <= v || de >= ne - v), L && x && (ge = ge < It ? 0 : le), K && C && (de = de < Bt ? 0 : ne), zt(null, !0, !0), bt = !1 } ge = -10, de = -10, zt(null, !0, !0), b && (bt = b) } } u(po, "mouseLeave"); function gi(t, n, r, f, a, m, S) { sn(), bn(), t != null && _l(Ai, i, ge, de, le, ne, null) } u(gi, "dblClick"); function di() { P.forEach(df), nn(i.width, i.height, !0) } u(di, "syncPxRatio"), xt(Ul, Qt, di); let jt = {}; jt.mousedown = pi, jt.mousemove = ai, jt.mouseup = mi, jt.dblclick = gi, jt.setSeries = (t, n, r, f) => { ct(r, f, !0, !1) }, G.show && (ft(Ei, T, pi), ft(xi, T, ai), ft(Ti, T, Nl), ft(Di, T, po), ft(Ai, T, gi), Vn.add(i), i.syncRect = Nl); let Ol = i.hooks = e.hooks || {}; function Fe(t, n, r) { t in Ol && Ol[t].forEach(f => { f.call(null, i, n, r) }) } u(Fe, "fire"), (e.plugins || []).forEach(t => { for (let n in t.hooks) Ol[n] = (Ol[n] || []).concat(t.hooks[n]) }); let Ve = Me({ key: null, setSeries: !1, filters: { pub: Hi, sub: Hi }, scales: [D, k[1] ? k[1].scale : null], match: [Wi, Wi], values: [null, null] }, G.sync); G.sync = Ve; let wi = Ve.key, Mn = Ts(wi); function _l(t, n, r, f, a, m, S) { Ve.filters.pub(t, n, r, f, a, m, S) && Mn.pub(t, n, r, f, a, m, S) } u(_l, "pubSync"), Mn.sub(i); function mo(t, n, r, f, a, m, S) { Ve.filters.sub(t, n, r, f, a, m, S) && jt[t](null, n, r, f, a, m, S) } u(mo, "pub"), i.pub = mo; function go() { Mn.unsub(i), Vn.delete(i), pt.clear(), Rn(Ul, Qt, di), _.remove(), ae?.remove(), Fe("destroy") } u(go, "destroy"), i.destroy = go; function kn() { Fe("init", e, l), Xn(l || e.data, !1), Y[D] ? wn(D, Y[D]) : sn(), Dt = je.show, ut = et = !0, nn(e.width, e.height) } return u(kn, "_init"), k.forEach($n), P.forEach(js), s ? s instanceof HTMLElement ? (s.appendChild(_), kn()) : s(i, kn) : kn(), i
    } u(Oe, "uPlot"); Oe.assign = Me; Oe.fmtNum = Bn; Oe.rangeNum = Yl; Oe.rangeLog = Jl; Oe.rangeAsinh = Gn; Oe.orient = Ht; Oe.pxRatio = ie; Oe.join = sr; Oe.fmtDate = Un, Oe.tzDate = pr; Oe.sync = Ts; { Oe.addGap = Xr, Oe.clipGaps = Xl; let e = Oe.paths = { points: zs }; e.linear = Fs, e.stepped = lf, e.bars = nf, e.spline = of } function wf(e, l, s, i) { let o = document.getElementById(e), h = o.parentElement, c = new Oe({ width: h.scrollWidth, height: 240, series: [{}, { label: l, fill: "#ffe0d8" }], ms: 1 }, [s, i], o); new ResizeObserver(() => { c.setSize({ width: h.scrollWidth, height: 240 }) }).observe(h) } u(wf, "plotSeries"); window.plotSeries = wf;
})();
