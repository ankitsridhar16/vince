// Code generated by capnpc-go. DO NOT EDIT.

package store

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Calendar capnp.Struct

// Calendar_TypeID is the unique identifier for the type Calendar.
const Calendar_TypeID = 0xf8bd901143c99f61

func NewCalendar(s *capnp.Segment) (Calendar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Calendar(st), err
}

func NewRootCalendar(s *capnp.Segment) (Calendar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return Calendar(st), err
}

func ReadRootCalendar(msg *capnp.Message) (Calendar, error) {
	root, err := msg.Root()
	return Calendar(root.Struct()), err
}

func (s Calendar) String() string {
	str, _ := text.Marshal(0xf8bd901143c99f61, capnp.Struct(s))
	return str
}

func (s Calendar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Calendar) DecodeFromPtr(p capnp.Ptr) Calendar {
	return Calendar(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Calendar) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Calendar) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Calendar) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Calendar) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Calendar) Visitors() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.Float64List(p.List()), err
}

func (s Calendar) HasVisitors() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Calendar) SetVisitors(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewVisitors sets the visitors field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Calendar) NewVisitors(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Calendar) Visits() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.Float64List(p.List()), err
}

func (s Calendar) HasVisits() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Calendar) SetVisits(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewVisits sets the visits field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Calendar) NewVisits(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Calendar) Events() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.Float64List(p.List()), err
}

func (s Calendar) HasEvents() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Calendar) SetEvents(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewEvents sets the events field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Calendar) NewEvents(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// Calendar_List is a list of Calendar.
type Calendar_List = capnp.StructList[Calendar]

// NewCalendar creates a new list of Calendar.
func NewCalendar_List(s *capnp.Segment, sz int32) (Calendar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[Calendar](l), err
}

// Calendar_Future is a wrapper for a Calendar promised by a client call.
type Calendar_Future struct{ *capnp.Future }

func (f Calendar_Future) Struct() (Calendar, error) {
	p, err := f.Future.Ptr()
	return Calendar(p.Struct()), err
}

const schema_da1eebf4d7c0f83e = "x\xda\x12\xa8u`1\xe4\xdd\xcf\xc8\xc0\x14(\xc2\xca" +
	"\xf6?q\xfeIg\xc1\x09{\x7f0\x08\x0a1\xfe\xb7" +
	"\xfbq\xe0\xfa\x97\xd7r\xb7\x18X\x99\xd9\x19\x18\x04\x8f" +
	"\xde\x12\xbc\x08\xa2\xcf\xaeg\xd0\xfd_\\\x92_\x94\xaa" +
	"_\\\xc2\x94_\x94\xaa\x97\x9cX\x90W`\xe5\x9c\x98" +
	"\x93\x9a\x97\xc2\x9cX\x14\xc0\xc8\x18\xc8\xc3\xcc\xc2\xc0\xc0" +
	"\xc2\xc8\xc0 \xe8\xea\xc5\xc0\x10\xe8\xc2\xcc\x18\x98\xc0\xc4" +
	"(\xc8\xc8(\xc2\x08\x12\x8c\xb5b`\x08\x8c`f\x0c" +
	",ab\x14db\x12adb`\x10,\x04\x09\xe6" +
	"03\x06v01\xfe/\xcb,\xce,\xc9/*f" +
	"```\xe4c`\x0c`fd\xe4f`\x021\xed" +
	"\xc1R\xc5\xe8\xa2\xa9e\xa9y\x18\xa2\x80\x00\x00\x00\xff" +
	"\xff\x16\xec1\x1d"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da1eebf4d7c0f83e,
		Nodes: []uint64{
			0xf8bd901143c99f61,
		},
		Compressed: true,
	})
}
