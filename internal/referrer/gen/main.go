package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/vinceanalytics/vince/tools"
	"gopkg.in/yaml.v2"
)

type Domains struct {
	Type    string   `json:"-"`
	Name    string   `json:"-"`
	Index   int      `json:"-"`
	Hosts   []string `json:"-"`
	Domains []string `json:"-"`
}

const (
	repo = "git@github.com:snowplow-referer-parser/referer-parser.git"
	dir  = "referer-parser"
)

type refererData map[string]map[string]map[string][]string

func (r refererData) Walk() (maxLen, minLen int, o []*Domains) {
	processed := make(map[string]struct{})
	r.walkName(func(mType, mName string, mV []string) {
		sort.Strings(mV)
		var oh []string
		var od []string
		for _, k := range mV {
			if _, ok := processed[k]; ok {
				continue
			}
			processed[k] = struct{}{}
			u, _ := url.Parse("http://" + k)
			host := strings.TrimPrefix(u.Host, "www.")
			parts := strings.Split(host, ".")
			if len(parts) > int(maxLen) {
				maxLen = len(parts)
			}
			if len(parts) < minLen {
				minLen = len(parts)
			}
			sort.Sort(sort.Reverse(StringSlice(parts)))
			host = strings.Join(parts, ".")
			if _, ok := processed[host]; ok {
				continue
			}
			processed[host] = struct{}{}
			oh = append(oh, host)
			od = append(od, k)
		}
		if len(oh) > 0 {
			o = append(o, &Domains{
				Type:    mType,
				Name:    mName,
				Hosts:   oh,
				Domains: od,
			})
		}
	})
	return
}

func (r refererData) walkName(f func(mType, mName string, mV []string)) {
	r.walkType(func(mType string, mV map[string]map[string][]string) {
		ls := make([]string, 0, len(mV))
		for k := range mV {
			ls = append(ls, k)
		}
		sort.Strings(ls)
		for _, k := range ls {
			f(mType, k, mV[k]["domains"])
		}
	})
}
func (r refererData) walkType(f func(mType string, mV map[string]map[string][]string)) {
	ls := make([]string, 0, len(r))
	for k := range r {
		ls = append(ls, k)
	}
	sort.Strings(ls)
	for _, k := range ls {
		f(k, r[k])
	}
}

const baseURL = "https://icons.duckduckgo.com/ip3/"

func main() {
	root := tools.RootVince()
	tools.EnsureRepo(
		filepath.Join(root, "internal", "referrer"),
		repo, dir,
	)
	var data refererData
	bs := tools.ReadFile(filepath.Join(dir, "resources", "referers.yml"))
	err := yaml.NewDecoder(bytes.NewReader(bs)).Decode(&data)
	if err != nil {
		tools.Exit(err.Error())
	}

	var maxLen int
	var minLen = 6

	maxLen, minLen, domains := data.Walk()
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by referrer/make_referrer.go")
	fmt.Fprintln(&b, " package referrer")

	fmt.Fprintln(&b, "var favicon=map[string]struct{}{")
	seen := make(map[string]struct{})
	os.Mkdir("icons", 0755)
	for _, v := range domains {
		if _, ok := seen[v.Name]; ok {
			continue
		}
		seen[v.Name] = struct{}{}
		key := strings.ToLower(v.Name)
		key = strings.Replace(key, " ", "-", -1)
		ok := writeIcon(key, v.Domains)
		if !ok {
			continue
		}
		fmt.Fprintf(&b, "%q:{},\n", key)
	}
	fmt.Fprintln(&b, "}")
	fmt.Fprintf(&b, " const minReferrerSize=%d\n", minLen)
	fmt.Fprintf(&b, " const maxReferrerSize=%d\n", maxLen)
	fmt.Fprintln(&b, "var refList=map[string]string{")

	for _, d := range domains {
		for _, h := range d.Hosts {
			fmt.Fprintf(&b, "%q:%q,\n", h, d.Name)
		}
	}
	fmt.Fprintln(&b, "}")

	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	tools.WriteFile("referrer_data.go", r)

	b.Reset()
	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by referrer/make_referrer.go")
	fmt.Fprintln(&b, " package main")
	var ls []string
	for _, d := range domains {
		ls = append(ls, d.Hosts...)
	}
	fmt.Fprintf(&b, " var domains=[%d]string{\n", len(ls))
	sort.Strings(ls)
	for i, k := range ls {
		if i%4 == 0 {
			b.WriteByte('\n')
		}
		fmt.Fprintf(&b, "%q,", k)
	}
	fmt.Fprintln(&b, "\n}")

	r, err = format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	tools.WriteFile(
		filepath.Join(tools.RootVince(), "tools", "vince_load_gen", "domains.go"),
		r)
}

type StringSlice []string

func (x StringSlice) Len() int           { return len(x) }
func (x StringSlice) Less(i, j int) bool { return i < j }
func (x StringSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

func writeIcon(key string, ls []string) bool {
	for _, s := range ls {
		if ok := getFavicon(key, s); ok {
			return ok
		}
	}
	return false
}

func getFavicon(key, site string) bool {
	su := site + ".ico"
	u := baseURL + su
	r, err := http.Get(u)
	if err != nil {
		tools.Exit(err.Error())
	}
	defer r.Body.Close()

	if r.StatusCode != http.StatusOK {
		println(">", u, r.Status)
		if r.StatusCode == http.StatusNotFound {
			return false
		}
		tools.Exit(su, http.StatusText(r.StatusCode))
	}
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		tools.Exit(err.Error())
	}
	if !bytes.Contains(b, []byte{137, 80, 78, 71, 13, 10, 26, 10}) {
		println(">", u, "xxxxxx special case")
	}
	tools.WriteFile(filepath.Join("icons", key), b)
	return true
}
