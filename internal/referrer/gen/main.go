package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"net/url"
	"path/filepath"
	"sort"
	"strings"

	"github.com/vinceanalytics/vince/tools"
	"gopkg.in/yaml.v2"
)

type Domains struct {
	Type    string   `json:"-"`
	Name    string   `json:"-"`
	Index   int      `json:"-"`
	Hosts   []string `json:"-"`
	Domains []string `json:"-"`
}

const (
	repo = "git@github.com:snowplow-referer-parser/referer-parser.git"
	dir  = "referer-parser"
)

type refererData map[string]map[string]map[string][]string

func (r refererData) Walk() (maxLen, minLen int, o []*Domains) {
	processed := make(map[string]struct{})
	r.walkName(func(mType, mName string, mV []string) {
		sort.Strings(mV)
		var oh []string
		var od []string
		for _, k := range mV {
			if _, ok := processed[k]; ok {
				continue
			}
			processed[k] = struct{}{}
			u, _ := url.Parse("http://" + k)
			host := strings.TrimPrefix(u.Host, "www.")
			parts := strings.Split(host, ".")
			if len(parts) > int(maxLen) {
				maxLen = len(parts)
			}
			if len(parts) < minLen {
				minLen = len(parts)
			}
			sort.Sort(sort.Reverse(StringSlice(parts)))
			host = strings.Join(parts, ".")
			if _, ok := processed[host]; ok {
				continue
			}
			processed[host] = struct{}{}
			oh = append(oh, host)
			od = append(od, k)
		}
		if len(oh) > 0 {
			o = append(o, &Domains{
				Type:    mType,
				Name:    mName,
				Hosts:   oh,
				Domains: od,
			})
		}
	})
	return
}

func (r refererData) walkName(f func(mType, mName string, mV []string)) {
	r.walkType(func(mType string, mV map[string]map[string][]string) {
		ls := make([]string, 0, len(mV))
		for k := range mV {
			ls = append(ls, k)
		}
		sort.Strings(ls)
		for _, k := range ls {
			f(mType, k, mV[k]["domains"])
		}
	})
}
func (r refererData) walkType(f func(mType string, mV map[string]map[string][]string)) {
	ls := make([]string, 0, len(r))
	for k := range r {
		ls = append(ls, k)
	}
	sort.Strings(ls)
	for _, k := range ls {
		f(k, r[k])
	}
}

func main() {
	root := tools.RootVince()
	tools.EnsureRepo(
		filepath.Join(root, "internal", "referrer"),
		repo, dir,
	)
	var data refererData
	bs := tools.ReadFile(filepath.Join(dir, "resources", "referers.yml"))
	err := yaml.NewDecoder(bytes.NewReader(bs)).Decode(&data)
	if err != nil {
		tools.Exit(err.Error())
	}

	var maxLen int
	var minLen = 6

	maxLen, minLen, domains := data.Walk()
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by referrer/make_referrer.go")
	fmt.Fprintln(&b, " package referrer")
	fmt.Fprintln(&b, " import \"sync\"")
	fmt.Fprintln(&b, " var Favicon =&sync.Map{}")
	fmt.Fprintln(&b, " func init() {")

	for _, v := range domains {
		fmt.Fprintf(&b, " Favicon.Store(%q,%q)\n", v.Name, v.Domains[0])
	}
	fmt.Fprintln(&b, " }")
	fmt.Fprintf(&b, " const minReferrerSize=%d\n", minLen)
	fmt.Fprintf(&b, " const maxReferrerSize=%d\n", maxLen)
	fmt.Fprintln(&b, `
	type Medium struct {
		Type       string
		Name       string
	}
	`)
	fmt.Fprintln(&b, "var refList=map[string]*Medium{")

	for _, d := range domains {
		for _, h := range d.Hosts {
			fmt.Fprintf(&b, "%q:{Type:%q,Name:%q},\n", h, d.Type, d.Name)
		}
	}
	fmt.Fprintln(&b, "}")

	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	tools.WriteFile("referrer_data.go", r)

	b.Reset()
	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by referrer/make_referrer.go")
	fmt.Fprintln(&b, " package main")
	var ls []string
	for _, d := range domains {
		ls = append(ls, d.Hosts...)
	}
	fmt.Fprintf(&b, " var domains=[%d]string{\n", len(ls))
	sort.Strings(ls)
	for i, k := range ls {
		if i%4 == 0 {
			b.WriteByte('\n')
		}
		fmt.Fprintf(&b, "%q,", k)
	}
	fmt.Fprintln(&b, "\n}")

	r, err = format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	tools.WriteFile(
		filepath.Join(tools.RootVince(), "tools", "vince_load_gen", "domains.go"),
		r)
}

type StringSlice []string

func (x StringSlice) Len() int           { return len(x) }
func (x StringSlice) Less(i, j int) bool { return i < j }
func (x StringSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
