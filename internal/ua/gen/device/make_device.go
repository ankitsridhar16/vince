package device

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/vinceanalytics/vince/internal/tools"
	"github.com/vinceanalytics/vince/internal/ua"
	"gopkg.in/yaml.v2"
)

func Make(root string) {
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by ua/device/make_device.go")
	fmt.Fprintln(&b, " package ua")

	genCamera(&b, root)
	genCar(&b, root)
	genConsole(&b, root)
	genTV(&b, root)
	genMobile(&b, root)
	genNotebook(&b, root)
	genPortableMediaPlayer(&b, root)
	genShell(&b, root)
	r, err := format.Source(b.Bytes())
	if err != nil {
		tools.Exit("failed to format go source ", err.Error())
	}
	tools.WriteFile("ua_device.go", r)
}

type Model struct {
	Regex  string `yaml:"regex" json:"regex"`
	Model  string `yaml:"model" json:"model"`
	Device string `yaml:"device" json:"device"` //mobile
	Brand  string `yaml:"brand" json:"brand"`   //mobile
}

type DeviceReg struct {
	Regex        string   `yaml:"regex" json:"regex"`
	Model        string   `yaml:"model" json:"model"`
	Device       string   `yaml:"device" json:"device"`
	Manufacturer string   `yaml:"-" json:"-"`
	Models       []*Model `yaml:"models" json:"models"`
}

type DeviceRegSlice []*DeviceReg

func (x DeviceRegSlice) Len() int           { return len(x) }
func (x DeviceRegSlice) Less(i, j int) bool { return x[i].Manufacturer < x[j].Manufacturer }
func (x DeviceRegSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

func genCamera(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	generic(b, "Camera", root, "device/cameras.yml")
}

func genCar(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	generic(b, "Car", root, "device/car_browsers.yml")
}

func genConsole(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	generic(b, "Console", root, "device/consoles.yml")
}

func genTV(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	fmt.Fprintf(b, " var deviceIsTVRe= MustCompile(`%s`)\n", ua.Clean(`HbbTV/([1-9]{1}(?:.[0-9]{1}){1,2})`))
	generic(b, "TV", root, "device/televisions.yml")
}

func genMobile(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	generic(b, "Mobile", root, "device/mobiles.yml")
}

func genNotebook(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	generic(b, "Notebook", root, "device/notebooks.yml")
}
func genPortableMediaPlayer(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	generic(b, "PortableMediaPlayer", root, "device/portable_media_player.yml")
}

func genShell(b *bytes.Buffer, root string) {
	fmt.Fprintln(b)
	fmt.Fprintf(b, " var deviceIsShellTV= MustCompile(`%s`)\n", ua.Clean(`[a-z]+[ _]Shell[ _]\w{6}`))
	generic(b, "Shell", root, "device/shell_tv.yml")
}
func generic(b *bytes.Buffer, name string, root, path string) {
	items := loadDevice(root, path)
	var s strings.Builder
	for i, d := range items {
		if i != 0 {
			s.WriteByte('|')
		}
		s.WriteString(d.Regex)
	}
	var buf bytes.Buffer

	if ua.IsStdRe(s.String()) {
		fmt.Fprintf(b, " var device%sAllRe= MatchRe(`%s`)\n", name, ua.Clean(s.String()))
	} else {
		fmt.Fprintf(b, " var device%sAllRe= MatchRe2(`%s`)\n", name, ua.Clean(s.String()))
	}
	fmt.Fprintf(b, "var device%sAll=[]*deviceRe{\n", name)
	for _, d := range items {
		buf.Reset()
		r := ua.Clean(d.Regex)
		if ua.IsStdRe(d.Regex) {
			fmt.Fprintf(&buf, "re:MatchRe(`%s`)", r)
		} else {
			fmt.Fprintf(&buf, "re: MatchRe2(`%s`)", r)
		}
		fmt.Fprintf(b, "{%s,company:%q,device:%q, ", &buf, d.Manufacturer, d.Device)
		if d.Model != "" {
			fmt.Fprintf(b, "model:%q},\n", d.Model)
		} else {
			if len(d.Models) > 0 {
				fmt.Fprintf(b, "models:[]*deviceModel{")
				for _, m := range d.Models {

					fmt.Fprintf(b, "{model:%q,", m.Model)
					buf.Reset()
					r = ua.Clean(m.Regex)
					if ua.IsStdRe(m.Regex) {
						fmt.Fprintf(&buf, "re:MatchRe(`%s`)", r)
					} else {
						fmt.Fprintf(&buf, "re: MatchRe2(`%s`)", r)
					}
					fmt.Fprintf(b, "%s},\n", &buf)
				}
				fmt.Fprintf(b, "},")
			}
			fmt.Fprintf(b, "},\n")
		}

	}
	fmt.Fprintln(b, "}")
}

func loadDevice(root, path string) []*DeviceReg {
	var v map[string]*DeviceReg
	readUA(root, path, &v)

	var items []*DeviceReg
	for key, value := range v {
		value.Manufacturer = key
		items = append(items, value)
	}
	sort.Sort(DeviceRegSlice(items))
	return items
}

func readUA(root, name string, out any) {
	path := filepath.Join(root, name)
	f, err := os.ReadFile(path)
	if err != nil {
		tools.Exit("failed to read ua file ", path)
	}
	err = yaml.Unmarshal(f, out)
	if err != nil {
		tools.Exit("failed to  decode ", path, err.Error())
	}
}
