package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
)

func main() {
	src := os.Getenv("CITIES_DATA")
	if src == "" {
		return
	}
	f, err := os.Open(src)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	var cities []*Country
	err = json.NewDecoder(f).Decode(&cities)
	if err != nil {
		log.Fatal(err)
	}
	var codes []*KV
	for _, c := range cities {
		codes = append(codes, &KV{
			Key:   c.Code,
			Value: c.Name,
		})
		for _, r := range c.States {
			codes = append(codes, &KV{
				Key:   c.Code + "-" + r.Code,
				Value: r.Name,
			})
		}
	}

	var b bytes.Buffer
	b.WriteString(`
	// DO NOT EDIT Code generated by cities/index/main.go"
	package cities

	var isoCodes =map[string]uint16{
	`)
	for i, k := range codes {
		fmt.Fprintf(&b, "%q:%d,\n", k.Key, i)
	}
	b.WriteString("}\n")
	b.WriteString(`
	var countryAndRegions =[]string{
	`)
	for _, k := range codes {
		fmt.Fprintf(&b, "%q,\n", k.Value)
	}
	b.WriteString("}\n")
	b.WriteString(`
	var isoCodeList =[]string{
	`)
	for _, k := range codes {
		fmt.Fprintf(&b, "%q,\n", k.Key)
	}
	b.WriteString("}\n")
	x, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("index.go", x, 0600)

}

type KV struct {
	Key, Value string
}

type Country struct {
	Name   string   `json:"name"`
	Code   string   `json:"iso2"`
	States []*State `json:"states"`
}

type State struct {
	Name string `json:"name"`
	Code string `json:"state_code"`
}
