package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
)

//go:embed all.json
var all []byte

func main() {
	var countries []*Country
	err := json.Unmarshal(all, &countries)
	if err != nil {
		log.Fatal(err)
	}
	var b bytes.Buffer
	b.WriteString(`
   // DO NOT EDIT Code generated by country/gen/main.go
	package country
type Code uint
	`)
	fmt.Fprintln(&b, "const (")
	var reverse, lookup bytes.Buffer
	fmt.Fprintln(&lookup, `
	func Lookup (code string)Code{
		return _lookup[code]
	}

	func From (code Code)string{
		return _reverse[code]
	}
	
	var  _reverse map[Code]string 
	func init(){
		_reverse=make(map[Code]string)
		for k,v:=range _lookup{
			_reverse[v]=k
		}
	}
	`)
	fmt.Fprintln(&reverse, "var _lookup=map[string]Code{")
	for i, c := range countries {
		if i == 0 {
			fmt.Fprintf(&b, "%s Code=iota\n", c.Alpha2)
		} else {
			fmt.Fprintln(&b, c.Alpha2)
		}
		fmt.Fprintln(&b, c.Alpha3)
		fmt.Fprintf(&reverse, "%q :%s,\n", c.Alpha2, c.Alpha2)
		fmt.Fprintf(&reverse, "%q :%s,\n", c.Alpha3, c.Alpha3)
	}
	fmt.Fprintln(&reverse, "}")
	fmt.Fprintln(&b, ")")
	b.Write(lookup.Bytes())
	b.Write(reverse.Bytes())
	v, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("country/codes.go", v, 0600)
}

type Country struct {
	Name   string `json:"name"`
	Alpha2 string `json:"alpha-2"`
	Alpha3 string `json:"alpha-3"`
	Code   string `json:"country-code"`
}
