// DO NOT EDIT Code generated by schema/make_schema.go
package vince

import (
	"sort"

	"github.com/polarsignals/frostdb"
	"github.com/polarsignals/frostdb/dynparquet"
	schemav2pb "github.com/polarsignals/frostdb/gen/proto/go/frostdb/schema/v1alpha2"
	"github.com/segmentio/parquet-go"
)

const EventTable = "event"

type EventList []*Event

func (e EventList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	names := []string{}
	seen := map[string]struct{}{}
	for _, lb := range e {
		for _, label := range lb.Labels {
			if _, ok := seen[label.Name]; !ok {
				names = append(names, label.Name)
				seen[label.Name] = struct{}{}
			}
		}
	}
	sort.Strings(names)
	labelIndex := map[string]int{}
	for idx, name := range names {
		labelIndex[name] = idx
	}
	nameNumber := len(names)
	tl := make([]*schemav2pb.Node, len(names))
	for _, n := range names {
		tl = append(tl, LabelColumn(n))
	}
	buf, err := tables.Events.Schema().NewBufferV2(tl...)
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(e))
	for _, value := range e {
		row := make(parquet.Row, 0, nameNumber+24)

		lbI, lbJ := 0, 0
		for lbI < nameNumber {
			if names[lbI] == value.Labels[lbJ].Name {
				row = append(row, parquet.ValueOf(value.Labels[lbJ].Value).Level(0, 1, lbI+1))
				lbI++
				lbJ++
				if lbJ >= len(value.Labels) {
					for ; lbI < nameNumber; lbI++ {
						row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
					}
					break
				}
			} else {
				row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
				lbI++
			}
		}
		row = append(row, parquet.ValueOf(value.Name).Level(0, 0, nameNumber+1))
		row = append(row, parquet.ValueOf(value.Domain).Level(0, 0, nameNumber+2))
		row = append(row, parquet.ValueOf(value.UserId).Level(0, 0, nameNumber+3))
		row = append(row, parquet.ValueOf(value.SessionId).Level(0, 0, nameNumber+4))
		row = append(row, parquet.ValueOf(value.Hostname).Level(0, 0, nameNumber+5))
		row = append(row, parquet.ValueOf(value.Pathname).Level(0, 0, nameNumber+6))
		row = append(row, parquet.ValueOf(value.Referrer).Level(0, 0, nameNumber+7))
		row = append(row, parquet.ValueOf(value.ReferrerSource).Level(0, 0, nameNumber+8))
		row = append(row, parquet.ValueOf(value.CountryCode).Level(0, 0, nameNumber+9))
		row = append(row, parquet.ValueOf(value.ScreenSize).Level(0, 0, nameNumber+10))
		row = append(row, parquet.ValueOf(value.OperatingSystem).Level(0, 0, nameNumber+11))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, nameNumber+12))
		row = append(row, parquet.ValueOf(value.UtmMedium).Level(0, 0, nameNumber+13))
		row = append(row, parquet.ValueOf(value.UtmSource).Level(0, 0, nameNumber+14))
		row = append(row, parquet.ValueOf(value.UtmCampaign).Level(0, 0, nameNumber+15))
		row = append(row, parquet.ValueOf(value.BrowserVersion).Level(0, 0, nameNumber+16))
		row = append(row, parquet.ValueOf(value.OperatingSystemVersion).Level(0, 0, nameNumber+17))
		row = append(row, parquet.ValueOf(value.Subdivision1Code).Level(0, 0, nameNumber+18))
		row = append(row, parquet.ValueOf(value.Subdivision2Code).Level(0, 0, nameNumber+19))
		row = append(row, parquet.ValueOf(value.CityGeonameId).Level(0, 0, nameNumber+20))
		row = append(row, parquet.ValueOf(value.UtmContent).Level(0, 0, nameNumber+21))
		row = append(row, parquet.ValueOf(value.UtmTerm).Level(0, 0, nameNumber+22))
		row = append(row, parquet.ValueOf(value.TransferredFrom).Level(0, 0, nameNumber+23))
		row = append(row, parquet.ValueOf(value.Timestamp).Level(0, 0, nameNumber+25))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateEventTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(EventSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(EventTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var EventSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "event",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "name",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "domain",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "user_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "session_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "hostname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "pathname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "country_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "screen_size",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_medium",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_campaign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision1_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision2_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "city_geoname_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_content",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_term",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "transferred_from",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},

			{
				Type: &schemav2pb.Node_Group{
					Group: &schemav2pb.Group{
						Name:  "labels",
						Nodes: []*schemav2pb.Node{},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "timestamp",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
		},
	},
}

const SessionTable = "session"

type SessionList []*Session

func (s SessionList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	names := []string{}
	seen := map[string]struct{}{}
	for _, lb := range s {
		for _, label := range lb.Labels {
			if _, ok := seen[label.Name]; !ok {
				names = append(names, label.Name)
				seen[label.Name] = struct{}{}
			}
		}
	}
	sort.Strings(names)
	labelIndex := map[string]int{}
	for idx, name := range names {
		labelIndex[name] = idx
	}
	nameNumber := len(names)
	tl := make([]*schemav2pb.Node, len(names))
	for _, n := range names {
		tl = append(tl, LabelColumn(n))
	}
	buf, err := tables.Sessions.Schema().NewBufferV2(tl...)
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(s))
	for _, value := range s {
		row := make(parquet.Row, 0, nameNumber+30)

		lbI, lbJ := 0, 0
		for lbI < nameNumber {
			if names[lbI] == value.Labels[lbJ].Name {
				row = append(row, parquet.ValueOf(value.Labels[lbJ].Value).Level(0, 1, lbI+1))
				lbI++
				lbJ++
				if lbJ >= len(value.Labels) {
					for ; lbI < nameNumber; lbI++ {
						row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
					}
					break
				}
			} else {
				row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
				lbI++
			}
		}
		row = append(row, parquet.ValueOf(value.SessionId).Level(0, 0, nameNumber+1))
		row = append(row, parquet.ValueOf(value.Sign).Level(0, 0, nameNumber+2))
		row = append(row, parquet.ValueOf(value.Domain).Level(0, 0, nameNumber+3))
		row = append(row, parquet.ValueOf(value.UserId).Level(0, 0, nameNumber+4))
		row = append(row, parquet.ValueOf(value.Hostname).Level(0, 0, nameNumber+5))
		row = append(row, parquet.ValueOf(value.IsBounce).Level(0, 0, nameNumber+6))
		row = append(row, parquet.ValueOf(value.EntryPage).Level(0, 0, nameNumber+7))
		row = append(row, parquet.ValueOf(value.ExitPage).Level(0, 0, nameNumber+8))
		row = append(row, parquet.ValueOf(value.PageViews).Level(0, 0, nameNumber+9))
		row = append(row, parquet.ValueOf(value.Events).Level(0, 0, nameNumber+10))
		row = append(row, parquet.ValueOf(value.Duration).Level(0, 0, nameNumber+11))
		row = append(row, parquet.ValueOf(value.Referrer).Level(0, 0, nameNumber+12))
		row = append(row, parquet.ValueOf(value.ReferrerSource).Level(0, 0, nameNumber+13))
		row = append(row, parquet.ValueOf(value.CountryCode).Level(0, 0, nameNumber+14))
		row = append(row, parquet.ValueOf(value.OperatingSystem).Level(0, 0, nameNumber+15))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, nameNumber+16))
		row = append(row, parquet.ValueOf(value.UtmMedium).Level(0, 0, nameNumber+17))
		row = append(row, parquet.ValueOf(value.UtmSource).Level(0, 0, nameNumber+18))
		row = append(row, parquet.ValueOf(value.UtmCampaign).Level(0, 0, nameNumber+19))
		row = append(row, parquet.ValueOf(value.BrowserVersion).Level(0, 0, nameNumber+20))
		row = append(row, parquet.ValueOf(value.OperatingSystemVersion).Level(0, 0, nameNumber+21))
		row = append(row, parquet.ValueOf(value.Subdivision1Code).Level(0, 0, nameNumber+22))
		row = append(row, parquet.ValueOf(value.Subdivision2Code).Level(0, 0, nameNumber+23))
		row = append(row, parquet.ValueOf(value.CityGeonameId).Level(0, 0, nameNumber+24))
		row = append(row, parquet.ValueOf(value.UtmContent).Level(0, 0, nameNumber+25))
		row = append(row, parquet.ValueOf(value.UtmTerm).Level(0, 0, nameNumber+26))
		row = append(row, parquet.ValueOf(value.TransferredFrom).Level(0, 0, nameNumber+27))
		row = append(row, parquet.ValueOf(value.ScreenSize).Level(0, 0, nameNumber+28))
		row = append(row, parquet.ValueOf(value.Start).Level(0, 0, nameNumber+30))
		row = append(row, parquet.ValueOf(value.Timestamp).Level(0, 0, nameNumber+31))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateSessionTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(SessionSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(SessionTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var SessionSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "session",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "session_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "sign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "domain",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "user_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "hostname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "is_bounce",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_BOOL,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "entry_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exit_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "page_views",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "events",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:     schemav2pb.StorageLayout_TYPE_INT64,
							Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "country_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_medium",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_campaign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision1_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision2_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "city_geoname_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_content",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_term",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "transferred_from",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "screen_size",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},

			{
				Type: &schemav2pb.Node_Group{
					Group: &schemav2pb.Group{
						Name:  "labels",
						Nodes: []*schemav2pb.Node{},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "start",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "timestamp",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
		},
	},
}

const ImportedVisitorTable = "imported_visitor"

type ImportedVisitorList []*ImportedVisitor

func (i ImportedVisitorList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedVisitors.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Pageviews).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 6))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedVisitorTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedVisitorSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedVisitorTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedVisitorSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_visitor",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "pageviews",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedSourcesTable = "imported_sources"

type ImportedSourcesList []*ImportedSources

func (i ImportedSourcesList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedSources.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 11)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Source).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.UtmMedium).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.UtmCampaign).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.UtmContent).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.UtmTerm).Level(0, 0, 6))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 7))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 8))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 9))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 10))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedSourcesTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedSourcesSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedSourcesTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedSourcesSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_sources",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_medium",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_campaign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_content",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_term",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedPagesTable = "imported_pages"

type ImportedPagesList []*ImportedPages

func (i ImportedPagesList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedPages.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 8)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Hostname).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Page).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.Pagevies).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Exits).Level(0, 0, 6))
		row = append(row, parquet.ValueOf(value.TimeOnPage).Level(0, 0, 7))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedPagesTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedPagesSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedPagesTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedPagesSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_pages",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "hostname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "pagevies",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "time_on_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedEntryPagesTable = "imported_entry_pages"

type ImportedEntryPagesList []*ImportedEntryPages

func (i ImportedEntryPagesList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedEntryPages.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.EntryPage).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Entrances).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedEntryPagesTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedEntryPagesSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedEntryPagesTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedEntryPagesSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_entry_pages",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "entry_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "entrances",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedExitPagesTable = "imported_exit_pages"

type ImportedExitPagesList []*ImportedExitPages

func (i ImportedExitPagesList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedExitPages.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 5)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.ExitPage).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Exits).Level(0, 0, 4))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedExitPagesTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedExitPagesSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedExitPagesTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedExitPagesSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_exit_pages",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exit_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedLocationsTable = "imported_locations"

type ImportedLocationsList []*ImportedLocations

func (i ImportedLocationsList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedLocations.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 9)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Country).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Region).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.City).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 6))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 7))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 8))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedLocationsTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedLocationsSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedLocationsTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedLocationsSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_locations",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "country",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "region",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "city",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedDevicesTable = "imported_devices"

type ImportedDevicesList []*ImportedDevices

func (i ImportedDevicesList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedDevices.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Devise).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedDevicesTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedDevicesSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedDevicesTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedDevicesSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_devices",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "devise",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedBrowserTable = "imported_browser"

type ImportedBrowserList []*ImportedBrowser

func (i ImportedBrowserList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedBrowsers.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedBrowserTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedBrowserSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedBrowserTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedBrowserSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_browser",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedOperatingSystemTable = "imported_operating_system"

type ImportedOperatingSystemList []*ImportedOperatingSystem

func (i ImportedOperatingSystemList) Rows(tables *Tables) (*dynparquet.Buffer, error) {
	buf, err := tables.ImportedOperatingSystems.Schema().NewBufferV2()
	if err != nil {
		return nil, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}
	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err
}
func CreateImportedOperatingSystemTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedOperatingSystemSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedOperatingSystemTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedOperatingSystemSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_operating_system",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

type Tables struct {
	Events                   *frostdb.Table
	Sessions                 *frostdb.Table
	ImportedVisitors         *frostdb.Table
	ImportedSources          *frostdb.Table
	ImportedPages            *frostdb.Table
	ImportedEntryPages       *frostdb.Table
	ImportedExitPages        *frostdb.Table
	ImportedLocations        *frostdb.Table
	ImportedDevices          *frostdb.Table
	ImportedBrowsers         *frostdb.Table
	ImportedOperatingSystems *frostdb.Table
}

func NewTables(db *frostdb.DB, opts ...frostdb.TableOption) (*Tables, error) {
	event, err := CreateEventTable(db, opts...)
	if err != nil {
		return nil, err
	}
	session, err := CreateSessionTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedVisitor, err := CreateImportedVisitorTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedSources, err := CreateImportedSourcesTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedPages, err := CreateImportedPagesTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedEntryPages, err := CreateImportedEntryPagesTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedExitPages, err := CreateImportedExitPagesTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedLocations, err := CreateImportedLocationsTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedDevices, err := CreateImportedDevicesTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedBrowser, err := CreateImportedBrowserTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedOperatingSystem, err := CreateImportedOperatingSystemTable(db, opts...)
	if err != nil {
		return nil, err
	}

	return &Tables{
		Events:                   event,
		Sessions:                 session,
		ImportedVisitors:         importedVisitor,
		ImportedSources:          importedSources,
		ImportedPages:            importedPages,
		ImportedEntryPages:       importedEntryPages,
		ImportedExitPages:        importedExitPages,
		ImportedLocations:        importedLocations,
		ImportedDevices:          importedDevices,
		ImportedBrowsers:         importedBrowser,
		ImportedOperatingSystems: importedOperatingSystem,
	}, nil
}

func LabelColumn(name string) *schemav2pb.Node {
	return &schemav2pb.Node{
		Type: &schemav2pb.Node_Group{
			Group: &schemav2pb.Group{
				Name: "labels",
				Nodes: []*schemav2pb.Node{
					{
						Type: &schemav2pb.Node_Leaf{
							Leaf: &schemav2pb.Leaf{
								Name: name,
								StorageLayout: &schemav2pb.StorageLayout{
									Type:     schemav2pb.StorageLayout_TYPE_STRING,
									Nullable: true,
									Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
								},
							},
						},
					},
				},
			},
		},
	}
}
