// DO NOT EDIT Code generated by schema/make_schema.go
package vince

import (
	"bytes"
	"context"
	"sort"
	"sync"
	"testing"

	"github.com/polarsignals/frostdb"
	"github.com/polarsignals/frostdb/dynparquet"
	schemav2pb "github.com/polarsignals/frostdb/gen/proto/go/frostdb/schema/v1alpha2"
	"github.com/segmentio/parquet-go"
)

func NewTestDB(t *testing.T) *Tables {
	t.Helper()
	store, err := frostdb.New(
		frostdb.WithStoragePath(t.TempDir()),
	)
	if err != nil {
		t.Fatal(err)
	}
	t.Cleanup(func() {
		store.Close()
	})
	db, err := store.DB(context.TODO(), "vince")
	if err != nil {
		t.Fatal(err)
	}
	tbl, err := NewTables(db)
	if err != nil {
		t.Fatal(err)
	}
	return tbl
}

var buffPool = &sync.Pool{
	New: func() any {
		return &bytes.Buffer{}
	},
}

func getBuff() *bytes.Buffer {
	return buffPool.Get().(*bytes.Buffer)
}

func putBuff(b *bytes.Buffer) {
	b.Reset()
	buffPool.Put(b)
}

const EventTable = "event"

type EventList []*Event

var eventPool = &sync.Pool{
	New: func() any {
		return &Event{}
	},
}

func GetEvent() *Event {
	return eventPool.Get().(*Event)
}
func PutEvent(value *Event) {
	value.Reset()
	eventPool.Put(value)
}

var eventsPool = &sync.Pool{
	New: func() any {
		return make(EventList, 1024)
	},
}

func GetEvents() EventList {
	return eventsPool.Get().(EventList)
}
func PutEvents(value EventList) {
	for _, item := range value {
		PutEvent(item)
	}
	value = value[:0]
	eventsPool.Put(value)
}

func (e EventList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutEvents(e)
	names := []string{}
	seen := map[string]struct{}{}
	for _, lb := range e {
		for _, label := range lb.Labels {
			if _, ok := seen[label.Name]; !ok {
				names = append(names, label.Name)
				seen[label.Name] = struct{}{}
			}
		}
	}
	sort.Strings(names)
	labelIndex := map[string]int{}
	for idx, name := range names {
		labelIndex[name] = idx
	}
	nameNumber := len(names)
	tl := make([]*schemav2pb.Node, len(names))
	for _, n := range names {
		tl = append(tl, LabelColumn(n))
	}
	buf, err := tables.Events.Schema().NewBufferV2(tl...)
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(e))
	for _, value := range e {
		row := make(parquet.Row, 0, nameNumber+24)

		lbI, lbJ := 0, 0
		for lbI < nameNumber {
			if names[lbI] == value.Labels[lbJ].Name {
				row = append(row, parquet.ValueOf(value.Labels[lbJ].Value).Level(0, 1, lbI+1))
				lbI++
				lbJ++
				if lbJ >= len(value.Labels) {
					for ; lbI < nameNumber; lbI++ {
						row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
					}
					break
				}
			} else {
				row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
				lbI++
			}
		}
		row = append(row, parquet.ValueOf(value.Name).Level(0, 0, nameNumber+1))
		row = append(row, parquet.ValueOf(value.Domain).Level(0, 0, nameNumber+2))
		row = append(row, parquet.ValueOf(value.UserId).Level(0, 0, nameNumber+3))
		row = append(row, parquet.ValueOf(value.SessionId).Level(0, 0, nameNumber+4))
		row = append(row, parquet.ValueOf(value.Hostname).Level(0, 0, nameNumber+5))
		row = append(row, parquet.ValueOf(value.Pathname).Level(0, 0, nameNumber+6))
		row = append(row, parquet.ValueOf(value.Referrer).Level(0, 0, nameNumber+7))
		row = append(row, parquet.ValueOf(value.ReferrerSource).Level(0, 0, nameNumber+8))
		row = append(row, parquet.ValueOf(value.CountryCode).Level(0, 0, nameNumber+9))
		row = append(row, parquet.ValueOf(value.ScreenSize).Level(0, 0, nameNumber+10))
		row = append(row, parquet.ValueOf(value.OperatingSystem).Level(0, 0, nameNumber+11))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, nameNumber+12))
		row = append(row, parquet.ValueOf(value.UtmMedium).Level(0, 0, nameNumber+13))
		row = append(row, parquet.ValueOf(value.UtmSource).Level(0, 0, nameNumber+14))
		row = append(row, parquet.ValueOf(value.UtmCampaign).Level(0, 0, nameNumber+15))
		row = append(row, parquet.ValueOf(value.BrowserVersion).Level(0, 0, nameNumber+16))
		row = append(row, parquet.ValueOf(value.OperatingSystemVersion).Level(0, 0, nameNumber+17))
		row = append(row, parquet.ValueOf(value.Subdivision1Code).Level(0, 0, nameNumber+18))
		row = append(row, parquet.ValueOf(value.Subdivision2Code).Level(0, 0, nameNumber+19))
		row = append(row, parquet.ValueOf(value.CityGeonameId).Level(0, 0, nameNumber+20))
		row = append(row, parquet.ValueOf(value.UtmContent).Level(0, 0, nameNumber+21))
		row = append(row, parquet.ValueOf(value.UtmTerm).Level(0, 0, nameNumber+22))
		row = append(row, parquet.ValueOf(value.TransferredFrom).Level(0, 0, nameNumber+23))
		row = append(row, parquet.ValueOf(value.Timestamp).Level(0, 0, nameNumber+25))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.Events.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.Events.Insert(ctx, b.Bytes())
}
func CreateEventTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(EventSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(EventTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var EventSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "event",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "name",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "domain",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "user_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "session_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "hostname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "pathname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "country_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "screen_size",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_medium",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_campaign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision1_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision2_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "city_geoname_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_content",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_term",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "transferred_from",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},

			{
				Type: &schemav2pb.Node_Group{
					Group: &schemav2pb.Group{
						Name:  "labels",
						Nodes: []*schemav2pb.Node{},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "timestamp",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
		},
	},
}

const SessionTable = "session"

type SessionList []*Session

var sessionPool = &sync.Pool{
	New: func() any {
		return &Session{}
	},
}

func GetSession() *Session {
	return sessionPool.Get().(*Session)
}
func PutSession(value *Session) {
	value.Reset()
	sessionPool.Put(value)
}

var sessionsPool = &sync.Pool{
	New: func() any {
		return make(SessionList, 1024)
	},
}

func GetSessions() SessionList {
	return sessionsPool.Get().(SessionList)
}
func PutSessions(value SessionList) {
	for _, item := range value {
		PutSession(item)
	}
	value = value[:0]
	sessionsPool.Put(value)
}

func (s SessionList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutSessions(s)
	names := []string{}
	seen := map[string]struct{}{}
	for _, lb := range s {
		for _, label := range lb.Labels {
			if _, ok := seen[label.Name]; !ok {
				names = append(names, label.Name)
				seen[label.Name] = struct{}{}
			}
		}
	}
	sort.Strings(names)
	labelIndex := map[string]int{}
	for idx, name := range names {
		labelIndex[name] = idx
	}
	nameNumber := len(names)
	tl := make([]*schemav2pb.Node, len(names))
	for _, n := range names {
		tl = append(tl, LabelColumn(n))
	}
	buf, err := tables.Sessions.Schema().NewBufferV2(tl...)
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(s))
	for _, value := range s {
		row := make(parquet.Row, 0, nameNumber+30)

		lbI, lbJ := 0, 0
		for lbI < nameNumber {
			if names[lbI] == value.Labels[lbJ].Name {
				row = append(row, parquet.ValueOf(value.Labels[lbJ].Value).Level(0, 1, lbI+1))
				lbI++
				lbJ++
				if lbJ >= len(value.Labels) {
					for ; lbI < nameNumber; lbI++ {
						row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
					}
					break
				}
			} else {
				row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
				lbI++
			}
		}
		row = append(row, parquet.ValueOf(value.SessionId).Level(0, 0, nameNumber+1))
		row = append(row, parquet.ValueOf(value.Sign).Level(0, 0, nameNumber+2))
		row = append(row, parquet.ValueOf(value.Domain).Level(0, 0, nameNumber+3))
		row = append(row, parquet.ValueOf(value.UserId).Level(0, 0, nameNumber+4))
		row = append(row, parquet.ValueOf(value.Hostname).Level(0, 0, nameNumber+5))
		row = append(row, parquet.ValueOf(value.IsBounce).Level(0, 0, nameNumber+6))
		row = append(row, parquet.ValueOf(value.EntryPage).Level(0, 0, nameNumber+7))
		row = append(row, parquet.ValueOf(value.ExitPage).Level(0, 0, nameNumber+8))
		row = append(row, parquet.ValueOf(value.PageViews).Level(0, 0, nameNumber+9))
		row = append(row, parquet.ValueOf(value.Events).Level(0, 0, nameNumber+10))
		row = append(row, parquet.ValueOf(value.Duration).Level(0, 0, nameNumber+11))
		row = append(row, parquet.ValueOf(value.Referrer).Level(0, 0, nameNumber+12))
		row = append(row, parquet.ValueOf(value.ReferrerSource).Level(0, 0, nameNumber+13))
		row = append(row, parquet.ValueOf(value.CountryCode).Level(0, 0, nameNumber+14))
		row = append(row, parquet.ValueOf(value.OperatingSystem).Level(0, 0, nameNumber+15))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, nameNumber+16))
		row = append(row, parquet.ValueOf(value.UtmMedium).Level(0, 0, nameNumber+17))
		row = append(row, parquet.ValueOf(value.UtmSource).Level(0, 0, nameNumber+18))
		row = append(row, parquet.ValueOf(value.UtmCampaign).Level(0, 0, nameNumber+19))
		row = append(row, parquet.ValueOf(value.BrowserVersion).Level(0, 0, nameNumber+20))
		row = append(row, parquet.ValueOf(value.OperatingSystemVersion).Level(0, 0, nameNumber+21))
		row = append(row, parquet.ValueOf(value.Subdivision1Code).Level(0, 0, nameNumber+22))
		row = append(row, parquet.ValueOf(value.Subdivision2Code).Level(0, 0, nameNumber+23))
		row = append(row, parquet.ValueOf(value.CityGeonameId).Level(0, 0, nameNumber+24))
		row = append(row, parquet.ValueOf(value.UtmContent).Level(0, 0, nameNumber+25))
		row = append(row, parquet.ValueOf(value.UtmTerm).Level(0, 0, nameNumber+26))
		row = append(row, parquet.ValueOf(value.TransferredFrom).Level(0, 0, nameNumber+27))
		row = append(row, parquet.ValueOf(value.ScreenSize).Level(0, 0, nameNumber+28))
		row = append(row, parquet.ValueOf(value.Start).Level(0, 0, nameNumber+30))
		row = append(row, parquet.ValueOf(value.Timestamp).Level(0, 0, nameNumber+31))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.Sessions.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.Sessions.Insert(ctx, b.Bytes())
}
func CreateSessionTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(SessionSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(SessionTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var SessionSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "session",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "session_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "sign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "domain",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "user_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "hostname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "is_bounce",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_BOOL,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "entry_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exit_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "page_views",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "events",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:     schemav2pb.StorageLayout_TYPE_INT64,
							Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "referrer_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "country_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_medium",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_campaign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "operating_system_version",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision1_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "subdivision2_code",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "city_geoname_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_content",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_term",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "transferred_from",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "screen_size",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},

			{
				Type: &schemav2pb.Node_Group{
					Group: &schemav2pb.Group{
						Name:  "labels",
						Nodes: []*schemav2pb.Node{},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "start",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "timestamp",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
		},
	},
}

const ImportedVisitorTable = "imported_visitor"

type ImportedVisitorList []*ImportedVisitor

var importedVisitorPool = &sync.Pool{
	New: func() any {
		return &ImportedVisitor{}
	},
}

func GetImportedVisitor() *ImportedVisitor {
	return importedVisitorPool.Get().(*ImportedVisitor)
}
func PutImportedVisitor(value *ImportedVisitor) {
	value.Reset()
	importedVisitorPool.Put(value)
}

var importedVisitorsPool = &sync.Pool{
	New: func() any {
		return make(ImportedVisitorList, 1024)
	},
}

func GetImportedVisitors() ImportedVisitorList {
	return importedVisitorsPool.Get().(ImportedVisitorList)
}
func PutImportedVisitors(value ImportedVisitorList) {
	for _, item := range value {
		PutImportedVisitor(item)
	}
	value = value[:0]
	importedVisitorsPool.Put(value)
}

func (i ImportedVisitorList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedVisitors(i)
	buf, err := tables.ImportedVisitors.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Pageviews).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 6))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedVisitors.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedVisitors.Insert(ctx, b.Bytes())
}
func CreateImportedVisitorTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedVisitorSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedVisitorTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedVisitorSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_visitor",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "pageviews",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedSourceTable = "imported_source"

type ImportedSourceList []*ImportedSource

var importedSourcePool = &sync.Pool{
	New: func() any {
		return &ImportedSource{}
	},
}

func GetImportedSource() *ImportedSource {
	return importedSourcePool.Get().(*ImportedSource)
}
func PutImportedSource(value *ImportedSource) {
	value.Reset()
	importedSourcePool.Put(value)
}

var importedSourcesPool = &sync.Pool{
	New: func() any {
		return make(ImportedSourceList, 1024)
	},
}

func GetImportedSources() ImportedSourceList {
	return importedSourcesPool.Get().(ImportedSourceList)
}
func PutImportedSources(value ImportedSourceList) {
	for _, item := range value {
		PutImportedSource(item)
	}
	value = value[:0]
	importedSourcesPool.Put(value)
}

func (i ImportedSourceList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedSources(i)
	buf, err := tables.ImportedSources.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 11)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Source).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.UtmMedium).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.UtmCampaign).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.UtmContent).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.UtmTerm).Level(0, 0, 6))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 7))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 8))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 9))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 10))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedSources.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedSources.Insert(ctx, b.Bytes())
}
func CreateImportedSourceTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedSourceSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedSourceTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedSourceSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_source",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "source",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_medium",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_campaign",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_content",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "utm_term",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedPageTable = "imported_page"

type ImportedPageList []*ImportedPage

var importedPagePool = &sync.Pool{
	New: func() any {
		return &ImportedPage{}
	},
}

func GetImportedPage() *ImportedPage {
	return importedPagePool.Get().(*ImportedPage)
}
func PutImportedPage(value *ImportedPage) {
	value.Reset()
	importedPagePool.Put(value)
}

var importedPagesPool = &sync.Pool{
	New: func() any {
		return make(ImportedPageList, 1024)
	},
}

func GetImportedPages() ImportedPageList {
	return importedPagesPool.Get().(ImportedPageList)
}
func PutImportedPages(value ImportedPageList) {
	for _, item := range value {
		PutImportedPage(item)
	}
	value = value[:0]
	importedPagesPool.Put(value)
}

func (i ImportedPageList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedPages(i)
	buf, err := tables.ImportedPages.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 8)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Hostname).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Page).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.Pagevies).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Exits).Level(0, 0, 6))
		row = append(row, parquet.ValueOf(value.TimeOnPage).Level(0, 0, 7))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedPages.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedPages.Insert(ctx, b.Bytes())
}
func CreateImportedPageTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedPageSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedPageTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedPageSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_page",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "hostname",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "pagevies",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "time_on_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedEntryPageTable = "imported_entry_page"

type ImportedEntryPageList []*ImportedEntryPage

var importedEntryPagePool = &sync.Pool{
	New: func() any {
		return &ImportedEntryPage{}
	},
}

func GetImportedEntryPage() *ImportedEntryPage {
	return importedEntryPagePool.Get().(*ImportedEntryPage)
}
func PutImportedEntryPage(value *ImportedEntryPage) {
	value.Reset()
	importedEntryPagePool.Put(value)
}

var importedEntryPagesPool = &sync.Pool{
	New: func() any {
		return make(ImportedEntryPageList, 1024)
	},
}

func GetImportedEntryPages() ImportedEntryPageList {
	return importedEntryPagesPool.Get().(ImportedEntryPageList)
}
func PutImportedEntryPages(value ImportedEntryPageList) {
	for _, item := range value {
		PutImportedEntryPage(item)
	}
	value = value[:0]
	importedEntryPagesPool.Put(value)
}

func (i ImportedEntryPageList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedEntryPages(i)
	buf, err := tables.ImportedEntryPages.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.EntryPage).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Entrances).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedEntryPages.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedEntryPages.Insert(ctx, b.Bytes())
}
func CreateImportedEntryPageTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedEntryPageSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedEntryPageTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedEntryPageSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_entry_page",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "entry_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "entrances",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedExitPageTable = "imported_exit_page"

type ImportedExitPageList []*ImportedExitPage

var importedExitPagePool = &sync.Pool{
	New: func() any {
		return &ImportedExitPage{}
	},
}

func GetImportedExitPage() *ImportedExitPage {
	return importedExitPagePool.Get().(*ImportedExitPage)
}
func PutImportedExitPage(value *ImportedExitPage) {
	value.Reset()
	importedExitPagePool.Put(value)
}

var importedExitPagesPool = &sync.Pool{
	New: func() any {
		return make(ImportedExitPageList, 1024)
	},
}

func GetImportedExitPages() ImportedExitPageList {
	return importedExitPagesPool.Get().(ImportedExitPageList)
}
func PutImportedExitPages(value ImportedExitPageList) {
	for _, item := range value {
		PutImportedExitPage(item)
	}
	value = value[:0]
	importedExitPagesPool.Put(value)
}

func (i ImportedExitPageList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedExitPages(i)
	buf, err := tables.ImportedExitPages.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 5)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.ExitPage).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Exits).Level(0, 0, 4))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedExitPages.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedExitPages.Insert(ctx, b.Bytes())
}
func CreateImportedExitPageTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedExitPageSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedExitPageTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedExitPageSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_exit_page",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exit_page",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "exits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedLocationTable = "imported_location"

type ImportedLocationList []*ImportedLocation

var importedLocationPool = &sync.Pool{
	New: func() any {
		return &ImportedLocation{}
	},
}

func GetImportedLocation() *ImportedLocation {
	return importedLocationPool.Get().(*ImportedLocation)
}
func PutImportedLocation(value *ImportedLocation) {
	value.Reset()
	importedLocationPool.Put(value)
}

var importedLocationsPool = &sync.Pool{
	New: func() any {
		return make(ImportedLocationList, 1024)
	},
}

func GetImportedLocations() ImportedLocationList {
	return importedLocationsPool.Get().(ImportedLocationList)
}
func PutImportedLocations(value ImportedLocationList) {
	for _, item := range value {
		PutImportedLocation(item)
	}
	value = value[:0]
	importedLocationsPool.Put(value)
}

func (i ImportedLocationList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedLocations(i)
	buf, err := tables.ImportedLocations.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 9)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Country).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Region).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.City).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 6))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 7))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 8))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedLocations.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedLocations.Insert(ctx, b.Bytes())
}
func CreateImportedLocationTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedLocationSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedLocationTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedLocationSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_location",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "country",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "region",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "city",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedDeviceTable = "imported_device"

type ImportedDeviceList []*ImportedDevice

var importedDevicePool = &sync.Pool{
	New: func() any {
		return &ImportedDevice{}
	},
}

func GetImportedDevice() *ImportedDevice {
	return importedDevicePool.Get().(*ImportedDevice)
}
func PutImportedDevice(value *ImportedDevice) {
	value.Reset()
	importedDevicePool.Put(value)
}

var importedDevicesPool = &sync.Pool{
	New: func() any {
		return make(ImportedDeviceList, 1024)
	},
}

func GetImportedDevices() ImportedDeviceList {
	return importedDevicesPool.Get().(ImportedDeviceList)
}
func PutImportedDevices(value ImportedDeviceList) {
	for _, item := range value {
		PutImportedDevice(item)
	}
	value = value[:0]
	importedDevicesPool.Put(value)
}

func (i ImportedDeviceList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedDevices(i)
	buf, err := tables.ImportedDevices.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Devise).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedDevices.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedDevices.Insert(ctx, b.Bytes())
}
func CreateImportedDeviceTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedDeviceSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedDeviceTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedDeviceSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_device",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "devise",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedBrowserTable = "imported_browser"

type ImportedBrowserList []*ImportedBrowser

var importedBrowserPool = &sync.Pool{
	New: func() any {
		return &ImportedBrowser{}
	},
}

func GetImportedBrowser() *ImportedBrowser {
	return importedBrowserPool.Get().(*ImportedBrowser)
}
func PutImportedBrowser(value *ImportedBrowser) {
	value.Reset()
	importedBrowserPool.Put(value)
}

var importedBrowsersPool = &sync.Pool{
	New: func() any {
		return make(ImportedBrowserList, 1024)
	},
}

func GetImportedBrowsers() ImportedBrowserList {
	return importedBrowsersPool.Get().(ImportedBrowserList)
}
func PutImportedBrowsers(value ImportedBrowserList) {
	for _, item := range value {
		PutImportedBrowser(item)
	}
	value = value[:0]
	importedBrowsersPool.Put(value)
}

func (i ImportedBrowserList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedBrowsers(i)
	buf, err := tables.ImportedBrowsers.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedBrowsers.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedBrowsers.Insert(ctx, b.Bytes())
}
func CreateImportedBrowserTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedBrowserSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedBrowserTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedBrowserSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_browser",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

const ImportedOperatingSystemTable = "imported_operating_system"

type ImportedOperatingSystemList []*ImportedOperatingSystem

var importedOperatingSystemPool = &sync.Pool{
	New: func() any {
		return &ImportedOperatingSystem{}
	},
}

func GetImportedOperatingSystem() *ImportedOperatingSystem {
	return importedOperatingSystemPool.Get().(*ImportedOperatingSystem)
}
func PutImportedOperatingSystem(value *ImportedOperatingSystem) {
	value.Reset()
	importedOperatingSystemPool.Put(value)
}

var importedOperatingSystemsPool = &sync.Pool{
	New: func() any {
		return make(ImportedOperatingSystemList, 1024)
	},
}

func GetImportedOperatingSystems() ImportedOperatingSystemList {
	return importedOperatingSystemsPool.Get().(ImportedOperatingSystemList)
}
func PutImportedOperatingSystems(value ImportedOperatingSystemList) {
	for _, item := range value {
		PutImportedOperatingSystem(item)
	}
	value = value[:0]
	importedOperatingSystemsPool.Put(value)
}

func (i ImportedOperatingSystemList) Save(ctx context.Context, tables *Tables) (uint64, error) {
	defer PutImportedOperatingSystems(i)
	buf, err := tables.ImportedOperatingSystems.Schema().NewBufferV2()
	if err != nil {
		return 0, err
	}
	rows := make([]parquet.Row, len(i))
	for _, value := range i {
		row := make(parquet.Row, 0, 7)
		row = append(row, parquet.ValueOf(value.SiteId).Level(0, 0, 0))
		row = append(row, parquet.ValueOf(value.Date).Level(0, 0, 1))
		row = append(row, parquet.ValueOf(value.Browser).Level(0, 0, 2))
		row = append(row, parquet.ValueOf(value.Visitors).Level(0, 0, 3))
		row = append(row, parquet.ValueOf(value.Visits).Level(0, 0, 4))
		row = append(row, parquet.ValueOf(value.VisitDuration).Level(0, 0, 5))
		row = append(row, parquet.ValueOf(value.Bounces).Level(0, 0, 6))
		rows = append(rows, row)
	}

	_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.ImportedOperatingSystems.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.ImportedOperatingSystems.Insert(ctx, b.Bytes())
}
func CreateImportedOperatingSystemTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(ImportedOperatingSystemSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(ImportedOperatingSystemTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}

var ImportedOperatingSystemSchema = &schemav2pb.Schema{
	Root: &schemav2pb.Group{
		Name: "imported_operating_system",
		Nodes: []*schemav2pb.Node{
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "site_id",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "date",
						StorageLayout: &schemav2pb.StorageLayout{
							Type:        schemav2pb.StorageLayout_TYPE_INT64,
							Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
							Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "browser",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_STRING,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visitors",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visits",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "visit_duration",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
			{
				Type: &schemav2pb.Node_Leaf{
					Leaf: &schemav2pb.Leaf{
						Name: "bounces",
						StorageLayout: &schemav2pb.StorageLayout{
							Type: schemav2pb.StorageLayout_TYPE_INT64,
						},
					},
				},
			},
		},
	},
}

type Tables struct {
	Events                   *frostdb.Table
	Sessions                 *frostdb.Table
	ImportedVisitors         *frostdb.Table
	ImportedSources          *frostdb.Table
	ImportedPages            *frostdb.Table
	ImportedEntryPages       *frostdb.Table
	ImportedExitPages        *frostdb.Table
	ImportedLocations        *frostdb.Table
	ImportedDevices          *frostdb.Table
	ImportedBrowsers         *frostdb.Table
	ImportedOperatingSystems *frostdb.Table
}

func NewTables(db *frostdb.DB, opts ...frostdb.TableOption) (*Tables, error) {
	event, err := CreateEventTable(db, opts...)
	if err != nil {
		return nil, err
	}
	session, err := CreateSessionTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedVisitor, err := CreateImportedVisitorTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedSource, err := CreateImportedSourceTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedPage, err := CreateImportedPageTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedEntryPage, err := CreateImportedEntryPageTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedExitPage, err := CreateImportedExitPageTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedLocation, err := CreateImportedLocationTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedDevice, err := CreateImportedDeviceTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedBrowser, err := CreateImportedBrowserTable(db, opts...)
	if err != nil {
		return nil, err
	}
	importedOperatingSystem, err := CreateImportedOperatingSystemTable(db, opts...)
	if err != nil {
		return nil, err
	}

	return &Tables{
		Events:                   event,
		Sessions:                 session,
		ImportedVisitors:         importedVisitor,
		ImportedSources:          importedSource,
		ImportedPages:            importedPage,
		ImportedEntryPages:       importedEntryPage,
		ImportedExitPages:        importedExitPage,
		ImportedLocations:        importedLocation,
		ImportedDevices:          importedDevice,
		ImportedBrowsers:         importedBrowser,
		ImportedOperatingSystems: importedOperatingSystem,
	}, nil
}

func LabelColumn(name string) *schemav2pb.Node {
	return &schemav2pb.Node{
		Type: &schemav2pb.Node_Group{
			Group: &schemav2pb.Group{
				Name: "labels",
				Nodes: []*schemav2pb.Node{
					{
						Type: &schemav2pb.Node_Leaf{
							Leaf: &schemav2pb.Leaf{
								Name: name,
								StorageLayout: &schemav2pb.StorageLayout{
									Type:     schemav2pb.StorageLayout_TYPE_STRING,
									Nullable: true,
									Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
								},
							},
						},
					},
				},
			},
		},
	}
}
