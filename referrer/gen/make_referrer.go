package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/url"
	"os"
	"sort"
	"strings"
)

//go:embed referrer.json
var refererJSON string

var index = map[string]bool{}
var refs = map[string]struct{}{}

type Domains struct {
	Type    string   `json:"-"`
	Name    string   `json:"-"`
	Index   int      `json:"-"`
	Domains []string `json:"domains"`
	Hosts   []string `json:"-"`
}

var domains []*Domains

type Name struct {
	name   string
	domain string
}

var names []*Name

func main() {
	var maxLen int
	var minLen = 6

	dec := json.NewDecoder(strings.NewReader(refererJSON))
	{
		_, err := dec.Token()
		if err != nil {
			log.Fatal(err)
		}
		for {
			t, err := dec.Token()
			if err == io.EOF {
				break
			}
			metaType, ok := t.(string)
			if !ok {
				break
			}
			dec.Token()
			for {
				t, err = dec.Token()
				if err == io.EOF {
					break
				}
				metaName, ok := t.(string)
				if !ok {
					break
				}
				var x Domains
				dec.Decode(&x)
				x.Type = metaType
				x.Name = metaName
				names = append(names, &Name{
					name:   x.Name,
					domain: x.Domains[0],
				})
				for _, d := range x.Domains {
					refs[d] = struct{}{}
					u, _ := url.Parse("http://" + d)
					host := strings.TrimPrefix(u.Host, "www.")
					parts := strings.Split(host, ".")
					sort.Sort(sort.Reverse(StringSlice(parts)))
					if len(parts) > int(maxLen) {
						maxLen = len(parts)
					}
					host = strings.Join(parts, ".")
					if len(parts) < minLen {
						minLen = len(parts)
					}
					if index[host] {
						continue
					}
					x.Hosts = append(x.Hosts, host)
					index[host] = true
				}
				domains = append(domains, &x)
			}
		}
	}

	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by referrer/make_referrer.go")
	fmt.Fprintln(&b, " package referrer")
	fmt.Fprintln(&b, " import \"sync\"")
	fmt.Fprintln(&b, " var Favicon =&sync.Map{}")
	fmt.Fprintln(&b, " func init() {")
	for _, v := range names {
		fmt.Fprintf(&b, " Favicon.Store(%q,%q)\n", v.name, v.domain)
	}
	fmt.Fprintln(&b, " }")
	fmt.Fprintf(&b, " const minReferrerSize=%d\n", minLen)
	fmt.Fprintf(&b, " const maxReferrerSize=%d\n", maxLen)
	fmt.Fprintln(&b, `
	type Medium struct {
		Type       string
		Name       string
	}
	`)
	fmt.Fprintln(&b, "var refList=map[string]*Medium{")
	for _, m := range domains {
		for _, h := range m.Hosts {
			fmt.Fprintf(&b, "%q:{Type:%q,Name:%q},\n", h, m.Type, m.Name)
		}
	}
	fmt.Fprintln(&b, "}")

	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("referrer_data.go", r, 0600)

	b.Reset()
	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by referrer/make_referrer.go")
	fmt.Fprintln(&b, " package main")
	fmt.Fprintf(&b, " var domains=[%d]string{\n", len(refs))
	var ls []string
	for k := range refs {
		ls = append(ls, k)
	}
	sort.Strings(ls)
	for i, k := range ls {
		if i%4 == 0 {
			b.WriteByte('\n')
		}
		fmt.Fprintf(&b, "%q,", k)
	}
	fmt.Fprintln(&b, "\n}")

	r, err = format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	err = os.WriteFile("../cmd/load/domains.go", r, 0600)
	if err != nil {
		log.Fatal(err)
	}
}

type StringSlice []string

func (x StringSlice) Len() int           { return len(x) }
func (x StringSlice) Less(i, j int) bool { return i < j }
func (x StringSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
