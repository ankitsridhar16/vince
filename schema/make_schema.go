package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"unicode"

	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/protoparse"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	p := &protoparse.Parser{}

	descp, err := p.ParseFiles("events.proto")
	if err != nil {
		log.Fatal(err)
	}
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by schema/make_schema.go")
	fmt.Fprintln(&b, " package vince")
	fmt.Fprintln(&b, `
	import (
		"bytes"
		"context"
		"sort"
		"sync"
		"testing"

		"github.com/polarsignals/frostdb"
		"github.com/polarsignals/frostdb/dynparquet"
		schemav2pb "github.com/polarsignals/frostdb/gen/proto/go/frostdb/schema/v1alpha2"
		"github.com/segmentio/parquet-go"
	)

	func NewTestDB(t *testing.T) *Tables {
		t.Helper()
		store, err := frostdb.New(
			frostdb.WithStoragePath(t.TempDir()),
		)
		if err != nil {
			t.Fatal(err)
		}
		t.Cleanup(func() {
			store.Close()
		})
		db, err := store.DB(context.TODO(), "vince")
		if err != nil {
			t.Fatal(err)
		}
		tbl, err := NewTables(db)
		if err != nil {
			t.Fatal(err)
		}
		return tbl
	}
	
	var buffPool = &sync.Pool{
		New: func() any {
			return &bytes.Buffer{}
		},
	}
	
	func getBuff() *bytes.Buffer {
		return buffPool.Get().(*bytes.Buffer)
	}
	
	func putBuff(b *bytes.Buffer) {
		b.Reset()
		buffPool.Put(b)
	}
	`)

	messages := descp[0].GetMessageTypes()

	var tables bytes.Buffer
	var tablesBody bytes.Buffer
	var tablesResult bytes.Buffer

	tables.WriteString("type Tables struct{\n")
	tablesResult.WriteString("return &Tables{\n")
	for _, d := range messages {
		n := d.GetName()
		if n == "Label" {
			continue
		}
		fmt.Fprintln(&b)
		fmt.Fprintf(&b, "const %sTable=%q\n", n, tableName(n))
		fmt.Fprintf(&tables, "%s *frostdb.Table\n", fieldCase(n))
		fmt.Fprintf(&tablesBody, `	%s, err := Create%sTable(db, opts...)
		if err != nil {
			return nil, err
		}
		`, variableCase(n), n)
		fmt.Fprintf(&tablesResult, "%s: %s,\n", fieldCase(n), variableCase(n))
		fmt.Fprintf(&b, "type %sList []*%s\n", n, n)
		fmt.Fprintf(&b, createPool, variableCase(n), n)
		fmt.Fprintf(&b, getItem, n, n, variableCase(n), n)
		fmt.Fprintf(&b, putItem, n, n, variableCase(n))
		createToRow(&b, d)
		fmt.Fprintf(&b, createTable, n, n, n)
		createSchema(&b, d)
	}
	tables.WriteString("}")
	fmt.Fprintf(&b, `
	%s 

	func NewTables(db *frostdb.DB, opts ...frostdb.TableOption) (*Tables, error) {
		%s
		%s
		}, nil
	}
	`, &tables, &tablesBody, &tablesResult)
	fmt.Fprintln(&b, labelColumn)
	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("events_schema.go", r, 0600)
}

func createSchema(b *bytes.Buffer, d *desc.MessageDescriptor) {
	fmt.Fprintln(b)
	name := d.GetName()
	fmt.Fprintf(b, "var %sSchema= &schemav2pb.Schema{\n", name)
	fmt.Fprintf(b, "                Root: &schemav2pb.Group{\n")
	fmt.Fprintf(b, "                         Name: %q,\n", tableName(name))
	fmt.Fprintf(b, "                         Nodes: []*schemav2pb.Node{\n")
	for _, f := range d.GetFields() {
		t := f.GetType()
		n := f.GetName()
		switch t {
		case descriptorpb.FieldDescriptorProto_TYPE_STRING:
			fmt.Fprintf(b, stringFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
			descriptorpb.FieldDescriptorProto_TYPE_UINT32,
			descriptorpb.FieldDescriptorProto_TYPE_INT32:
			fmt.Fprintf(b, intFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
			fmt.Fprintf(b, boolFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
			msg := f.GetMessageType()
			switch msg.GetName() {
			case "Timestamp":
				fmt.Fprintf(b, timestampFmt, n)
			case "Duration":
				fmt.Fprintf(b, durationFmt, n)
			case "Label":
				fmt.Fprint(b, stringArrayFmt)
			}
		default:
			println(t)
		}
	}
	fmt.Fprintf(b, "                               },\n")
	fmt.Fprintf(b, "                       },\n")
	fmt.Fprintf(b, "              }")
}

func createToRow(b *bytes.Buffer, d *desc.MessageDescriptor) {
	fmt.Fprintln(b)
	n := d.GetName()
	r := strings.ToLower(n[:1])
	hasLabel := n == "Event" || n == "Session"
	fmt.Fprintf(b, `
	func (%s %sList)Save(ctx context.Context, tables *Tables)(uint64, error){
		`, r, n)
	if hasLabel {
		fmt.Fprintf(b, labelName, r, fieldCase(n))
	} else {
		fmt.Fprintf(b, `	buf, err := tables.%s.Schema().NewBufferV2()
		if err != nil {
			return 0, err
		}
		`, fieldCase(n))
	}
	fmt.Fprintf(b, "    rows:=make([]parquet.Row,len(%s))\n", r)
	fmt.Fprintf(b, "    for _,value:=range %s{\n", r)
	if hasLabel {
		fmt.Fprintf(b, "    row:= make(parquet.Row, 0, nameNumber+%d)\n", len(d.GetFields())-1)
		fmt.Fprintln(b, labelWrite)
	} else {
		fmt.Fprintf(b, "    row:= make(parquet.Row, 0, %d)\n", len(d.GetFields()))
	}
	for i, f := range d.GetFields() {
		fn := f.GetName()
		if fn == "labels" {
			continue
		}
		switch f.GetType() {
		case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
			msg := f.GetMessageType()
			switch msg.GetName() {
			case "Timestamp", "Duration":
				if hasLabel {
					fmt.Fprintf(b, " row =append(row,parquet.ValueOf(value.%s.Seconds).Level(0, 0, nameNumber+%d))\n", camelCase(fn), i+1)
				} else {
					fmt.Fprintf(b, " row =append(row,parquet.ValueOf(value.%s.Seconds).Level(0, 0, %d))\n", camelCase(fn), i)
				}
			}
		default:
			if hasLabel {
				fmt.Fprintf(b, " row =append(row,parquet.ValueOf(value.%s).Level(0, 0, nameNumber+%d))\n", camelCase(fn), i+1)
			} else {
				fmt.Fprintf(b, " row =append(row,parquet.ValueOf(value.%s).Level(0, 0, %d))\n", camelCase(fn), i)
			}
		}

	}
	fmt.Fprintln(b, "    rows = append(rows, row)")
	fmt.Fprintln(b, "   }")
	fmt.Fprintf(b, `
		_, err = buf.WriteRows(rows)
	if err != nil {
		return 0, err
	}
	b := getBuff()
	defer putBuff(b)
	err = tables.%s.Schema().SerializeBuffer(b, buf)
	if err != nil {
		return 0, err
	}
	return tables.%s.Insert(ctx, b.Bytes())
	`, fieldCase(n), fieldCase(n))
	fmt.Fprintln(b, "}")
}

func tableName(s string) string {
	var x strings.Builder
	for i, b := range s {
		if i != 0 && unicode.IsUpper(b) {
			x.WriteByte('_')
		}
		x.WriteRune(b)
	}
	return strings.ToLower(x.String())
}

const stringFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:        schemav2pb.StorageLayout_TYPE_STRING,
			},
		},
	},
},
`
const stringArrayFmt = `
{
	Type: &schemav2pb.Node_Group{
		Group: &schemav2pb.Group{
			Name:  "labels",
			Nodes: []*schemav2pb.Node{},
		},
	},
},
`

const intFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
			},
		},
	},
},
`
const durationFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
				Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
			},
		},
	},
},
`
const timestampFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
				Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
				Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
			},
		},
	},
},
`
const boolFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_BOOL,
			},
		},
	},
},
`

const labelName = `names := []string{}
seen := map[string]struct{}{}
for _, lb := range %s {
	for _, label := range lb.Labels {
		if _, ok := seen[label.Name]; !ok {
			names = append(names, label.Name)
			seen[label.Name] = struct{}{}
		}
	}
}
sort.Strings(names)
labelIndex:=map[string]int{}
for idx,name:=range names{
	labelIndex[name]=idx
}
nameNumber:=len(names)
tl := make([]*schemav2pb.Node, len(names))
for _, n := range names {
	tl = append(tl, LabelColumn(n))
}
buf, err := tables.%s.Schema().NewBufferV2(tl...)
if err != nil {
	return 0, err
}
`

const labelWrite = `
lbI, lbJ := 0, 0
for lbI < nameNumber {
	if names[lbI] == value.Labels[lbJ].Name {
		row = append(row, parquet.ValueOf(value.Labels[lbJ].Value).Level(0, 1, lbI+1))
		lbI++
		lbJ++
		if lbJ >= len(value.Labels) {
			for ; lbI < nameNumber; lbI++ {
				row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
			}
			break
		}
	} else {
		row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
		lbI++
	}
}`

const labelColumn = `
func LabelColumn(name string) *schemav2pb.Node {
	return &schemav2pb.Node{
		Type: &schemav2pb.Node_Group{
			Group: &schemav2pb.Group{
				Name: "labels",
				Nodes: []*schemav2pb.Node{
					{
						Type: &schemav2pb.Node_Leaf{
							Leaf: &schemav2pb.Leaf{
								Name: name,
								StorageLayout: &schemav2pb.StorageLayout{
									Type:     schemav2pb.StorageLayout_TYPE_STRING,
									Nullable: true,
									Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
								},
							},
						},
					},
				},
			},
		},
	}
}`

const createTable = `func Create%sTable(db *frostdb.DB, opts ...frostdb.TableOption) (*frostdb.Table, error) {
	tableSchema, err := dynparquet.SchemaFromDefinition(%sSchema)
	if err != nil {
		return nil, err
	}
	return db.Table(%sTable, frostdb.NewTableConfig(
		tableSchema, opts...,
	))
}
`

const createPool = `
var %sPool = &sync.Pool{
	New: func() any {
		return &%s{}
	},
}`
const getItem = `
func Get%s() *%s {
	return %sPool.Get().(*%s)
}`

const putItem = `
func Put%s(value *%s) {
	value.Reset()
	%sPool.Put(value)
}
`

func camelCase(s string) string {
	var b strings.Builder
	up := true
	for _, x := range s {
		if x == '_' {
			up = true
			continue
		}
		if up {
			b.WriteRune(unicode.ToUpper(x))
			up = false
			continue
		}
		b.WriteRune(x)
	}
	return b.String()
}

func variableCase(s string) string {
	var b strings.Builder
	for i, x := range s {
		if i == 0 {
			b.WriteRune(unicode.ToLower(x))
			continue
		}
		b.WriteRune(x)
	}
	return b.String()
}
func fieldCase(s string) string {
	if s[len(s)-1] == 's' {
		return s
	}
	return s + "s"
}
