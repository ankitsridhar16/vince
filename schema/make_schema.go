package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"unicode"

	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/protoparse"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	p := &protoparse.Parser{}

	descp, err := p.ParseFiles("events.proto")
	if err != nil {
		log.Fatal(err)
	}
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by schema/make_schema.go")
	fmt.Fprintln(&b, " package vince")
	fmt.Fprintln(&b, `
	import (
		schemav2pb "github.com/polarsignals/frostdb/gen/proto/go/frostdb/schema/v1alpha2"
	)
	`)

	messages := descp[0].GetMessageTypes()

	for _, d := range messages {
		n := d.GetName()
		fmt.Fprintf(&b, "const %sTable=%q\n", n, tableName(n))
	}
	for _, d := range messages {
		createSchema(&b, d)
	}
	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("events_schema.go", r, 0600)
}

const group = "&schemav2pb.Group{"
const node = "*schemav2pb.Node"
const nodeGroup = "chemav2pb.Node_Group"

func createSchema(b *bytes.Buffer, d *desc.MessageDescriptor) {
	fmt.Fprintln(b)
	name := d.GetName()
	fmt.Fprintf(b, "var %sSchema= &schemav2pb.Schema{\n", name)
	fmt.Fprintf(b, "                Root: &schemav2pb.Group{\n")
	fmt.Fprintf(b, "                         Name: %q,\n", tableName(name))
	fmt.Fprintf(b, "                         Nodes: []*schemav2pb.Node{\n")
	for _, f := range d.GetFields() {
		t := f.GetType()
		n := f.GetName()
		switch t {
		case descriptorpb.FieldDescriptorProto_TYPE_STRING:
			fmt.Fprintf(b, stringFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
			descriptorpb.FieldDescriptorProto_TYPE_UINT32,
			descriptorpb.FieldDescriptorProto_TYPE_INT32:
			fmt.Fprintf(b, intFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
			fmt.Fprintf(b, boolFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
			msg := f.GetMessageType()
			switch msg.GetName() {
			case "Timestamp":
				fmt.Fprintf(b, timestampFmt, n)
			case "Duration":
				fmt.Fprintf(b, durationFmt, n)
			case "Label":
				fmt.Fprint(b, stringArrayFmt)
			}
		default:
			println(t)
		}
	}
	fmt.Fprintf(b, "                               },\n")
	fmt.Fprintf(b, "                       },\n")
	fmt.Fprintf(b, "              }")
}

func tableName(s string) string {
	var x strings.Builder
	for i, b := range s {
		if i != 0 && unicode.IsUpper(b) {
			x.WriteByte('_')
		}
		x.WriteRune(b)
	}
	return strings.ToLower(x.String())
}

const stringFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:        schemav2pb.StorageLayout_TYPE_STRING,
			},
		},
	},
},
`
const stringArrayFmt = `
{
	Type: &schemav2pb.Node_Group{
		Group: &schemav2pb.Group{
			Name:  "labels",
			Nodes: []*schemav2pb.Node{},
		},
	},
},
`

const intFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
			},
		},
	},
},
`
const durationFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
				Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
			},
		},
	},
},
`
const timestampFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
				Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
				Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
			},
		},
	},
},
`
const boolFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_BOOL,
			},
		},
	},
},
`
