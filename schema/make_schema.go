package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"unicode"

	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/protoparse"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	p := &protoparse.Parser{}

	descp, err := p.ParseFiles("events.proto")
	if err != nil {
		log.Fatal(err)
	}
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by schema/make_schema.go")
	fmt.Fprintln(&b, " package vince")
	fmt.Fprintln(&b, `
	import (
		"sort"

		"github.com/polarsignals/frostdb/dynparquet"
		schemav2pb "github.com/polarsignals/frostdb/gen/proto/go/frostdb/schema/v1alpha2"
		"github.com/segmentio/parquet-go"
	)
	`)

	messages := descp[0].GetMessageTypes()

	for _, d := range messages {

		n := d.GetName()
		if n == "Label" {
			continue
		}
		fmt.Fprintln(&b)
		fmt.Fprintf(&b, "const %sTable=%q\n", n, tableName(n))
		fmt.Fprintf(&b, "type %sList []*%s\n", n, n)
		createToRow(&b, d)
		createSchema(&b, d)
	}
	fmt.Fprintln(&b, labelColumn)
	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("events_schema.go", r, 0600)
}

func createSchema(b *bytes.Buffer, d *desc.MessageDescriptor) {
	fmt.Fprintln(b)
	name := d.GetName()
	fmt.Fprintf(b, "var %sSchema= &schemav2pb.Schema{\n", name)
	fmt.Fprintf(b, "                Root: &schemav2pb.Group{\n")
	fmt.Fprintf(b, "                         Name: %q,\n", tableName(name))
	fmt.Fprintf(b, "                         Nodes: []*schemav2pb.Node{\n")
	for _, f := range d.GetFields() {
		t := f.GetType()
		n := f.GetName()
		switch t {
		case descriptorpb.FieldDescriptorProto_TYPE_STRING:
			fmt.Fprintf(b, stringFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
			descriptorpb.FieldDescriptorProto_TYPE_UINT32,
			descriptorpb.FieldDescriptorProto_TYPE_INT32:
			fmt.Fprintf(b, intFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
			fmt.Fprintf(b, boolFmt, n)
		case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
			msg := f.GetMessageType()
			switch msg.GetName() {
			case "Timestamp":
				fmt.Fprintf(b, timestampFmt, n)
			case "Duration":
				fmt.Fprintf(b, durationFmt, n)
			case "Label":
				fmt.Fprint(b, stringArrayFmt)
			}
		default:
			println(t)
		}
	}
	fmt.Fprintf(b, "                               },\n")
	fmt.Fprintf(b, "                       },\n")
	fmt.Fprintf(b, "              }")
}

func createToRow(b *bytes.Buffer, d *desc.MessageDescriptor) {
	fmt.Fprintln(b)
	n := d.GetName()
	r := strings.ToLower(n[:1])
	hasLabel := n == "Event" || n == "Session"
	fmt.Fprintf(b, "func (%s %sList)Rows(schema *dynparquet.Schema)(*dynparquet.Buffer, error){\n", r, n)
	if hasLabel {
		fmt.Fprintf(b, labelName, r)
	} else {
		fmt.Fprintln(b, `	buf, err := schema.NewBufferV2()
		if err != nil {
			return nil, err
		}`)
	}
	fmt.Fprintf(b, "    rows:=make([]parquet.Row,len(%s))\n", r)
	fmt.Fprintf(b, "    for _,value:=range %s{\n", r)
	if hasLabel {
		fmt.Fprintf(b, "    row:= make(parquet.Row, 0, nameNumber+%d)\n", len(d.GetFields())-1)
		fmt.Fprintln(b, labelWrite)
	} else {
		fmt.Fprintf(b, "    row:= make(parquet.Row, 0, %d)\n", len(d.GetFields()))
	}
	for i, f := range d.GetFields() {
		fn := f.GetName()
		if fn == "labels" {
			continue
		}
		if hasLabel {
			fmt.Fprintf(b, " row =append(row,parquet.ValueOf(value.%s).Level(0, 0, nameNumber+%d))\n", camelCase(fn), i+1)
		} else {
			fmt.Fprintf(b, " row =append(row,parquet.ValueOf(value.%s).Level(0, 0, %d))\n", camelCase(fn), i)
		}
	}
	fmt.Fprintln(b, "    rows = append(rows, row)")
	fmt.Fprintln(b, "   }")
	fmt.Fprintln(b, `	_, err = buf.WriteRows(rows)
	if err != nil {
		return nil, err
	}
	return buf, err`)
	fmt.Fprintln(b, "}")
}

func tableName(s string) string {
	var x strings.Builder
	for i, b := range s {
		if i != 0 && unicode.IsUpper(b) {
			x.WriteByte('_')
		}
		x.WriteRune(b)
	}
	return strings.ToLower(x.String())
}

const stringFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:        schemav2pb.StorageLayout_TYPE_STRING,
			},
		},
	},
},
`
const stringArrayFmt = `
{
	Type: &schemav2pb.Node_Group{
		Group: &schemav2pb.Group{
			Name:  "labels",
			Nodes: []*schemav2pb.Node{},
		},
	},
},
`

const intFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
			},
		},
	},
},
`
const durationFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
				Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
			},
		},
	},
},
`
const timestampFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_INT64,
				Encoding:    schemav2pb.StorageLayout_ENCODING_DELTA_BINARY_PACKED,
				Compression: schemav2pb.StorageLayout_COMPRESSION_ZSTD,
			},
		},
	},
},
`
const boolFmt = `{
	Type: &schemav2pb.Node_Leaf{
		Leaf: &schemav2pb.Leaf{
			Name: %q,
			StorageLayout: &schemav2pb.StorageLayout{
				Type:     schemav2pb.StorageLayout_TYPE_BOOL,
			},
		},
	},
},
`

const labelName = `names := []string{}
seen := map[string]struct{}{}
for _, lb := range %s {
	for _, label := range lb.Labels {
		if _, ok := seen[label.Name]; !ok {
			names = append(names, label.Name)
			seen[label.Name] = struct{}{}
		}
	}
}
sort.Strings(names)
labelIndex:=map[string]int{}
for idx,name:=range names{
	labelIndex[name]=idx
}
nameNumber:=len(names)
tl := make([]*schemav2pb.Node, len(names))
for _, n := range names {
	tl = append(tl, LabelColumn(n))
}
buf, err := schema.NewBufferV2(tl...)
if err != nil {
	return nil, err
}
`

const labelWrite = `
lbI, lbJ := 0, 0
for lbI < nameNumber {
	if names[lbI] == value.Labels[lbJ].Name {
		row = append(row, parquet.ValueOf(value.Labels[lbJ].Value).Level(0, 1, lbI+1))
		lbI++
		lbJ++
		if lbJ >= len(value.Labels) {
			for ; lbI < nameNumber; lbI++ {
				row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
			}
			break
		}
	} else {
		row = append(row, parquet.ValueOf(nil).Level(0, 1, lbI+1))
		lbI++
	}
}`

const labelColumn = `
func LabelColumn(name string) *schemav2pb.Node {
	return &schemav2pb.Node{
		Type: &schemav2pb.Node_Group{
			Group: &schemav2pb.Group{
				Name: "labels",
				Nodes: []*schemav2pb.Node{
					{
						Type: &schemav2pb.Node_Leaf{
							Leaf: &schemav2pb.Leaf{
								Name: name,
								StorageLayout: &schemav2pb.StorageLayout{
									Type:     schemav2pb.StorageLayout_TYPE_STRING,
									Nullable: true,
									Encoding: schemav2pb.StorageLayout_ENCODING_RLE_DICTIONARY,
								},
							},
						},
					},
				},
			},
		},
	}
}`

func camelCase(s string) string {
	var b strings.Builder
	up := true
	for _, x := range s {
		if x == '_' {
			up = true
			continue
		}
		if up {
			b.WriteRune(unicode.ToUpper(x))
			up = false
			continue
		}
		b.WriteRune(x)
	}
	return b.String()
}
