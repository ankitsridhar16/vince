// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "staples/v1/base.proto" (package "v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * @generated from protobuf message v1.ScanRequest
 */
export interface ScanRequest {
    /**
     * @generated from protobuf field: v1.TimeRange timestamp = 1;
     */
    timestamp?: TimeRange;
    /**
     * @generated from protobuf field: v1.Filters filters = 2;
     */
    filters?: Filters;
}
/**
 * @generated from protobuf message v1.ScanResponse
 */
export interface ScanResponse {
    /**
     * @generated from protobuf field: bytes record = 1;
     */
    record: Uint8Array;
}
/**
 * @generated from protobuf message v1.TimeRange
 */
export interface TimeRange {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
}
/**
 * @generated from protobuf message v1.KeyValue
 */
export interface KeyValue {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message v1.Filters
 */
export interface Filters {
    /**
     * @generated from protobuf field: repeated v1.Filter list = 1;
     */
    list: Filter[];
    /**
     * columns returned
     *
     * @generated from protobuf field: repeated v1.Filters.Projection projection = 2;
     */
    projection: Filters_Projection[];
}
/**
 * @generated from protobuf enum v1.Filters.Projection
 */
export enum Filters_Projection {
    /**
     * @generated from protobuf enum value: Timestamp = 0;
     */
    Timestamp = 0,
    /**
     * @generated from protobuf enum value: ID = 1;
     */
    ID = 1,
    /**
     * @generated from protobuf enum value: Bounce = 2;
     */
    Bounce = 2,
    /**
     * @generated from protobuf enum value: Session = 3;
     */
    Session = 3,
    /**
     * @generated from protobuf enum value: Duration = 4;
     */
    Duration = 4,
    /**
     * @generated from protobuf enum value: Browser = 5;
     */
    Browser = 5,
    /**
     * @generated from protobuf enum value: BrowserVersion = 6;
     */
    BrowserVersion = 6,
    /**
     * @generated from protobuf enum value: City = 7;
     */
    City = 7,
    /**
     * @generated from protobuf enum value: Country = 8;
     */
    Country = 8,
    /**
     * @generated from protobuf enum value: Domain = 9;
     */
    Domain = 9,
    /**
     * @generated from protobuf enum value: EntryPage = 10;
     */
    EntryPage = 10,
    /**
     * @generated from protobuf enum value: ExitPage = 11;
     */
    ExitPage = 11,
    /**
     * @generated from protobuf enum value: Host = 12;
     */
    Host = 12,
    /**
     * @generated from protobuf enum value: Event = 13;
     */
    Event = 13,
    /**
     * @generated from protobuf enum value: Os = 14;
     */
    Os = 14,
    /**
     * @generated from protobuf enum value: OsVersion = 15;
     */
    OsVersion = 15,
    /**
     * @generated from protobuf enum value: Path = 16;
     */
    Path = 16,
    /**
     * @generated from protobuf enum value: Referrer = 17;
     */
    Referrer = 17,
    /**
     * @generated from protobuf enum value: ReferrerSource = 18;
     */
    ReferrerSource = 18,
    /**
     * @generated from protobuf enum value: Region = 19;
     */
    Region = 19,
    /**
     * @generated from protobuf enum value: Screen = 20;
     */
    Screen = 20,
    /**
     * @generated from protobuf enum value: UtmCampaign = 21;
     */
    UtmCampaign = 21,
    /**
     * @generated from protobuf enum value: UtmContent = 22;
     */
    UtmContent = 22,
    /**
     * @generated from protobuf enum value: UtmMedium = 23;
     */
    UtmMedium = 23,
    /**
     * @generated from protobuf enum value: UtmSource = 24;
     */
    UtmSource = 24,
    /**
     * @generated from protobuf enum value: UtmTerm = 25;
     */
    UtmTerm = 25
}
/**
 * @generated from protobuf message v1.Filter
 */
export interface Filter {
    /**
     * @generated from protobuf field: v1.Filter.Column column = 1;
     */
    column: Filter_Column;
    /**
     * @generated from protobuf field: v1.Filter.Op op = 2;
     */
    op: Filter_Op;
    /**
     * @generated from protobuf field: string value = 3;
     */
    value: string;
}
/**
 * @generated from protobuf enum v1.Filter.Op
 */
export enum Filter_Op {
    /**
     * @generated from protobuf enum value: equal = 0;
     */
    equal = 0,
    /**
     * @generated from protobuf enum value: not_equal = 2;
     */
    not_equal = 2,
    /**
     * @generated from protobuf enum value: re_equal = 3;
     */
    re_equal = 3,
    /**
     * @generated from protobuf enum value: re_not_equal = 4;
     */
    re_not_equal = 4
}
/**
 * @generated from protobuf enum v1.Filter.Column
 */
export enum Filter_Column {
    /**
     * @generated from protobuf enum value: Browser = 0;
     */
    Browser = 0,
    /**
     * @generated from protobuf enum value: BrowserVersion = 6;
     */
    BrowserVersion = 6,
    /**
     * @generated from protobuf enum value: City = 7;
     */
    City = 7,
    /**
     * @generated from protobuf enum value: Country = 8;
     */
    Country = 8,
    /**
     * @generated from protobuf enum value: Domain = 9;
     */
    Domain = 9,
    /**
     * @generated from protobuf enum value: EntryPage = 10;
     */
    EntryPage = 10,
    /**
     * @generated from protobuf enum value: ExitPage = 11;
     */
    ExitPage = 11,
    /**
     * @generated from protobuf enum value: Host = 12;
     */
    Host = 12,
    /**
     * @generated from protobuf enum value: Event = 13;
     */
    Event = 13,
    /**
     * @generated from protobuf enum value: Os = 14;
     */
    Os = 14,
    /**
     * @generated from protobuf enum value: OsVersion = 15;
     */
    OsVersion = 15,
    /**
     * @generated from protobuf enum value: Path = 16;
     */
    Path = 16,
    /**
     * @generated from protobuf enum value: Referrer = 17;
     */
    Referrer = 17,
    /**
     * @generated from protobuf enum value: ReferrerSource = 18;
     */
    ReferrerSource = 18,
    /**
     * @generated from protobuf enum value: Region = 19;
     */
    Region = 19,
    /**
     * @generated from protobuf enum value: Screen = 20;
     */
    Screen = 20,
    /**
     * @generated from protobuf enum value: UtmCampaign = 21;
     */
    UtmCampaign = 21,
    /**
     * @generated from protobuf enum value: UtmContent = 22;
     */
    UtmContent = 22,
    /**
     * @generated from protobuf enum value: UtmMedium = 23;
     */
    UtmMedium = 23,
    /**
     * @generated from protobuf enum value: UtmSource = 24;
     */
    UtmSource = 24,
    /**
     * @generated from protobuf enum value: UtmTerm = 25;
     */
    UtmTerm = 25
}
/**
 * @generated from protobuf message v1.Event
 */
export interface Event {
    /**
     * / EventName
     *
     * @generated from protobuf field: string n = 1;
     */
    n: string;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
    /**
     * Domain
     *
     * @generated from protobuf field: string d = 3;
     */
    d: string;
    /**
     * Screen width
     *
     * @generated from protobuf field: int32 w = 4;
     */
    w: number;
    /**
     * Hash mode
     *
     * @generated from protobuf field: bool h = 5;
     */
    h: boolean;
    /**
     * @generated from protobuf field: string ip = 6;
     */
    ip: string;
    /**
     * user agent
     *
     * @generated from protobuf field: string ua = 7;
     */
    ua: string;
    /**
     * Referrer
     *
     * @generated from protobuf field: string r = 8;
     */
    r: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 9;
     */
    timestamp?: Timestamp;
}
/**
 * @generated from protobuf enum v1.Metric
 */
export enum Metric {
    /**
     * @generated from protobuf enum value: pageviews = 0;
     */
    pageviews = 0,
    /**
     * @generated from protobuf enum value: visitors = 1;
     */
    visitors = 1,
    /**
     * @generated from protobuf enum value: visits = 2;
     */
    visits = 2,
    /**
     * @generated from protobuf enum value: bounce_rate = 3;
     */
    bounce_rate = 3,
    /**
     * @generated from protobuf enum value: visit_duration = 4;
     */
    visit_duration = 4
}
/**
 * @generated from protobuf enum v1.Interval
 */
export enum Interval {
    /**
     * @generated from protobuf enum value: Day = 0;
     */
    Day = 0,
    /**
     * @generated from protobuf enum value: Week = 2;
     */
    Week = 2,
    /**
     * @generated from protobuf enum value: Month = 3;
     */
    Month = 3,
    /**
     * @generated from protobuf enum value: Year = 4;
     */
    Year = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class ScanRequest$Type extends MessageType<ScanRequest> {
    constructor() {
        super("v1.ScanRequest", [
            { no: 1, name: "timestamp", kind: "message", T: () => TimeRange, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "filters", kind: "message", T: () => Filters, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<ScanRequest>): ScanRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScanRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanRequest): ScanRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.TimeRange timestamp */ 1:
                    message.timestamp = TimeRange.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* v1.Filters filters */ 2:
                    message.filters = Filters.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.TimeRange timestamp = 1; */
        if (message.timestamp)
            TimeRange.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Filters filters = 2; */
        if (message.filters)
            Filters.internalBinaryWrite(message.filters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.ScanRequest
 */
export const ScanRequest = new ScanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanResponse$Type extends MessageType<ScanResponse> {
    constructor() {
        super("v1.ScanResponse", [
            { no: 1, name: "record", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ScanResponse>): ScanResponse {
        const message = { record: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanResponse): ScanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes record */ 1:
                    message.record = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes record = 1; */
        if (message.record.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.record);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.ScanResponse
 */
export const ScanResponse = new ScanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeRange$Type extends MessageType<TimeRange> {
    constructor() {
        super("v1.TimeRange", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "end", kind: "message", T: () => Timestamp, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<TimeRange>): TimeRange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeRange): TimeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.TimeRange
 */
export const TimeRange = new TimeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyValue$Type extends MessageType<KeyValue> {
    constructor() {
        super("v1.KeyValue", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeyValue>): KeyValue {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyValue): KeyValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.KeyValue
 */
export const KeyValue = new KeyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filters$Type extends MessageType<Filters> {
    constructor() {
        super("v1.Filters", [
            { no: 1, name: "list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Filter },
            { no: 2, name: "projection", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["v1.Filters.Projection", Filters_Projection] }
        ]);
    }
    create(value?: PartialMessage<Filters>): Filters {
        const message = { list: [], projection: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Filters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filters): Filters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated v1.Filter list */ 1:
                    message.list.push(Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated v1.Filters.Projection projection */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.projection.push(reader.int32());
                    else
                        message.projection.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated v1.Filter list = 1; */
        for (let i = 0; i < message.list.length; i++)
            Filter.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated v1.Filters.Projection projection = 2; */
        if (message.projection.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.projection.length; i++)
                writer.int32(message.projection[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Filters
 */
export const Filters = new Filters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter$Type extends MessageType<Filter> {
    constructor() {
        super("v1.Filter", [
            { no: 1, name: "column", kind: "enum", T: () => ["v1.Filter.Column", Filter_Column] },
            { no: 2, name: "op", kind: "enum", T: () => ["v1.Filter.Op", Filter_Op] },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Filter>): Filter {
        const message = { column: 0, op: 0, value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter): Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Filter.Column column */ 1:
                    message.column = reader.int32();
                    break;
                case /* v1.Filter.Op op */ 2:
                    message.op = reader.int32();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Filter.Column column = 1; */
        if (message.column !== 0)
            writer.tag(1, WireType.Varint).int32(message.column);
        /* v1.Filter.Op op = 2; */
        if (message.op !== 0)
            writer.tag(2, WireType.Varint).int32(message.op);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Filter
 */
export const Filter = new Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("v1.Event", [
            { no: 1, name: "n", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { uri: true } } } },
            { no: 3, name: "d", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true, string: { hostname: true } } } },
            { no: 4, name: "w", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "h", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { ip: true } } } },
            { no: 7, name: "ua", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "r", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = { n: "", url: "", d: "", w: 0, h: false, ip: "", ua: "", r: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string n */ 1:
                    message.n = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string d */ 3:
                    message.d = reader.string();
                    break;
                case /* int32 w */ 4:
                    message.w = reader.int32();
                    break;
                case /* bool h */ 5:
                    message.h = reader.bool();
                    break;
                case /* string ip */ 6:
                    message.ip = reader.string();
                    break;
                case /* string ua */ 7:
                    message.ua = reader.string();
                    break;
                case /* string r */ 8:
                    message.r = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 9:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string n = 1; */
        if (message.n !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.n);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string d = 3; */
        if (message.d !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.d);
        /* int32 w = 4; */
        if (message.w !== 0)
            writer.tag(4, WireType.Varint).int32(message.w);
        /* bool h = 5; */
        if (message.h !== false)
            writer.tag(5, WireType.Varint).bool(message.h);
        /* string ip = 6; */
        if (message.ip !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.ip);
        /* string ua = 7; */
        if (message.ua !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ua);
        /* string r = 8; */
        if (message.r !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.r);
        /* google.protobuf.Timestamp timestamp = 9; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Event
 */
export const Event = new Event$Type();
