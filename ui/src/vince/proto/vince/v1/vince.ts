// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "vince/v1/vince.proto" (package "v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Duration } from "../../google/protobuf/duration";
import { StoreKey } from "../store/v1/store";
/**
 * @generated from protobuf message v1.Site
 */
export interface Site {
    /**
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
}
/**
 * @generated from protobuf message v1.Site.Key
 */
export interface Site_Key {
    /**
     * @generated from protobuf field: v1.StoreKey store = 1;
     */
    store?: StoreKey;
    /**
     * @generated from protobuf field: string domain = 2;
     */
    domain: string;
}
/**
 * @generated from protobuf message v1.Site.Create
 */
export interface Site_Create {
}
/**
 * @generated from protobuf message v1.Site.Create.Request
 */
export interface Site_Create_Request {
    /**
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
}
/**
 * @generated from protobuf message v1.Site.Create.Response
 */
export interface Site_Create_Response {
    /**
     * @generated from protobuf field: v1.Site site = 1;
     */
    site?: Site;
}
/**
 * @generated from protobuf message v1.Site.Get
 */
export interface Site_Get {
}
/**
 * @generated from protobuf message v1.Site.Get.Request
 */
export interface Site_Get_Request {
}
/**
 * @generated from protobuf message v1.Site.Get.Response
 */
export interface Site_Get_Response {
    /**
     * @generated from protobuf field: v1.Site site = 1;
     */
    site?: Site;
}
/**
 * @generated from protobuf message v1.Site.List
 */
export interface Site_List {
}
/**
 * @generated from protobuf message v1.Site.List.Request
 */
export interface Site_List_Request {
}
/**
 * @generated from protobuf message v1.Site.List.Response
 */
export interface Site_List_Response {
    /**
     * @generated from protobuf field: repeated v1.Site list = 1;
     */
    list: Site[];
}
/**
 * @generated from protobuf message v1.Site.Delete
 */
export interface Site_Delete {
}
/**
 * @generated from protobuf message v1.Site.Delete.Request
 */
export interface Site_Delete_Request {
    /**
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
}
/**
 * @generated from protobuf message v1.Site.Delete.Response
 */
export interface Site_Delete_Response {
}
/**
 * @generated from protobuf message v1.Status
 */
export interface Status {
}
/**
 * @generated from protobuf message v1.Build
 */
export interface Build {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
/**
 * Configuration object for vince instance
 *
 * @generated from protobuf message v1.Config
 */
export interface Config {
    /**
     * Path to the main badger database.
     *
     * @generated from protobuf field: string db_path = 1;
     */
    dbPath: string;
    /**
     * Path to where block files are stored. Blocks are stored as files with ULID
     * as filenames
     *
     * @generated from protobuf field: string blocks_path = 2;
     */
    blocksPath: string;
    /**
     * host:port to bind for http api. This is used by serve command. The server
     * serves ui console
     *
     * @generated from protobuf field: string listen_address = 3;
     */
    listenAddress: string;
    /**
     * Control how much is logged options are
     * trace,debug,info,warn,error,fatal,panic
     *
     * @generated from protobuf field: string log_level = 4;
     */
    logLevel: string;
    /**
     * Interval for syncing buffered entries. By default events are buffered and
     * periodically saved.
     *
     * @generated from protobuf field: google.protobuf.Duration sync_interval = 5;
     */
    syncInterval?: Duration;
    /**
     * Expose /debug/pprof endpoint when serving
     *
     * @generated from protobuf field: bool enable_profile = 6;
     */
    enableProfile: boolean;
    /**
     * host:port to bind myslq server. Serves web analytics via MySQL compliant
     * wire protocol.
     *
     * @generated from protobuf field: string mysql_listen_address = 7;
     */
    mysqlListenAddress: string;
    /**
     * @generated from protobuf field: string tls_cert_file = 8;
     */
    tlsCertFile: string;
    /**
     * @generated from protobuf field: string tls_key_file = 9;
     */
    tlsKeyFile: string;
    /**
     * @generated from protobuf field: int64 events_buffer_size = 10;
     */
    eventsBufferSize: bigint;
    /**
     * @generated from protobuf field: repeated v1.Config.Notifier notifiers = 11;
     */
    notifiers: Config_Notifier[];
    /**
     * @generated from protobuf field: string server_id = 12;
     */
    serverId: string;
    /**
     * @generated from protobuf field: string raft_path = 13;
     */
    raftPath: string;
}
/**
 * @generated from protobuf message v1.Config.Notifier
 */
export interface Config_Notifier {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "email";
        /**
         * @generated from protobuf field: v1.Config.Email email = 2;
         */
        email: Config_Email;
    } | {
        oneofKind: "webhook";
        /**
         * @generated from protobuf field: v1.Config.Webhook webhook = 3;
         */
        webhook: Config_Webhook;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.Config.Email
 */
export interface Config_Email {
    /**
     * @generated from protobuf field: string to = 1;
     */
    to: string;
    /**
     * @generated from protobuf field: string from = 2;
     */
    from: string;
    /**
     * @generated from protobuf field: string hello = 3;
     */
    hello: string;
    /**
     * @generated from protobuf field: string host_port = 4;
     */
    hostPort: string;
    /**
     * @generated from protobuf field: string auth_username = 5;
     */
    authUsername: string;
    /**
     * @generated from protobuf field: string auth_password = 6;
     */
    authPassword: string;
    /**
     * @generated from protobuf field: string auth_secret = 7;
     */
    authSecret: string;
    /**
     * @generated from protobuf field: string auth_identity = 8;
     */
    authIdentity: string;
    /**
     * @generated from protobuf field: map<string, string> headers = 9;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string html = 10;
     */
    html: string;
    /**
     * @generated from protobuf field: string text = 11;
     */
    text: string;
    /**
     * @generated from protobuf field: bool require_tls = 12;
     */
    requireTls: boolean;
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 13;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.Webhook
 */
export interface Config_Webhook {
    /**
     * @generated from protobuf field: v1.Config.HTTP http_config = 1;
     */
    httpConfig?: Config_HTTP;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP
 */
export interface Config_HTTP {
    /**
     * @generated from protobuf field: v1.Config.HTTP.BasicAuth basic_auth = 1;
     */
    basicAuth?: Config_HTTP_BasicAuth;
    /**
     * @generated from protobuf field: v1.Config.HTTP.Authorization authorization = 2;
     */
    authorization?: Config_HTTP_Authorization;
    /**
     * @generated from protobuf field: v1.Config.HTTP.OAuth2 pauth2 = 3;
     */
    pauth2?: Config_HTTP_OAuth2;
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 4;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.HTTP.BasicAuth
 */
export interface Config_HTTP_BasicAuth {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP.Authorization
 */
export interface Config_HTTP_Authorization {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string credentials = 2;
     */
    credentials: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP.OAuth2
 */
export interface Config_HTTP_OAuth2 {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string client_secret = 2;
     */
    clientSecret: string;
    /**
     * @generated from protobuf field: repeated string client_scopes = 3;
     */
    clientScopes: string[];
    /**
     * @generated from protobuf field: string token_url = 4;
     */
    tokenUrl: string;
    /**
     * @generated from protobuf field: map<string, string> endpoint_params = 5;
     */
    endpointParams: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 6;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.HTTP.TLSConfig
 */
export interface Config_HTTP_TLSConfig {
    /**
     * @generated from protobuf field: string key_file = 1;
     */
    keyFile: string;
    /**
     * @generated from protobuf field: string cert_file = 2;
     */
    certFile: string;
    /**
     * @generated from protobuf field: bool insecure_skip_verify = 3;
     */
    insecureSkipVerify: boolean;
}
/**
 * @generated from protobuf message v1.Account
 */
export interface Account {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes hashed_password = 2;
     */
    hashedPassword: Uint8Array;
}
/**
 * @generated from protobuf message v1.Account.Key
 */
export interface Account_Key {
    /**
     * @generated from protobuf field: v1.StoreKey store = 1;
     */
    store?: StoreKey;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message v1.Client
 */
export interface Client {
    /**
     * @generated from protobuf field: bytes private_key = 1;
     */
    privateKey: Uint8Array;
    /**
     * Authentication details of vince instances
     *
     * @generated from protobuf field: map<string, v1.Client.Instance> instance = 2;
     */
    instance: {
        [key: string]: Client_Instance;
    };
    /**
     * Map of server_id to instance
     *
     * @generated from protobuf field: map<string, string> server_id = 3;
     */
    serverId: {
        [key: string]: string;
    };
    /**
     * The default auth name to use.
     *
     * @generated from protobuf field: v1.Client.Active active = 4;
     */
    active?: Client_Active;
    /**
     * @generated from protobuf field: map<string, v1.Cluster.Config> clusters = 5;
     */
    clusters: {
        [key: string]: Cluster_Config;
    };
}
/**
 * @generated from protobuf message v1.Client.Instance
 */
export interface Client_Instance {
    /**
     * @generated from protobuf field: map<string, v1.Client.Auth> accounts = 1;
     */
    accounts: {
        [key: string]: Client_Auth;
    };
}
/**
 * @generated from protobuf message v1.Client.Active
 */
export interface Client_Active {
    /**
     * @generated from protobuf field: string instance = 1;
     */
    instance: string;
    /**
     * @generated from protobuf field: string account = 2;
     */
    account: string;
}
/**
 * @generated from protobuf message v1.Client.Auth
 */
export interface Client_Auth {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string token = 2;
     */
    token: string;
    /**
     * @generated from protobuf field: string server_id = 3;
     */
    serverId: string;
}
/**
 * @generated from protobuf message v1.Token
 */
export interface Token {
    /**
     * @generated from protobuf field: bytes pub_key = 1;
     */
    pubKey: Uint8Array;
}
/**
 * @generated from protobuf message v1.Token.Create
 */
export interface Token_Create {
}
/**
 * @generated from protobuf message v1.Token.Create.Request
 */
export interface Token_Create_Request {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
    /**
     * @generated from protobuf field: string token = 3;
     */
    token: string;
    /**
     * @generated from protobuf field: bytes public_key = 4;
     */
    publicKey: Uint8Array;
    /**
     * When true, the token will be generated by the server.
     *
     * @generated from protobuf field: bool generate = 5;
     */
    generate: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Duration ttl = 6;
     */
    ttl?: Duration;
}
/**
 * @generated from protobuf message v1.Token.Create.Response
 */
export interface Token_Create_Response {
    /**
     * @generated from protobuf field: v1.Client.Auth auth = 1;
     */
    auth?: Client_Auth;
}
/**
 * @generated from protobuf message v1.Token.Key
 */
export interface Token_Key {
    /**
     * @generated from protobuf field: v1.StoreKey store = 1;
     */
    store?: StoreKey;
    /**
     * @generated from protobuf field: int64 hash = 2;
     */
    hash: bigint;
}
/**
 * @generated from protobuf enum v1.Token.Issuer
 */
export enum Token_Issuer {
    /**
     * @generated from protobuf enum value: SERVER = 0;
     */
    SERVER = 0,
    /**
     * @generated from protobuf enum value: CLIENT = 1;
     */
    CLIENT = 1
}
/**
 * @generated from protobuf message v1.Error
 */
export interface Error {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message v1.Query
 */
export interface Query {
}
/**
 * @generated from protobuf message v1.Query.Value
 */
export interface Query_Value {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "number";
        /**
         * @generated from protobuf field: int64 number = 1;
         */
        number: bigint;
    } | {
        oneofKind: "double";
        /**
         * @generated from protobuf field: double double = 2;
         */
        double: number;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 3;
         */
        string: string;
    } | {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: bool bool = 4;
         */
        bool: boolean;
    } | {
        oneofKind: "timestamp";
        /**
         * @generated from protobuf field: google.protobuf.Timestamp timestamp = 5;
         */
        timestamp: Timestamp;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.Query.Request
 */
export interface Query_Request {
    /**
     * @generated from protobuf field: string query = 1;
     */
    query: string;
    /**
     * @generated from protobuf field: repeated v1.Query.Param params = 2;
     */
    params: Query_Param[];
}
/**
 * @generated from protobuf message v1.Query.Response
 */
export interface Query_Response {
    /**
     * @generated from protobuf field: google.protobuf.Duration elapsed = 1;
     */
    elapsed?: Duration;
    /**
     * @generated from protobuf field: repeated v1.Query.Colum columns = 2;
     */
    columns: Query_Colum[];
    /**
     * @generated from protobuf field: repeated v1.Query.Row rows = 3;
     */
    rows: Query_Row[];
}
/**
 * @generated from protobuf message v1.Query.Param
 */
export interface Query_Param {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: v1.Query.Value value = 2;
     */
    value?: Query_Value;
}
/**
 * @generated from protobuf message v1.Query.Colum
 */
export interface Query_Colum {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: v1.Query.Colum.DataType data_type = 2;
     */
    dataType: Query_Colum_DataType;
}
/**
 * @generated from protobuf enum v1.Query.Colum.DataType
 */
export enum Query_Colum_DataType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: NUMBER = 1;
     */
    NUMBER = 1,
    /**
     * @generated from protobuf enum value: DOUBLE = 2;
     */
    DOUBLE = 2,
    /**
     * @generated from protobuf enum value: STRING = 3;
     */
    STRING = 3,
    /**
     * @generated from protobuf enum value: BOOL = 4;
     */
    BOOL = 4,
    /**
     * @generated from protobuf enum value: TIMESTAMP = 5;
     */
    TIMESTAMP = 5
}
/**
 * @generated from protobuf message v1.Query.Row
 */
export interface Query_Row {
    /**
     * @generated from protobuf field: repeated v1.Query.Value values = 1;
     */
    values: Query_Value[];
}
/**
 * @generated from protobuf message v1.Notice
 */
export interface Notice {
}
/**
 * @generated from protobuf message v1.Raft
 */
export interface Raft {
}
/**
 * @generated from protobuf message v1.Raft.Entry
 */
export interface Raft_Entry {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Duration expires = 3;
     */
    expires?: Duration;
}
/**
 * @generated from protobuf message v1.Raft.Log
 */
export interface Raft_Log {
    /**
     * @generated from protobuf field: uint64 index = 1;
     */
    index: bigint;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: v1.Raft.Log.Type type = 3;
     */
    type: Raft_Log_Type;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes extensions = 5;
     */
    extensions: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp appended_at = 6;
     */
    appendedAt?: Timestamp;
}
/**
 * @generated from protobuf enum v1.Raft.Log.Type
 */
export enum Raft_Log_Type {
    /**
     * @generated from protobuf enum value: Command = 0;
     */
    Command = 0,
    /**
     * @generated from protobuf enum value: Noop = 1;
     */
    Noop = 1,
    /**
     * @generated from protobuf enum value: AddPeerDeprecated = 2;
     */
    AddPeerDeprecated = 2,
    /**
     * @generated from protobuf enum value: RemovePeerDeprecated = 3;
     */
    RemovePeerDeprecated = 3,
    /**
     * @generated from protobuf enum value: Barrier = 4;
     */
    Barrier = 4,
    /**
     * @generated from protobuf enum value: Configuration = 5;
     */
    Configuration = 5
}
/**
 * @generated from protobuf message v1.Raft.Config
 */
export interface Raft_Config {
    /**
     * @generated from protobuf field: repeated v1.Raft.Config.Server servers = 1;
     */
    servers: Raft_Config_Server[];
}
/**
 * @generated from protobuf message v1.Raft.Config.Server
 */
export interface Raft_Config_Server {
    /**
     * @generated from protobuf field: v1.Raft.Config.Server.Suffrage suffrage = 1;
     */
    suffrage: Raft_Config_Server_Suffrage;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * @generated from protobuf field: string token = 4;
     */
    token: string;
}
/**
 * @generated from protobuf enum v1.Raft.Config.Server.Suffrage
 */
export enum Raft_Config_Server_Suffrage {
    /**
     * @generated from protobuf enum value: Voter = 0;
     */
    Voter = 0,
    /**
     * @generated from protobuf enum value: Nonvoter = 1;
     */
    Nonvoter = 1,
    /**
     * @generated from protobuf enum value: Staging = 2;
     */
    Staging = 2
}
/**
 * @generated from protobuf message v1.Raft.RPC
 */
export interface Raft_RPC {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Call
 */
export interface Raft_RPC_Call {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Call.Request
 */
export interface Raft_RPC_Call_Request {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "appendEntries";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.AppendEntries.Request append_entries = 1;
         */
        appendEntries: Raft_RPC_Command_AppendEntries_Request;
    } | {
        oneofKind: "vote";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.Vote.Request vote = 2;
         */
        vote: Raft_RPC_Command_Vote_Request;
    } | {
        oneofKind: "installSnapshot";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.InstallSnapshot.Request install_snapshot = 3;
         */
        installSnapshot: Raft_RPC_Command_InstallSnapshot_Request;
    } | {
        oneofKind: "timeoutNow";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.TimeoutNow.Request timeout_now = 4;
         */
        timeoutNow: Raft_RPC_Command_TimeoutNow_Request;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.Raft.RPC.Call.Response
 */
export interface Raft_RPC_Call_Response {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "appendEntries";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.AppendEntries.Response append_entries = 1;
         */
        appendEntries: Raft_RPC_Command_AppendEntries_Response;
    } | {
        oneofKind: "vote";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.Vote.Response vote = 2;
         */
        vote: Raft_RPC_Command_Vote_Response;
    } | {
        oneofKind: "installSnapshot";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.InstallSnapshot.Response install_snapshot = 3;
         */
        installSnapshot: Raft_RPC_Command_InstallSnapshot_Response;
    } | {
        oneofKind: "timeoutNow";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.TimeoutNow.Response timeout_now = 4;
         */
        timeoutNow: Raft_RPC_Command_TimeoutNow_Response;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string error = 5;
     */
    error: string;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command
 */
export interface Raft_RPC_Command {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.AppendEntries
 */
export interface Raft_RPC_Command_AppendEntries {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.AppendEntries.Request
 */
export interface Raft_RPC_Command_AppendEntries_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 prev_log_entry = 4;
     */
    prevLogEntry: bigint;
    /**
     * @generated from protobuf field: uint64 prev_log_term = 5;
     */
    prevLogTerm: bigint;
    /**
     * @generated from protobuf field: repeated v1.Raft.Log entries = 6;
     */
    entries: Raft_Log[];
    /**
     * @generated from protobuf field: uint64 leader_commit_index = 7;
     */
    leaderCommitIndex: bigint;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.AppendEntries.Response
 */
export interface Raft_RPC_Command_AppendEntries_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 last_log = 3;
     */
    lastLog: bigint;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
    /**
     * @generated from protobuf field: bool no_retry_backoff = 5;
     */
    noRetryBackoff: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Vote
 */
export interface Raft_RPC_Command_Vote {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Vote.Request
 */
export interface Raft_RPC_Command_Vote_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_index = 3;
     */
    lastLogIndex: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_term = 4;
     */
    lastLogTerm: bigint;
    /**
     * @generated from protobuf field: bool leadership_transfer = 5;
     */
    leadershipTransfer: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Vote.Response
 */
export interface Raft_RPC_Command_Vote_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bool granted = 3;
     */
    granted: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.InstallSnapshot
 */
export interface Raft_RPC_Command_InstallSnapshot {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.InstallSnapshot.Request
 */
export interface Raft_RPC_Command_InstallSnapshot_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.InstallSnapshot.Request.Version snapshot_version = 2;
     */
    snapshotVersion: Raft_RPC_Command_InstallSnapshot_Request_Version;
    /**
     * @generated from protobuf field: uint64 term = 3;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bytes leader = 4;
     */
    leader: Uint8Array;
    /**
     * @generated from protobuf field: uint64 last_log_index = 5;
     */
    lastLogIndex: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_term = 6;
     */
    lastLogTerm: bigint;
    /**
     * @generated from protobuf field: bytes configuration = 7;
     */
    configuration: Uint8Array;
    /**
     * @generated from protobuf field: uint64 configuration_index = 8;
     */
    configurationIndex: bigint;
    /**
     * @generated from protobuf field: int64 size = 9;
     */
    size: bigint;
}
/**
 * @generated from protobuf enum v1.Raft.RPC.Command.InstallSnapshot.Request.Version
 */
export enum Raft_RPC_Command_InstallSnapshot_Request_Version {
    /**
     * @generated from protobuf enum value: Min = 0;
     */
    Min = 0,
    /**
     * @generated from protobuf enum value: Max = 1;
     */
    Max = 1
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.InstallSnapshot.Response
 */
export interface Raft_RPC_Command_InstallSnapshot_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bool success = 3;
     */
    success: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.TimeoutNow
 */
export interface Raft_RPC_Command_TimeoutNow {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.TimeoutNow.Request
 */
export interface Raft_RPC_Command_TimeoutNow_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.TimeoutNow.Response
 */
export interface Raft_RPC_Command_TimeoutNow_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Header
 */
export interface Raft_RPC_Command_Header {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header.Version version = 1;
     */
    version: Raft_RPC_Command_Header_Version;
    /**
     * @generated from protobuf field: bytes id = 2;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: bytes addr = 3;
     */
    addr: Uint8Array;
}
/**
 * @generated from protobuf enum v1.Raft.RPC.Command.Header.Version
 */
export enum Raft_RPC_Command_Header_Version {
    /**
     * @generated from protobuf enum value: Min = 0;
     */
    Min = 0,
    /**
     * @generated from protobuf enum value: Max = 1;
     */
    Max = 1
}
/**
 * @generated from protobuf message v1.Cluster
 */
export interface Cluster {
}
/**
 * @generated from protobuf message v1.Cluster.Apply
 */
export interface Cluster_Apply {
}
/**
 * @generated from protobuf message v1.Cluster.Apply.Request
 */
export interface Cluster_Apply_Request {
    /**
     * @generated from protobuf field: v1.Cluster.Config config = 1;
     */
    config?: Cluster_Config;
}
/**
 * @generated from protobuf message v1.Cluster.Apply.Response
 */
export interface Cluster_Apply_Response {
    /**
     * @generated from protobuf field: string ok = 1;
     */
    ok: string;
}
/**
 * @generated from protobuf message v1.Cluster.Get
 */
export interface Cluster_Get {
}
/**
 * @generated from protobuf message v1.Cluster.Get.Request
 */
export interface Cluster_Get_Request {
}
/**
 * @generated from protobuf message v1.Cluster.Get.Response
 */
export interface Cluster_Get_Response {
    /**
     * @generated from protobuf field: v1.Cluster.Config config = 1;
     */
    config?: Cluster_Config;
}
/**
 * @generated from protobuf message v1.Cluster.Config
 */
export interface Cluster_Config {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: map<string, v1.Cluster.Config.Node> nodes = 2;
     */
    nodes: {
        [key: string]: Cluster_Config_Node;
    };
}
/**
 * @generated from protobuf message v1.Cluster.Config.Node
 */
export interface Cluster_Config_Node {
    /**
     * @generated from protobuf field: v1.Client.Auth account = 1;
     */
    account?: Client_Auth;
    /**
     * True if this node is used to bootstrap the cluster.
     *
     * @generated from protobuf field: bool bootstrap = 2;
     */
    bootstrap: boolean;
    /**
     * @generated from protobuf field: string address = 3;
     */
    address: string;
}
/**
 * Parquet fields used to store events. There are only two phisical data types
 * int64 and string.
 *
 * The columns are grouped by data types for easy access
 *
 * @generated from protobuf enum v1.Column
 */
export enum Column {
    /**
     * @generated from protobuf enum value: bounce = 0;
     */
    bounce = 0,
    /**
     * @generated from protobuf enum value: duration = 1;
     */
    duration = 1,
    /**
     * @generated from protobuf enum value: id = 2;
     */
    id = 2,
    /**
     * @generated from protobuf enum value: session = 3;
     */
    session = 3,
    /**
     * @generated from protobuf enum value: timestamp = 4;
     */
    timestamp = 4,
    /**
     * @generated from protobuf enum value: browser = 5;
     */
    browser = 5,
    /**
     * @generated from protobuf enum value: browser_version = 6;
     */
    browser_version = 6,
    /**
     * @generated from protobuf enum value: city = 7;
     */
    city = 7,
    /**
     * @generated from protobuf enum value: country = 8;
     */
    country = 8,
    /**
     * @generated from protobuf enum value: entry_page = 9;
     */
    entry_page = 9,
    /**
     * @generated from protobuf enum value: event = 10;
     */
    event = 10,
    /**
     * @generated from protobuf enum value: exit_page = 11;
     */
    exit_page = 11,
    /**
     * @generated from protobuf enum value: host = 12;
     */
    host = 12,
    /**
     * @generated from protobuf enum value: os = 13;
     */
    os = 13,
    /**
     * @generated from protobuf enum value: os_version = 14;
     */
    os_version = 14,
    /**
     * @generated from protobuf enum value: path = 15;
     */
    path = 15,
    /**
     * @generated from protobuf enum value: referrer = 16;
     */
    referrer = 16,
    /**
     * @generated from protobuf enum value: referrer_source = 17;
     */
    referrer_source = 17,
    /**
     * @generated from protobuf enum value: region = 18;
     */
    region = 18,
    /**
     * @generated from protobuf enum value: screen = 19;
     */
    screen = 19,
    /**
     * @generated from protobuf enum value: utm_campaign = 20;
     */
    utm_campaign = 20,
    /**
     * @generated from protobuf enum value: utm_content = 21;
     */
    utm_content = 21,
    /**
     * @generated from protobuf enum value: utm_medium = 22;
     */
    utm_medium = 22,
    /**
     * @generated from protobuf enum value: utm_source = 23;
     */
    utm_source = 23,
    /**
     * @generated from protobuf enum value: utm_term = 24;
     */
    utm_term = 24
}
// @generated message type with reflection information, may provide speed optimized methods
class Site$Type extends MessageType<Site> {
    constructor() {
        super("v1.Site", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Site>): Site {
        const message = { domain: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site): Site {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site
 */
export const Site = new Site$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Key$Type extends MessageType<Site_Key> {
    constructor() {
        super("v1.Site.Key", [
            { no: 1, name: "store", kind: "message", T: () => StoreKey },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Site_Key>): Site_Key {
        const message = { domain: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Key>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Key): Site_Key {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.StoreKey store */ 1:
                    message.store = StoreKey.internalBinaryRead(reader, reader.uint32(), options, message.store);
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site_Key, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.StoreKey store = 1; */
        if (message.store)
            StoreKey.internalBinaryWrite(message.store, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Key
 */
export const Site_Key = new Site_Key$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Create$Type extends MessageType<Site_Create> {
    constructor() {
        super("v1.Site.Create", []);
    }
    create(value?: PartialMessage<Site_Create>): Site_Create {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Create>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Create): Site_Create {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_Create, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Create
 */
export const Site_Create = new Site_Create$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Create_Request$Type extends MessageType<Site_Create_Request> {
    constructor() {
        super("v1.Site.Create.Request", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Site_Create_Request>): Site_Create_Request {
        const message = { domain: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Create_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Create_Request): Site_Create_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site_Create_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Create.Request
 */
export const Site_Create_Request = new Site_Create_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Create_Response$Type extends MessageType<Site_Create_Response> {
    constructor() {
        super("v1.Site.Create.Response", [
            { no: 1, name: "site", kind: "message", T: () => Site }
        ]);
    }
    create(value?: PartialMessage<Site_Create_Response>): Site_Create_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Create_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Create_Response): Site_Create_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Site site */ 1:
                    message.site = Site.internalBinaryRead(reader, reader.uint32(), options, message.site);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site_Create_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Site site = 1; */
        if (message.site)
            Site.internalBinaryWrite(message.site, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Create.Response
 */
export const Site_Create_Response = new Site_Create_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Get$Type extends MessageType<Site_Get> {
    constructor() {
        super("v1.Site.Get", []);
    }
    create(value?: PartialMessage<Site_Get>): Site_Get {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Get>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Get): Site_Get {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_Get, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Get
 */
export const Site_Get = new Site_Get$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Get_Request$Type extends MessageType<Site_Get_Request> {
    constructor() {
        super("v1.Site.Get.Request", []);
    }
    create(value?: PartialMessage<Site_Get_Request>): Site_Get_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Get_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Get_Request): Site_Get_Request {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_Get_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Get.Request
 */
export const Site_Get_Request = new Site_Get_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Get_Response$Type extends MessageType<Site_Get_Response> {
    constructor() {
        super("v1.Site.Get.Response", [
            { no: 1, name: "site", kind: "message", T: () => Site }
        ]);
    }
    create(value?: PartialMessage<Site_Get_Response>): Site_Get_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Get_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Get_Response): Site_Get_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Site site */ 1:
                    message.site = Site.internalBinaryRead(reader, reader.uint32(), options, message.site);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site_Get_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Site site = 1; */
        if (message.site)
            Site.internalBinaryWrite(message.site, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Get.Response
 */
export const Site_Get_Response = new Site_Get_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_List$Type extends MessageType<Site_List> {
    constructor() {
        super("v1.Site.List", []);
    }
    create(value?: PartialMessage<Site_List>): Site_List {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_List): Site_List {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.List
 */
export const Site_List = new Site_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_List_Request$Type extends MessageType<Site_List_Request> {
    constructor() {
        super("v1.Site.List.Request", []);
    }
    create(value?: PartialMessage<Site_List_Request>): Site_List_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_List_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_List_Request): Site_List_Request {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_List_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.List.Request
 */
export const Site_List_Request = new Site_List_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_List_Response$Type extends MessageType<Site_List_Response> {
    constructor() {
        super("v1.Site.List.Response", [
            { no: 1, name: "list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Site }
        ]);
    }
    create(value?: PartialMessage<Site_List_Response>): Site_List_Response {
        const message = { list: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_List_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_List_Response): Site_List_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated v1.Site list */ 1:
                    message.list.push(Site.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site_List_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated v1.Site list = 1; */
        for (let i = 0; i < message.list.length; i++)
            Site.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.List.Response
 */
export const Site_List_Response = new Site_List_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Delete$Type extends MessageType<Site_Delete> {
    constructor() {
        super("v1.Site.Delete", []);
    }
    create(value?: PartialMessage<Site_Delete>): Site_Delete {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Delete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Delete): Site_Delete {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_Delete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Delete
 */
export const Site_Delete = new Site_Delete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Delete_Request$Type extends MessageType<Site_Delete_Request> {
    constructor() {
        super("v1.Site.Delete.Request", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Site_Delete_Request>): Site_Delete_Request {
        const message = { domain: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Delete_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Delete_Request): Site_Delete_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Site_Delete_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Delete.Request
 */
export const Site_Delete_Request = new Site_Delete_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Site_Delete_Response$Type extends MessageType<Site_Delete_Response> {
    constructor() {
        super("v1.Site.Delete.Response", []);
    }
    create(value?: PartialMessage<Site_Delete_Response>): Site_Delete_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Site_Delete_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Site_Delete_Response): Site_Delete_Response {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Site_Delete_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Site.Delete.Response
 */
export const Site_Delete_Response = new Site_Delete_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("v1.Status", []);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Build$Type extends MessageType<Build> {
    constructor() {
        super("v1.Build", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Build>): Build {
        const message = { version: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Build>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Build): Build {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Build, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Build
 */
export const Build = new Build$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("v1.Config", [
            { no: 1, name: "db_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocks_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "listen_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "log_level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "sync_interval", kind: "message", T: () => Duration },
            { no: 6, name: "enable_profile", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "mysql_listen_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tls_cert_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "tls_key_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "events_buffer_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "notifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Config_Notifier },
            { no: 12, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "raft_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config>): Config {
        const message = { dbPath: "", blocksPath: "", listenAddress: "", logLevel: "", enableProfile: false, mysqlListenAddress: "", tlsCertFile: "", tlsKeyFile: "", eventsBufferSize: 0n, notifiers: [], serverId: "", raftPath: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string db_path */ 1:
                    message.dbPath = reader.string();
                    break;
                case /* string blocks_path */ 2:
                    message.blocksPath = reader.string();
                    break;
                case /* string listen_address */ 3:
                    message.listenAddress = reader.string();
                    break;
                case /* string log_level */ 4:
                    message.logLevel = reader.string();
                    break;
                case /* google.protobuf.Duration sync_interval */ 5:
                    message.syncInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.syncInterval);
                    break;
                case /* bool enable_profile */ 6:
                    message.enableProfile = reader.bool();
                    break;
                case /* string mysql_listen_address */ 7:
                    message.mysqlListenAddress = reader.string();
                    break;
                case /* string tls_cert_file */ 8:
                    message.tlsCertFile = reader.string();
                    break;
                case /* string tls_key_file */ 9:
                    message.tlsKeyFile = reader.string();
                    break;
                case /* int64 events_buffer_size */ 10:
                    message.eventsBufferSize = reader.int64().toBigInt();
                    break;
                case /* repeated v1.Config.Notifier notifiers */ 11:
                    message.notifiers.push(Config_Notifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string server_id */ 12:
                    message.serverId = reader.string();
                    break;
                case /* string raft_path */ 13:
                    message.raftPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string db_path = 1; */
        if (message.dbPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dbPath);
        /* string blocks_path = 2; */
        if (message.blocksPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.blocksPath);
        /* string listen_address = 3; */
        if (message.listenAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.listenAddress);
        /* string log_level = 4; */
        if (message.logLevel !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.logLevel);
        /* google.protobuf.Duration sync_interval = 5; */
        if (message.syncInterval)
            Duration.internalBinaryWrite(message.syncInterval, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_profile = 6; */
        if (message.enableProfile !== false)
            writer.tag(6, WireType.Varint).bool(message.enableProfile);
        /* string mysql_listen_address = 7; */
        if (message.mysqlListenAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.mysqlListenAddress);
        /* string tls_cert_file = 8; */
        if (message.tlsCertFile !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tlsCertFile);
        /* string tls_key_file = 9; */
        if (message.tlsKeyFile !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.tlsKeyFile);
        /* int64 events_buffer_size = 10; */
        if (message.eventsBufferSize !== 0n)
            writer.tag(10, WireType.Varint).int64(message.eventsBufferSize);
        /* repeated v1.Config.Notifier notifiers = 11; */
        for (let i = 0; i < message.notifiers.length; i++)
            Config_Notifier.internalBinaryWrite(message.notifiers[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string server_id = 12; */
        if (message.serverId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.serverId);
        /* string raft_path = 13; */
        if (message.raftPath !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.raftPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config
 */
export const Config = new Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Notifier$Type extends MessageType<Config_Notifier> {
    constructor() {
        super("v1.Config.Notifier", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "message", oneof: "provider", T: () => Config_Email },
            { no: 3, name: "webhook", kind: "message", oneof: "provider", T: () => Config_Webhook }
        ]);
    }
    create(value?: PartialMessage<Config_Notifier>): Config_Notifier {
        const message = { name: "", provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Notifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Notifier): Config_Notifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* v1.Config.Email email */ 2:
                    message.provider = {
                        oneofKind: "email",
                        email: Config_Email.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).email)
                    };
                    break;
                case /* v1.Config.Webhook webhook */ 3:
                    message.provider = {
                        oneofKind: "webhook",
                        webhook: Config_Webhook.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).webhook)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_Notifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* v1.Config.Email email = 2; */
        if (message.provider.oneofKind === "email")
            Config_Email.internalBinaryWrite(message.provider.email, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.Webhook webhook = 3; */
        if (message.provider.oneofKind === "webhook")
            Config_Webhook.internalBinaryWrite(message.provider.webhook, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Notifier
 */
export const Config_Notifier = new Config_Notifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Email$Type extends MessageType<Config_Email> {
    constructor() {
        super("v1.Config.Email", [
            { no: 1, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hello", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "host_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "auth_username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "auth_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "auth_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "auth_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 10, name: "html", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "require_tls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_Email>): Config_Email {
        const message = { to: "", from: "", hello: "", hostPort: "", authUsername: "", authPassword: "", authSecret: "", authIdentity: "", headers: {}, html: "", text: "", requireTls: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Email>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Email): Config_Email {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string to */ 1:
                    message.to = reader.string();
                    break;
                case /* string from */ 2:
                    message.from = reader.string();
                    break;
                case /* string hello */ 3:
                    message.hello = reader.string();
                    break;
                case /* string host_port */ 4:
                    message.hostPort = reader.string();
                    break;
                case /* string auth_username */ 5:
                    message.authUsername = reader.string();
                    break;
                case /* string auth_password */ 6:
                    message.authPassword = reader.string();
                    break;
                case /* string auth_secret */ 7:
                    message.authSecret = reader.string();
                    break;
                case /* string auth_identity */ 8:
                    message.authIdentity = reader.string();
                    break;
                case /* map<string, string> headers */ 9:
                    this.binaryReadMap9(message.headers, reader, options);
                    break;
                case /* string html */ 10:
                    message.html = reader.string();
                    break;
                case /* string text */ 11:
                    message.text = reader.string();
                    break;
                case /* bool require_tls */ 12:
                    message.requireTls = reader.bool();
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 13:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: Config_Email["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Config_Email["headers"] | undefined, val: Config_Email["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Config.Email.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Config_Email, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string to = 1; */
        if (message.to !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.to);
        /* string from = 2; */
        if (message.from !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.from);
        /* string hello = 3; */
        if (message.hello !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hello);
        /* string host_port = 4; */
        if (message.hostPort !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hostPort);
        /* string auth_username = 5; */
        if (message.authUsername !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.authUsername);
        /* string auth_password = 6; */
        if (message.authPassword !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.authPassword);
        /* string auth_secret = 7; */
        if (message.authSecret !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.authSecret);
        /* string auth_identity = 8; */
        if (message.authIdentity !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.authIdentity);
        /* map<string, string> headers = 9; */
        for (let k of Object.keys(message.headers))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* string html = 10; */
        if (message.html !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.html);
        /* string text = 11; */
        if (message.text !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.text);
        /* bool require_tls = 12; */
        if (message.requireTls !== false)
            writer.tag(12, WireType.Varint).bool(message.requireTls);
        /* v1.Config.HTTP.TLSConfig tls_config = 13; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Email
 */
export const Config_Email = new Config_Email$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Webhook$Type extends MessageType<Config_Webhook> {
    constructor() {
        super("v1.Config.Webhook", [
            { no: 1, name: "http_config", kind: "message", T: () => Config_HTTP },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_Webhook>): Config_Webhook {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Webhook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Webhook): Config_Webhook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Config.HTTP http_config */ 1:
                    message.httpConfig = Config_HTTP.internalBinaryRead(reader, reader.uint32(), options, message.httpConfig);
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_Webhook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Config.HTTP http_config = 1; */
        if (message.httpConfig)
            Config_HTTP.internalBinaryWrite(message.httpConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Webhook
 */
export const Config_Webhook = new Config_Webhook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP$Type extends MessageType<Config_HTTP> {
    constructor() {
        super("v1.Config.HTTP", [
            { no: 1, name: "basic_auth", kind: "message", T: () => Config_HTTP_BasicAuth },
            { no: 2, name: "authorization", kind: "message", T: () => Config_HTTP_Authorization },
            { no: 3, name: "pauth2", kind: "message", T: () => Config_HTTP_OAuth2 },
            { no: 4, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP>): Config_HTTP {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP): Config_HTTP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Config.HTTP.BasicAuth basic_auth */ 1:
                    message.basicAuth = Config_HTTP_BasicAuth.internalBinaryRead(reader, reader.uint32(), options, message.basicAuth);
                    break;
                case /* v1.Config.HTTP.Authorization authorization */ 2:
                    message.authorization = Config_HTTP_Authorization.internalBinaryRead(reader, reader.uint32(), options, message.authorization);
                    break;
                case /* v1.Config.HTTP.OAuth2 pauth2 */ 3:
                    message.pauth2 = Config_HTTP_OAuth2.internalBinaryRead(reader, reader.uint32(), options, message.pauth2);
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 4:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Config.HTTP.BasicAuth basic_auth = 1; */
        if (message.basicAuth)
            Config_HTTP_BasicAuth.internalBinaryWrite(message.basicAuth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.Authorization authorization = 2; */
        if (message.authorization)
            Config_HTTP_Authorization.internalBinaryWrite(message.authorization, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.OAuth2 pauth2 = 3; */
        if (message.pauth2)
            Config_HTTP_OAuth2.internalBinaryWrite(message.pauth2, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.TLSConfig tls_config = 4; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP
 */
export const Config_HTTP = new Config_HTTP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_BasicAuth$Type extends MessageType<Config_HTTP_BasicAuth> {
    constructor() {
        super("v1.Config.HTTP.BasicAuth", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_BasicAuth>): Config_HTTP_BasicAuth {
        const message = { username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_BasicAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_BasicAuth): Config_HTTP_BasicAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_BasicAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.BasicAuth
 */
export const Config_HTTP_BasicAuth = new Config_HTTP_BasicAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_Authorization$Type extends MessageType<Config_HTTP_Authorization> {
    constructor() {
        super("v1.Config.HTTP.Authorization", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "credentials", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_Authorization>): Config_HTTP_Authorization {
        const message = { type: "", credentials: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_Authorization>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_Authorization): Config_HTTP_Authorization {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string credentials */ 2:
                    message.credentials = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_Authorization, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string credentials = 2; */
        if (message.credentials !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentials);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.Authorization
 */
export const Config_HTTP_Authorization = new Config_HTTP_Authorization$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_OAuth2$Type extends MessageType<Config_HTTP_OAuth2> {
    constructor() {
        super("v1.Config.HTTP.OAuth2", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_scopes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "endpoint_params", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_OAuth2>): Config_HTTP_OAuth2 {
        const message = { clientId: "", clientSecret: "", clientScopes: [], tokenUrl: "", endpointParams: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_OAuth2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_OAuth2): Config_HTTP_OAuth2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string client_secret */ 2:
                    message.clientSecret = reader.string();
                    break;
                case /* repeated string client_scopes */ 3:
                    message.clientScopes.push(reader.string());
                    break;
                case /* string token_url */ 4:
                    message.tokenUrl = reader.string();
                    break;
                case /* map<string, string> endpoint_params */ 5:
                    this.binaryReadMap5(message.endpointParams, reader, options);
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 6:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Config_HTTP_OAuth2["endpointParams"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Config_HTTP_OAuth2["endpointParams"] | undefined, val: Config_HTTP_OAuth2["endpointParams"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Config.HTTP.OAuth2.endpoint_params");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Config_HTTP_OAuth2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string client_secret = 2; */
        if (message.clientSecret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientSecret);
        /* repeated string client_scopes = 3; */
        for (let i = 0; i < message.clientScopes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.clientScopes[i]);
        /* string token_url = 4; */
        if (message.tokenUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenUrl);
        /* map<string, string> endpoint_params = 5; */
        for (let k of Object.keys(message.endpointParams))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.endpointParams[k]).join();
        /* v1.Config.HTTP.TLSConfig tls_config = 6; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.OAuth2
 */
export const Config_HTTP_OAuth2 = new Config_HTTP_OAuth2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_TLSConfig$Type extends MessageType<Config_HTTP_TLSConfig> {
    constructor() {
        super("v1.Config.HTTP.TLSConfig", [
            { no: 1, name: "key_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cert_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "insecure_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_TLSConfig>): Config_HTTP_TLSConfig {
        const message = { keyFile: "", certFile: "", insecureSkipVerify: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_TLSConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_TLSConfig): Config_HTTP_TLSConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key_file */ 1:
                    message.keyFile = reader.string();
                    break;
                case /* string cert_file */ 2:
                    message.certFile = reader.string();
                    break;
                case /* bool insecure_skip_verify */ 3:
                    message.insecureSkipVerify = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_TLSConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key_file = 1; */
        if (message.keyFile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyFile);
        /* string cert_file = 2; */
        if (message.certFile !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.certFile);
        /* bool insecure_skip_verify = 3; */
        if (message.insecureSkipVerify !== false)
            writer.tag(3, WireType.Varint).bool(message.insecureSkipVerify);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.TLSConfig
 */
export const Config_HTTP_TLSConfig = new Config_HTTP_TLSConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Account$Type extends MessageType<Account> {
    constructor() {
        super("v1.Account", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hashed_password", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Account>): Account {
        const message = { name: "", hashedPassword: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Account>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Account): Account {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bytes hashed_password */ 2:
                    message.hashedPassword = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Account, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bytes hashed_password = 2; */
        if (message.hashedPassword.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.hashedPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Account
 */
export const Account = new Account$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Account_Key$Type extends MessageType<Account_Key> {
    constructor() {
        super("v1.Account.Key", [
            { no: 1, name: "store", kind: "message", T: () => StoreKey },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Account_Key>): Account_Key {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Account_Key>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Account_Key): Account_Key {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.StoreKey store */ 1:
                    message.store = StoreKey.internalBinaryRead(reader, reader.uint32(), options, message.store);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Account_Key, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.StoreKey store = 1; */
        if (message.store)
            StoreKey.internalBinaryWrite(message.store, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Account.Key
 */
export const Account_Key = new Account_Key$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client$Type extends MessageType<Client> {
    constructor() {
        super("v1.Client", [
            { no: 1, name: "private_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "instance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Client_Instance } },
            { no: 3, name: "server_id", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "active", kind: "message", T: () => Client_Active },
            { no: 5, name: "clusters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Cluster_Config } }
        ]);
    }
    create(value?: PartialMessage<Client>): Client {
        const message = { privateKey: new Uint8Array(0), instance: {}, serverId: {}, clusters: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client): Client {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes private_key */ 1:
                    message.privateKey = reader.bytes();
                    break;
                case /* map<string, v1.Client.Instance> instance */ 2:
                    this.binaryReadMap2(message.instance, reader, options);
                    break;
                case /* map<string, string> server_id */ 3:
                    this.binaryReadMap3(message.serverId, reader, options);
                    break;
                case /* v1.Client.Active active */ 4:
                    message.active = Client_Active.internalBinaryRead(reader, reader.uint32(), options, message.active);
                    break;
                case /* map<string, v1.Cluster.Config> clusters */ 5:
                    this.binaryReadMap5(message.clusters, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Client["instance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["instance"] | undefined, val: Client["instance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Client_Instance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.instance");
            }
        }
        map[key ?? ""] = val ?? Client_Instance.create();
    }
    private binaryReadMap3(map: Client["serverId"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["serverId"] | undefined, val: Client["serverId"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.server_id");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: Client["clusters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["clusters"] | undefined, val: Client["clusters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Cluster_Config.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.clusters");
            }
        }
        map[key ?? ""] = val ?? Cluster_Config.create();
    }
    internalBinaryWrite(message: Client, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes private_key = 1; */
        if (message.privateKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.privateKey);
        /* map<string, v1.Client.Instance> instance = 2; */
        for (let k of Object.keys(message.instance)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Client_Instance.internalBinaryWrite(message.instance[k], writer, options);
            writer.join().join();
        }
        /* map<string, string> server_id = 3; */
        for (let k of Object.keys(message.serverId))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.serverId[k]).join();
        /* v1.Client.Active active = 4; */
        if (message.active)
            Client_Active.internalBinaryWrite(message.active, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, v1.Cluster.Config> clusters = 5; */
        for (let k of Object.keys(message.clusters)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Cluster_Config.internalBinaryWrite(message.clusters[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client
 */
export const Client = new Client$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Instance$Type extends MessageType<Client_Instance> {
    constructor() {
        super("v1.Client.Instance", [
            { no: 1, name: "accounts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Client_Auth } }
        ]);
    }
    create(value?: PartialMessage<Client_Instance>): Client_Instance {
        const message = { accounts: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Instance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Instance): Client_Instance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, v1.Client.Auth> accounts */ 1:
                    this.binaryReadMap1(message.accounts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Client_Instance["accounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client_Instance["accounts"] | undefined, val: Client_Instance["accounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Client_Auth.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.Instance.accounts");
            }
        }
        map[key ?? ""] = val ?? Client_Auth.create();
    }
    internalBinaryWrite(message: Client_Instance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, v1.Client.Auth> accounts = 1; */
        for (let k of Object.keys(message.accounts)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Client_Auth.internalBinaryWrite(message.accounts[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Instance
 */
export const Client_Instance = new Client_Instance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Active$Type extends MessageType<Client_Active> {
    constructor() {
        super("v1.Client.Active", [
            { no: 1, name: "instance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client_Active>): Client_Active {
        const message = { instance: "", account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Active>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Active): Client_Active {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instance */ 1:
                    message.instance = reader.string();
                    break;
                case /* string account */ 2:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client_Active, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instance = 1; */
        if (message.instance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instance);
        /* string account = 2; */
        if (message.account !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Active
 */
export const Client_Active = new Client_Active$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Auth$Type extends MessageType<Client_Auth> {
    constructor() {
        super("v1.Client.Auth", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client_Auth>): Client_Auth {
        const message = { name: "", token: "", serverId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Auth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Auth): Client_Auth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                case /* string server_id */ 3:
                    message.serverId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client_Auth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* string server_id = 3; */
        if (message.serverId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Auth
 */
export const Client_Auth = new Client_Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token$Type extends MessageType<Token> {
    constructor() {
        super("v1.Token", [
            { no: 1, name: "pub_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Token>): Token {
        const message = { pubKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pub_key */ 1:
                    message.pubKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pub_key = 1; */
        if (message.pubKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pubKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Token
 */
export const Token = new Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token_Create$Type extends MessageType<Token_Create> {
    constructor() {
        super("v1.Token.Create", []);
    }
    create(value?: PartialMessage<Token_Create>): Token_Create {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Token_Create>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token_Create): Token_Create {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Token_Create, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Token.Create
 */
export const Token_Create = new Token_Create$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token_Create_Request$Type extends MessageType<Token_Create_Request> {
    constructor() {
        super("v1.Token.Create.Request", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "generate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "ttl", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<Token_Create_Request>): Token_Create_Request {
        const message = { name: "", password: "", token: "", publicKey: new Uint8Array(0), generate: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Token_Create_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token_Create_Request): Token_Create_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                case /* bytes public_key */ 4:
                    message.publicKey = reader.bytes();
                    break;
                case /* bool generate */ 5:
                    message.generate = reader.bool();
                    break;
                case /* google.protobuf.Duration ttl */ 6:
                    message.ttl = Duration.internalBinaryRead(reader, reader.uint32(), options, message.ttl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token_Create_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* bytes public_key = 4; */
        if (message.publicKey.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.publicKey);
        /* bool generate = 5; */
        if (message.generate !== false)
            writer.tag(5, WireType.Varint).bool(message.generate);
        /* google.protobuf.Duration ttl = 6; */
        if (message.ttl)
            Duration.internalBinaryWrite(message.ttl, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Token.Create.Request
 */
export const Token_Create_Request = new Token_Create_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token_Create_Response$Type extends MessageType<Token_Create_Response> {
    constructor() {
        super("v1.Token.Create.Response", [
            { no: 1, name: "auth", kind: "message", T: () => Client_Auth }
        ]);
    }
    create(value?: PartialMessage<Token_Create_Response>): Token_Create_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Token_Create_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token_Create_Response): Token_Create_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Client.Auth auth */ 1:
                    message.auth = Client_Auth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token_Create_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Client.Auth auth = 1; */
        if (message.auth)
            Client_Auth.internalBinaryWrite(message.auth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Token.Create.Response
 */
export const Token_Create_Response = new Token_Create_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token_Key$Type extends MessageType<Token_Key> {
    constructor() {
        super("v1.Token.Key", [
            { no: 1, name: "store", kind: "message", T: () => StoreKey },
            { no: 2, name: "hash", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Token_Key>): Token_Key {
        const message = { hash: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Token_Key>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token_Key): Token_Key {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.StoreKey store */ 1:
                    message.store = StoreKey.internalBinaryRead(reader, reader.uint32(), options, message.store);
                    break;
                case /* int64 hash */ 2:
                    message.hash = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token_Key, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.StoreKey store = 1; */
        if (message.store)
            StoreKey.internalBinaryWrite(message.store, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 hash = 2; */
        if (message.hash !== 0n)
            writer.tag(2, WireType.Varint).int64(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Token.Key
 */
export const Token_Key = new Token_Key$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("v1.Error", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = { error: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query$Type extends MessageType<Query> {
    constructor() {
        super("v1.Query", []);
    }
    create(value?: PartialMessage<Query>): Query {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query): Query {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Query, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query
 */
export const Query = new Query$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query_Value$Type extends MessageType<Query_Value> {
    constructor() {
        super("v1.Query.Value", [
            { no: 1, name: "number", kind: "scalar", oneof: "value", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "double", kind: "scalar", oneof: "value", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "string", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "bool", kind: "scalar", oneof: "value", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "timestamp", kind: "message", oneof: "value", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Query_Value>): Query_Value {
        const message = { value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query_Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query_Value): Query_Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 number */ 1:
                    message.value = {
                        oneofKind: "number",
                        number: reader.int64().toBigInt()
                    };
                    break;
                case /* double double */ 2:
                    message.value = {
                        oneofKind: "double",
                        double: reader.double()
                    };
                    break;
                case /* string string */ 3:
                    message.value = {
                        oneofKind: "string",
                        string: reader.string()
                    };
                    break;
                case /* bool bool */ 4:
                    message.value = {
                        oneofKind: "bool",
                        bool: reader.bool()
                    };
                    break;
                case /* google.protobuf.Timestamp timestamp */ 5:
                    message.value = {
                        oneofKind: "timestamp",
                        timestamp: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).timestamp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query_Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 number = 1; */
        if (message.value.oneofKind === "number")
            writer.tag(1, WireType.Varint).int64(message.value.number);
        /* double double = 2; */
        if (message.value.oneofKind === "double")
            writer.tag(2, WireType.Bit64).double(message.value.double);
        /* string string = 3; */
        if (message.value.oneofKind === "string")
            writer.tag(3, WireType.LengthDelimited).string(message.value.string);
        /* bool bool = 4; */
        if (message.value.oneofKind === "bool")
            writer.tag(4, WireType.Varint).bool(message.value.bool);
        /* google.protobuf.Timestamp timestamp = 5; */
        if (message.value.oneofKind === "timestamp")
            Timestamp.internalBinaryWrite(message.value.timestamp, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query.Value
 */
export const Query_Value = new Query_Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query_Request$Type extends MessageType<Query_Request> {
    constructor() {
        super("v1.Query.Request", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Query_Param }
        ]);
    }
    create(value?: PartialMessage<Query_Request>): Query_Request {
        const message = { query: "", params: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query_Request): Query_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* repeated v1.Query.Param params */ 2:
                    message.params.push(Query_Param.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* repeated v1.Query.Param params = 2; */
        for (let i = 0; i < message.params.length; i++)
            Query_Param.internalBinaryWrite(message.params[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query.Request
 */
export const Query_Request = new Query_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query_Response$Type extends MessageType<Query_Response> {
    constructor() {
        super("v1.Query.Response", [
            { no: 1, name: "elapsed", kind: "message", T: () => Duration },
            { no: 2, name: "columns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Query_Colum },
            { no: 3, name: "rows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Query_Row }
        ]);
    }
    create(value?: PartialMessage<Query_Response>): Query_Response {
        const message = { columns: [], rows: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query_Response): Query_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration elapsed */ 1:
                    message.elapsed = Duration.internalBinaryRead(reader, reader.uint32(), options, message.elapsed);
                    break;
                case /* repeated v1.Query.Colum columns */ 2:
                    message.columns.push(Query_Colum.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated v1.Query.Row rows */ 3:
                    message.rows.push(Query_Row.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration elapsed = 1; */
        if (message.elapsed)
            Duration.internalBinaryWrite(message.elapsed, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated v1.Query.Colum columns = 2; */
        for (let i = 0; i < message.columns.length; i++)
            Query_Colum.internalBinaryWrite(message.columns[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated v1.Query.Row rows = 3; */
        for (let i = 0; i < message.rows.length; i++)
            Query_Row.internalBinaryWrite(message.rows[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query.Response
 */
export const Query_Response = new Query_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query_Param$Type extends MessageType<Query_Param> {
    constructor() {
        super("v1.Query.Param", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Query_Value }
        ]);
    }
    create(value?: PartialMessage<Query_Param>): Query_Param {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query_Param>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query_Param): Query_Param {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* v1.Query.Value value */ 2:
                    message.value = Query_Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query_Param, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* v1.Query.Value value = 2; */
        if (message.value)
            Query_Value.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query.Param
 */
export const Query_Param = new Query_Param$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query_Colum$Type extends MessageType<Query_Colum> {
    constructor() {
        super("v1.Query.Colum", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data_type", kind: "enum", T: () => ["v1.Query.Colum.DataType", Query_Colum_DataType] }
        ]);
    }
    create(value?: PartialMessage<Query_Colum>): Query_Colum {
        const message = { name: "", dataType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query_Colum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query_Colum): Query_Colum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* v1.Query.Colum.DataType data_type */ 2:
                    message.dataType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query_Colum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* v1.Query.Colum.DataType data_type = 2; */
        if (message.dataType !== 0)
            writer.tag(2, WireType.Varint).int32(message.dataType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query.Colum
 */
export const Query_Colum = new Query_Colum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query_Row$Type extends MessageType<Query_Row> {
    constructor() {
        super("v1.Query.Row", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Query_Value }
        ]);
    }
    create(value?: PartialMessage<Query_Row>): Query_Row {
        const message = { values: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query_Row>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query_Row): Query_Row {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated v1.Query.Value values */ 1:
                    message.values.push(Query_Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query_Row, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated v1.Query.Value values = 1; */
        for (let i = 0; i < message.values.length; i++)
            Query_Value.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Query.Row
 */
export const Query_Row = new Query_Row$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Notice$Type extends MessageType<Notice> {
    constructor() {
        super("v1.Notice", []);
    }
    create(value?: PartialMessage<Notice>): Notice {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Notice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Notice): Notice {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Notice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Notice
 */
export const Notice = new Notice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft$Type extends MessageType<Raft> {
    constructor() {
        super("v1.Raft", []);
    }
    create(value?: PartialMessage<Raft>): Raft {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft): Raft {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft
 */
export const Raft = new Raft$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Entry$Type extends MessageType<Raft_Entry> {
    constructor() {
        super("v1.Raft.Entry", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "expires", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<Raft_Entry>): Raft_Entry {
        const message = { key: new Uint8Array(0), value: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Entry): Raft_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* google.protobuf.Duration expires */ 3:
                    message.expires = Duration.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* google.protobuf.Duration expires = 3; */
        if (message.expires)
            Duration.internalBinaryWrite(message.expires, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Entry
 */
export const Raft_Entry = new Raft_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Log$Type extends MessageType<Raft_Log> {
    constructor() {
        super("v1.Raft.Log", [
            { no: 1, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["v1.Raft.Log.Type", Raft_Log_Type] },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "extensions", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "appended_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Raft_Log>): Raft_Log {
        const message = { index: 0n, term: 0n, type: 0, data: new Uint8Array(0), extensions: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Log>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Log): Raft_Log {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 index */ 1:
                    message.index = reader.uint64().toBigInt();
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* v1.Raft.Log.Type type */ 3:
                    message.type = reader.int32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* bytes extensions */ 5:
                    message.extensions = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp appended_at */ 6:
                    message.appendedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.appendedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Log, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 index = 1; */
        if (message.index !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.index);
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* v1.Raft.Log.Type type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* bytes extensions = 5; */
        if (message.extensions.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.extensions);
        /* google.protobuf.Timestamp appended_at = 6; */
        if (message.appendedAt)
            Timestamp.internalBinaryWrite(message.appendedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Log
 */
export const Raft_Log = new Raft_Log$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Config$Type extends MessageType<Raft_Config> {
    constructor() {
        super("v1.Raft.Config", [
            { no: 1, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Raft_Config_Server }
        ]);
    }
    create(value?: PartialMessage<Raft_Config>): Raft_Config {
        const message = { servers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Config): Raft_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated v1.Raft.Config.Server servers */ 1:
                    message.servers.push(Raft_Config_Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated v1.Raft.Config.Server servers = 1; */
        for (let i = 0; i < message.servers.length; i++)
            Raft_Config_Server.internalBinaryWrite(message.servers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Config
 */
export const Raft_Config = new Raft_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Config_Server$Type extends MessageType<Raft_Config_Server> {
    constructor() {
        super("v1.Raft.Config.Server", [
            { no: 1, name: "suffrage", kind: "enum", T: () => ["v1.Raft.Config.Server.Suffrage", Raft_Config_Server_Suffrage] },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_Config_Server>): Raft_Config_Server {
        const message = { suffrage: 0, id: "", address: "", token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Config_Server>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Config_Server): Raft_Config_Server {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.Config.Server.Suffrage suffrage */ 1:
                    message.suffrage = reader.int32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* string token */ 4:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Config_Server, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.Config.Server.Suffrage suffrage = 1; */
        if (message.suffrage !== 0)
            writer.tag(1, WireType.Varint).int32(message.suffrage);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* string token = 4; */
        if (message.token !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Config.Server
 */
export const Raft_Config_Server = new Raft_Config_Server$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC$Type extends MessageType<Raft_RPC> {
    constructor() {
        super("v1.Raft.RPC", []);
    }
    create(value?: PartialMessage<Raft_RPC>): Raft_RPC {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC): Raft_RPC {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC
 */
export const Raft_RPC = new Raft_RPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Call$Type extends MessageType<Raft_RPC_Call> {
    constructor() {
        super("v1.Raft.RPC.Call", []);
    }
    create(value?: PartialMessage<Raft_RPC_Call>): Raft_RPC_Call {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Call): Raft_RPC_Call {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Call
 */
export const Raft_RPC_Call = new Raft_RPC_Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Call_Request$Type extends MessageType<Raft_RPC_Call_Request> {
    constructor() {
        super("v1.Raft.RPC.Call.Request", [
            { no: 1, name: "append_entries", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_AppendEntries_Request },
            { no: 2, name: "vote", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_Vote_Request },
            { no: 3, name: "install_snapshot", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_InstallSnapshot_Request },
            { no: 4, name: "timeout_now", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_TimeoutNow_Request }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Call_Request>): Raft_RPC_Call_Request {
        const message = { kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Call_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Call_Request): Raft_RPC_Call_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.AppendEntries.Request append_entries */ 1:
                    message.kind = {
                        oneofKind: "appendEntries",
                        appendEntries: Raft_RPC_Command_AppendEntries_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).appendEntries)
                    };
                    break;
                case /* v1.Raft.RPC.Command.Vote.Request vote */ 2:
                    message.kind = {
                        oneofKind: "vote",
                        vote: Raft_RPC_Command_Vote_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).vote)
                    };
                    break;
                case /* v1.Raft.RPC.Command.InstallSnapshot.Request install_snapshot */ 3:
                    message.kind = {
                        oneofKind: "installSnapshot",
                        installSnapshot: Raft_RPC_Command_InstallSnapshot_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).installSnapshot)
                    };
                    break;
                case /* v1.Raft.RPC.Command.TimeoutNow.Request timeout_now */ 4:
                    message.kind = {
                        oneofKind: "timeoutNow",
                        timeoutNow: Raft_RPC_Command_TimeoutNow_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timeoutNow)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Call_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.AppendEntries.Request append_entries = 1; */
        if (message.kind.oneofKind === "appendEntries")
            Raft_RPC_Command_AppendEntries_Request.internalBinaryWrite(message.kind.appendEntries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.Vote.Request vote = 2; */
        if (message.kind.oneofKind === "vote")
            Raft_RPC_Command_Vote_Request.internalBinaryWrite(message.kind.vote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.InstallSnapshot.Request install_snapshot = 3; */
        if (message.kind.oneofKind === "installSnapshot")
            Raft_RPC_Command_InstallSnapshot_Request.internalBinaryWrite(message.kind.installSnapshot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.TimeoutNow.Request timeout_now = 4; */
        if (message.kind.oneofKind === "timeoutNow")
            Raft_RPC_Command_TimeoutNow_Request.internalBinaryWrite(message.kind.timeoutNow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Call.Request
 */
export const Raft_RPC_Call_Request = new Raft_RPC_Call_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Call_Response$Type extends MessageType<Raft_RPC_Call_Response> {
    constructor() {
        super("v1.Raft.RPC.Call.Response", [
            { no: 1, name: "append_entries", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_AppendEntries_Response },
            { no: 2, name: "vote", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_Vote_Response },
            { no: 3, name: "install_snapshot", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_InstallSnapshot_Response },
            { no: 4, name: "timeout_now", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_TimeoutNow_Response },
            { no: 5, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Call_Response>): Raft_RPC_Call_Response {
        const message = { kind: { oneofKind: undefined }, error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Call_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Call_Response): Raft_RPC_Call_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.AppendEntries.Response append_entries */ 1:
                    message.kind = {
                        oneofKind: "appendEntries",
                        appendEntries: Raft_RPC_Command_AppendEntries_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).appendEntries)
                    };
                    break;
                case /* v1.Raft.RPC.Command.Vote.Response vote */ 2:
                    message.kind = {
                        oneofKind: "vote",
                        vote: Raft_RPC_Command_Vote_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).vote)
                    };
                    break;
                case /* v1.Raft.RPC.Command.InstallSnapshot.Response install_snapshot */ 3:
                    message.kind = {
                        oneofKind: "installSnapshot",
                        installSnapshot: Raft_RPC_Command_InstallSnapshot_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).installSnapshot)
                    };
                    break;
                case /* v1.Raft.RPC.Command.TimeoutNow.Response timeout_now */ 4:
                    message.kind = {
                        oneofKind: "timeoutNow",
                        timeoutNow: Raft_RPC_Command_TimeoutNow_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timeoutNow)
                    };
                    break;
                case /* string error */ 5:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Call_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.AppendEntries.Response append_entries = 1; */
        if (message.kind.oneofKind === "appendEntries")
            Raft_RPC_Command_AppendEntries_Response.internalBinaryWrite(message.kind.appendEntries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.Vote.Response vote = 2; */
        if (message.kind.oneofKind === "vote")
            Raft_RPC_Command_Vote_Response.internalBinaryWrite(message.kind.vote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.InstallSnapshot.Response install_snapshot = 3; */
        if (message.kind.oneofKind === "installSnapshot")
            Raft_RPC_Command_InstallSnapshot_Response.internalBinaryWrite(message.kind.installSnapshot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.TimeoutNow.Response timeout_now = 4; */
        if (message.kind.oneofKind === "timeoutNow")
            Raft_RPC_Command_TimeoutNow_Response.internalBinaryWrite(message.kind.timeoutNow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string error = 5; */
        if (message.error !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Call.Response
 */
export const Raft_RPC_Call_Response = new Raft_RPC_Call_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command$Type extends MessageType<Raft_RPC_Command> {
    constructor() {
        super("v1.Raft.RPC.Command", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command>): Raft_RPC_Command {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command): Raft_RPC_Command {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command
 */
export const Raft_RPC_Command = new Raft_RPC_Command$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_AppendEntries$Type extends MessageType<Raft_RPC_Command_AppendEntries> {
    constructor() {
        super("v1.Raft.RPC.Command.AppendEntries", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_AppendEntries>): Raft_RPC_Command_AppendEntries {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_AppendEntries>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_AppendEntries): Raft_RPC_Command_AppendEntries {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_AppendEntries, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.AppendEntries
 */
export const Raft_RPC_Command_AppendEntries = new Raft_RPC_Command_AppendEntries$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_AppendEntries_Request$Type extends MessageType<Raft_RPC_Command_AppendEntries_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.AppendEntries.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "prev_log_entry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "prev_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Raft_Log },
            { no: 7, name: "leader_commit_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_AppendEntries_Request>): Raft_RPC_Command_AppendEntries_Request {
        const message = { term: 0n, prevLogEntry: 0n, prevLogTerm: 0n, entries: [], leaderCommitIndex: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_AppendEntries_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_AppendEntries_Request): Raft_RPC_Command_AppendEntries_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 prev_log_entry */ 4:
                    message.prevLogEntry = reader.uint64().toBigInt();
                    break;
                case /* uint64 prev_log_term */ 5:
                    message.prevLogTerm = reader.uint64().toBigInt();
                    break;
                case /* repeated v1.Raft.Log entries */ 6:
                    message.entries.push(Raft_Log.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 leader_commit_index */ 7:
                    message.leaderCommitIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_AppendEntries_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 prev_log_entry = 4; */
        if (message.prevLogEntry !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.prevLogEntry);
        /* uint64 prev_log_term = 5; */
        if (message.prevLogTerm !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.prevLogTerm);
        /* repeated v1.Raft.Log entries = 6; */
        for (let i = 0; i < message.entries.length; i++)
            Raft_Log.internalBinaryWrite(message.entries[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 leader_commit_index = 7; */
        if (message.leaderCommitIndex !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.leaderCommitIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.AppendEntries.Request
 */
export const Raft_RPC_Command_AppendEntries_Request = new Raft_RPC_Command_AppendEntries_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_AppendEntries_Response$Type extends MessageType<Raft_RPC_Command_AppendEntries_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.AppendEntries.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_log", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "no_retry_backoff", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_AppendEntries_Response>): Raft_RPC_Command_AppendEntries_Response {
        const message = { term: 0n, lastLog: 0n, success: false, noRetryBackoff: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_AppendEntries_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_AppendEntries_Response): Raft_RPC_Command_AppendEntries_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log */ 3:
                    message.lastLog = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                case /* bool no_retry_backoff */ 5:
                    message.noRetryBackoff = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_AppendEntries_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 last_log = 3; */
        if (message.lastLog !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastLog);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        /* bool no_retry_backoff = 5; */
        if (message.noRetryBackoff !== false)
            writer.tag(5, WireType.Varint).bool(message.noRetryBackoff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.AppendEntries.Response
 */
export const Raft_RPC_Command_AppendEntries_Response = new Raft_RPC_Command_AppendEntries_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Vote$Type extends MessageType<Raft_RPC_Command_Vote> {
    constructor() {
        super("v1.Raft.RPC.Command.Vote", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Vote>): Raft_RPC_Command_Vote {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Vote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Vote): Raft_RPC_Command_Vote {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_Vote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Vote
 */
export const Raft_RPC_Command_Vote = new Raft_RPC_Command_Vote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Vote_Request$Type extends MessageType<Raft_RPC_Command_Vote_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.Vote.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_log_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "leadership_transfer", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Vote_Request>): Raft_RPC_Command_Vote_Request {
        const message = { term: 0n, lastLogIndex: 0n, lastLogTerm: 0n, leadershipTransfer: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Vote_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Vote_Request): Raft_RPC_Command_Vote_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_index */ 3:
                    message.lastLogIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_term */ 4:
                    message.lastLogTerm = reader.uint64().toBigInt();
                    break;
                case /* bool leadership_transfer */ 5:
                    message.leadershipTransfer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_Vote_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 last_log_index = 3; */
        if (message.lastLogIndex !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastLogIndex);
        /* uint64 last_log_term = 4; */
        if (message.lastLogTerm !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.lastLogTerm);
        /* bool leadership_transfer = 5; */
        if (message.leadershipTransfer !== false)
            writer.tag(5, WireType.Varint).bool(message.leadershipTransfer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Vote.Request
 */
export const Raft_RPC_Command_Vote_Request = new Raft_RPC_Command_Vote_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Vote_Response$Type extends MessageType<Raft_RPC_Command_Vote_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.Vote.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "granted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Vote_Response>): Raft_RPC_Command_Vote_Response {
        const message = { term: 0n, granted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Vote_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Vote_Response): Raft_RPC_Command_Vote_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bool granted */ 3:
                    message.granted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_Vote_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* bool granted = 3; */
        if (message.granted !== false)
            writer.tag(3, WireType.Varint).bool(message.granted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Vote.Response
 */
export const Raft_RPC_Command_Vote_Response = new Raft_RPC_Command_Vote_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_InstallSnapshot$Type extends MessageType<Raft_RPC_Command_InstallSnapshot> {
    constructor() {
        super("v1.Raft.RPC.Command.InstallSnapshot", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_InstallSnapshot>): Raft_RPC_Command_InstallSnapshot {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_InstallSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_InstallSnapshot): Raft_RPC_Command_InstallSnapshot {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_InstallSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.InstallSnapshot
 */
export const Raft_RPC_Command_InstallSnapshot = new Raft_RPC_Command_InstallSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_InstallSnapshot_Request$Type extends MessageType<Raft_RPC_Command_InstallSnapshot_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.InstallSnapshot.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "snapshot_version", kind: "enum", T: () => ["v1.Raft.RPC.Command.InstallSnapshot.Request.Version", Raft_RPC_Command_InstallSnapshot_Request_Version] },
            { no: 3, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "leader", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "last_log_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "last_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "configuration", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "configuration_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_InstallSnapshot_Request>): Raft_RPC_Command_InstallSnapshot_Request {
        const message = { snapshotVersion: 0, term: 0n, leader: new Uint8Array(0), lastLogIndex: 0n, lastLogTerm: 0n, configuration: new Uint8Array(0), configurationIndex: 0n, size: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_InstallSnapshot_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_InstallSnapshot_Request): Raft_RPC_Command_InstallSnapshot_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* v1.Raft.RPC.Command.InstallSnapshot.Request.Version snapshot_version */ 2:
                    message.snapshotVersion = reader.int32();
                    break;
                case /* uint64 term */ 3:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bytes leader */ 4:
                    message.leader = reader.bytes();
                    break;
                case /* uint64 last_log_index */ 5:
                    message.lastLogIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_term */ 6:
                    message.lastLogTerm = reader.uint64().toBigInt();
                    break;
                case /* bytes configuration */ 7:
                    message.configuration = reader.bytes();
                    break;
                case /* uint64 configuration_index */ 8:
                    message.configurationIndex = reader.uint64().toBigInt();
                    break;
                case /* int64 size */ 9:
                    message.size = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_InstallSnapshot_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.InstallSnapshot.Request.Version snapshot_version = 2; */
        if (message.snapshotVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.snapshotVersion);
        /* uint64 term = 3; */
        if (message.term !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.term);
        /* bytes leader = 4; */
        if (message.leader.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.leader);
        /* uint64 last_log_index = 5; */
        if (message.lastLogIndex !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.lastLogIndex);
        /* uint64 last_log_term = 6; */
        if (message.lastLogTerm !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.lastLogTerm);
        /* bytes configuration = 7; */
        if (message.configuration.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.configuration);
        /* uint64 configuration_index = 8; */
        if (message.configurationIndex !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.configurationIndex);
        /* int64 size = 9; */
        if (message.size !== 0n)
            writer.tag(9, WireType.Varint).int64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.InstallSnapshot.Request
 */
export const Raft_RPC_Command_InstallSnapshot_Request = new Raft_RPC_Command_InstallSnapshot_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_InstallSnapshot_Response$Type extends MessageType<Raft_RPC_Command_InstallSnapshot_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.InstallSnapshot.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_InstallSnapshot_Response>): Raft_RPC_Command_InstallSnapshot_Response {
        const message = { term: 0n, success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_InstallSnapshot_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_InstallSnapshot_Response): Raft_RPC_Command_InstallSnapshot_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 3:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_InstallSnapshot_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* bool success = 3; */
        if (message.success !== false)
            writer.tag(3, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.InstallSnapshot.Response
 */
export const Raft_RPC_Command_InstallSnapshot_Response = new Raft_RPC_Command_InstallSnapshot_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_TimeoutNow$Type extends MessageType<Raft_RPC_Command_TimeoutNow> {
    constructor() {
        super("v1.Raft.RPC.Command.TimeoutNow", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_TimeoutNow>): Raft_RPC_Command_TimeoutNow {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_TimeoutNow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_TimeoutNow): Raft_RPC_Command_TimeoutNow {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_TimeoutNow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.TimeoutNow
 */
export const Raft_RPC_Command_TimeoutNow = new Raft_RPC_Command_TimeoutNow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_TimeoutNow_Request$Type extends MessageType<Raft_RPC_Command_TimeoutNow_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.TimeoutNow.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_TimeoutNow_Request>): Raft_RPC_Command_TimeoutNow_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_TimeoutNow_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_TimeoutNow_Request): Raft_RPC_Command_TimeoutNow_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_TimeoutNow_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.TimeoutNow.Request
 */
export const Raft_RPC_Command_TimeoutNow_Request = new Raft_RPC_Command_TimeoutNow_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_TimeoutNow_Response$Type extends MessageType<Raft_RPC_Command_TimeoutNow_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.TimeoutNow.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_TimeoutNow_Response>): Raft_RPC_Command_TimeoutNow_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_TimeoutNow_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_TimeoutNow_Response): Raft_RPC_Command_TimeoutNow_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_TimeoutNow_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.TimeoutNow.Response
 */
export const Raft_RPC_Command_TimeoutNow_Response = new Raft_RPC_Command_TimeoutNow_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Header$Type extends MessageType<Raft_RPC_Command_Header> {
    constructor() {
        super("v1.Raft.RPC.Command.Header", [
            { no: 1, name: "version", kind: "enum", T: () => ["v1.Raft.RPC.Command.Header.Version", Raft_RPC_Command_Header_Version] },
            { no: 2, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Header>): Raft_RPC_Command_Header {
        const message = { version: 0, id: new Uint8Array(0), addr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Header): Raft_RPC_Command_Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header.Version version */ 1:
                    message.version = reader.int32();
                    break;
                case /* bytes id */ 2:
                    message.id = reader.bytes();
                    break;
                case /* bytes addr */ 3:
                    message.addr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header.Version version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).int32(message.version);
        /* bytes id = 2; */
        if (message.id.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.id);
        /* bytes addr = 3; */
        if (message.addr.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Header
 */
export const Raft_RPC_Command_Header = new Raft_RPC_Command_Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster$Type extends MessageType<Cluster> {
    constructor() {
        super("v1.Cluster", []);
    }
    create(value?: PartialMessage<Cluster>): Cluster {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster): Cluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster
 */
export const Cluster = new Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Apply$Type extends MessageType<Cluster_Apply> {
    constructor() {
        super("v1.Cluster.Apply", []);
    }
    create(value?: PartialMessage<Cluster_Apply>): Cluster_Apply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Apply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Apply): Cluster_Apply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster_Apply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Apply
 */
export const Cluster_Apply = new Cluster_Apply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Apply_Request$Type extends MessageType<Cluster_Apply_Request> {
    constructor() {
        super("v1.Cluster.Apply.Request", [
            { no: 1, name: "config", kind: "message", T: () => Cluster_Config }
        ]);
    }
    create(value?: PartialMessage<Cluster_Apply_Request>): Cluster_Apply_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Apply_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Apply_Request): Cluster_Apply_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Cluster.Config config */ 1:
                    message.config = Cluster_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_Apply_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Cluster.Config config = 1; */
        if (message.config)
            Cluster_Config.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Apply.Request
 */
export const Cluster_Apply_Request = new Cluster_Apply_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Apply_Response$Type extends MessageType<Cluster_Apply_Response> {
    constructor() {
        super("v1.Cluster.Apply.Response", [
            { no: 1, name: "ok", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cluster_Apply_Response>): Cluster_Apply_Response {
        const message = { ok: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Apply_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Apply_Response): Cluster_Apply_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ok */ 1:
                    message.ok = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_Apply_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ok = 1; */
        if (message.ok !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ok);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Apply.Response
 */
export const Cluster_Apply_Response = new Cluster_Apply_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Get$Type extends MessageType<Cluster_Get> {
    constructor() {
        super("v1.Cluster.Get", []);
    }
    create(value?: PartialMessage<Cluster_Get>): Cluster_Get {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Get>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Get): Cluster_Get {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster_Get, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Get
 */
export const Cluster_Get = new Cluster_Get$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Get_Request$Type extends MessageType<Cluster_Get_Request> {
    constructor() {
        super("v1.Cluster.Get.Request", []);
    }
    create(value?: PartialMessage<Cluster_Get_Request>): Cluster_Get_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Get_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Get_Request): Cluster_Get_Request {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster_Get_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Get.Request
 */
export const Cluster_Get_Request = new Cluster_Get_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Get_Response$Type extends MessageType<Cluster_Get_Response> {
    constructor() {
        super("v1.Cluster.Get.Response", [
            { no: 1, name: "config", kind: "message", T: () => Cluster_Config }
        ]);
    }
    create(value?: PartialMessage<Cluster_Get_Response>): Cluster_Get_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Get_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Get_Response): Cluster_Get_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Cluster.Config config */ 1:
                    message.config = Cluster_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_Get_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Cluster.Config config = 1; */
        if (message.config)
            Cluster_Config.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Get.Response
 */
export const Cluster_Get_Response = new Cluster_Get_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Config$Type extends MessageType<Cluster_Config> {
    constructor() {
        super("v1.Cluster.Config", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nodes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Cluster_Config_Node } }
        ]);
    }
    create(value?: PartialMessage<Cluster_Config>): Cluster_Config {
        const message = { name: "", nodes: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Config): Cluster_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, v1.Cluster.Config.Node> nodes */ 2:
                    this.binaryReadMap2(message.nodes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Cluster_Config["nodes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Cluster_Config["nodes"] | undefined, val: Cluster_Config["nodes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Cluster_Config_Node.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Cluster.Config.nodes");
            }
        }
        map[key ?? ""] = val ?? Cluster_Config_Node.create();
    }
    internalBinaryWrite(message: Cluster_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, v1.Cluster.Config.Node> nodes = 2; */
        for (let k of Object.keys(message.nodes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Cluster_Config_Node.internalBinaryWrite(message.nodes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Config
 */
export const Cluster_Config = new Cluster_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Config_Node$Type extends MessageType<Cluster_Config_Node> {
    constructor() {
        super("v1.Cluster.Config.Node", [
            { no: 1, name: "account", kind: "message", T: () => Client_Auth },
            { no: 2, name: "bootstrap", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cluster_Config_Node>): Cluster_Config_Node {
        const message = { bootstrap: false, address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Config_Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Config_Node): Cluster_Config_Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Client.Auth account */ 1:
                    message.account = Client_Auth.internalBinaryRead(reader, reader.uint32(), options, message.account);
                    break;
                case /* bool bootstrap */ 2:
                    message.bootstrap = reader.bool();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_Config_Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Client.Auth account = 1; */
        if (message.account)
            Client_Auth.internalBinaryWrite(message.account, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool bootstrap = 2; */
        if (message.bootstrap !== false)
            writer.tag(2, WireType.Varint).bool(message.bootstrap);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Config.Node
 */
export const Cluster_Config_Node = new Cluster_Config_Node$Type();
/**
 * @generated ServiceType for protobuf service v1.Vince
 */
export const Vince = new ServiceType("v1.Vince", [
    { name: "CreateSite", options: {}, I: Site_Create_Request, O: Site_Create_Request }
]);
