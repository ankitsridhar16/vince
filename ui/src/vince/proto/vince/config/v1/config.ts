// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "vince/config/v1/config.proto" (package "v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../google/protobuf/duration";
/**
 * Configuration object for vince instance
 *
 * @generated from protobuf message v1.Config
 */
export interface Config {
    /**
     * Path to the main badger database.
     *
     * @generated from protobuf field: string db_path = 1;
     */
    dbPath: string;
    /**
     * Path to where block files are stored. Blocks are stored as files with ULID
     * as filenames
     *
     * @generated from protobuf field: string blocks_path = 2;
     */
    blocksPath: string;
    /**
     * host:port to bind for http api. This is used by serve command. The server
     * serves ui console
     *
     * @generated from protobuf field: string listen_address = 3;
     */
    listenAddress: string;
    /**
     * Control how much is logged options are
     * trace,debug,info,warn,error,fatal,panic
     *
     * @generated from protobuf field: string log_level = 4;
     */
    logLevel: string;
    /**
     * Interval for syncing buffered entries. By default events are buffered and
     * periodically saved.
     *
     * @generated from protobuf field: google.protobuf.Duration sync_interval = 5;
     */
    syncInterval?: Duration;
    /**
     * Expose /debug/pprof endpoint when serving
     *
     * @generated from protobuf field: bool enable_profile = 6;
     */
    enableProfile: boolean;
    /**
     * host:port to bind myslq server. Serves web analytics via MySQL compliant
     * wire protocol.
     *
     * @generated from protobuf field: string mysql_listen_address = 7;
     */
    mysqlListenAddress: string;
    /**
     * @generated from protobuf field: string tls_cert_file = 8;
     */
    tlsCertFile: string;
    /**
     * @generated from protobuf field: string tls_key_file = 9;
     */
    tlsKeyFile: string;
    /**
     * @generated from protobuf field: int64 events_buffer_size = 10;
     */
    eventsBufferSize: bigint;
    /**
     * @generated from protobuf field: repeated v1.Config.Notifier notifiers = 11;
     */
    notifiers: Config_Notifier[];
    /**
     * @generated from protobuf field: string server_id = 12;
     */
    serverId: string;
    /**
     * @generated from protobuf field: string raft_path = 13;
     */
    raftPath: string;
    /**
     * @generated from protobuf field: repeated string allowed_origins = 14;
     */
    allowedOrigins: string[];
}
/**
 * @generated from protobuf message v1.Config.Notifier
 */
export interface Config_Notifier {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "email";
        /**
         * @generated from protobuf field: v1.Config.Email email = 2;
         */
        email: Config_Email;
    } | {
        oneofKind: "webhook";
        /**
         * @generated from protobuf field: v1.Config.Webhook webhook = 3;
         */
        webhook: Config_Webhook;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.Config.Email
 */
export interface Config_Email {
    /**
     * @generated from protobuf field: string to = 1;
     */
    to: string;
    /**
     * @generated from protobuf field: string from = 2;
     */
    from: string;
    /**
     * @generated from protobuf field: string hello = 3;
     */
    hello: string;
    /**
     * @generated from protobuf field: string host_port = 4;
     */
    hostPort: string;
    /**
     * @generated from protobuf field: string auth_username = 5;
     */
    authUsername: string;
    /**
     * @generated from protobuf field: string auth_password = 6;
     */
    authPassword: string;
    /**
     * @generated from protobuf field: string auth_secret = 7;
     */
    authSecret: string;
    /**
     * @generated from protobuf field: string auth_identity = 8;
     */
    authIdentity: string;
    /**
     * @generated from protobuf field: map<string, string> headers = 9;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string html = 10;
     */
    html: string;
    /**
     * @generated from protobuf field: string text = 11;
     */
    text: string;
    /**
     * @generated from protobuf field: bool require_tls = 12;
     */
    requireTls: boolean;
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 13;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.Webhook
 */
export interface Config_Webhook {
    /**
     * @generated from protobuf field: v1.Config.HTTP http_config = 1;
     */
    httpConfig?: Config_HTTP;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP
 */
export interface Config_HTTP {
    /**
     * @generated from protobuf field: v1.Config.HTTP.BasicAuth basic_auth = 1;
     */
    basicAuth?: Config_HTTP_BasicAuth;
    /**
     * @generated from protobuf field: v1.Config.HTTP.Authorization authorization = 2;
     */
    authorization?: Config_HTTP_Authorization;
    /**
     * @generated from protobuf field: v1.Config.HTTP.OAuth2 pauth2 = 3;
     */
    pauth2?: Config_HTTP_OAuth2;
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 4;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.HTTP.BasicAuth
 */
export interface Config_HTTP_BasicAuth {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP.Authorization
 */
export interface Config_HTTP_Authorization {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string credentials = 2;
     */
    credentials: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP.OAuth2
 */
export interface Config_HTTP_OAuth2 {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string client_secret = 2;
     */
    clientSecret: string;
    /**
     * @generated from protobuf field: repeated string client_scopes = 3;
     */
    clientScopes: string[];
    /**
     * @generated from protobuf field: string token_url = 4;
     */
    tokenUrl: string;
    /**
     * @generated from protobuf field: map<string, string> endpoint_params = 5;
     */
    endpointParams: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 6;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.HTTP.TLSConfig
 */
export interface Config_HTTP_TLSConfig {
    /**
     * @generated from protobuf field: string key_file = 1;
     */
    keyFile: string;
    /**
     * @generated from protobuf field: string cert_file = 2;
     */
    certFile: string;
    /**
     * @generated from protobuf field: bool insecure_skip_verify = 3;
     */
    insecureSkipVerify: boolean;
}
/**
 * @generated from protobuf message v1.Cluster
 */
export interface Cluster {
}
/**
 * @generated from protobuf message v1.Cluster.Config
 */
export interface Cluster_Config {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: map<string, v1.Cluster.Config.Node> nodes = 2;
     */
    nodes: {
        [key: string]: Cluster_Config_Node;
    };
}
/**
 * @generated from protobuf message v1.Cluster.Config.Node
 */
export interface Cluster_Config_Node {
    /**
     * @generated from protobuf field: v1.Client.Auth account = 1;
     */
    account?: Client_Auth;
    /**
     * True if this node is used to bootstrap the cluster.
     *
     * @generated from protobuf field: bool bootstrap = 2;
     */
    bootstrap: boolean;
    /**
     * @generated from protobuf field: string address = 3;
     */
    address: string;
}
/**
 * @generated from protobuf message v1.Client
 */
export interface Client {
    /**
     * @generated from protobuf field: bytes private_key = 1;
     */
    privateKey: Uint8Array;
    /**
     * Authentication details of vince instances
     *
     * @generated from protobuf field: map<string, v1.Client.Instance> instance = 2;
     */
    instance: {
        [key: string]: Client_Instance;
    };
    /**
     * Map of server_id to instance
     *
     * @generated from protobuf field: map<string, string> server_id = 3;
     */
    serverId: {
        [key: string]: string;
    };
    /**
     * The default auth name to use.
     *
     * @generated from protobuf field: v1.Client.Active active = 4;
     */
    active?: Client_Active;
    /**
     * @generated from protobuf field: map<string, v1.Cluster.Config> clusters = 5;
     */
    clusters: {
        [key: string]: Cluster_Config;
    };
}
/**
 * @generated from protobuf message v1.Client.Instance
 */
export interface Client_Instance {
    /**
     * @generated from protobuf field: map<string, v1.Client.Auth> accounts = 1;
     */
    accounts: {
        [key: string]: Client_Auth;
    };
}
/**
 * @generated from protobuf message v1.Client.Active
 */
export interface Client_Active {
    /**
     * @generated from protobuf field: string instance = 1;
     */
    instance: string;
    /**
     * @generated from protobuf field: string account = 2;
     */
    account: string;
}
/**
 * @generated from protobuf message v1.Client.Auth
 */
export interface Client_Auth {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string token = 2;
     */
    token: string;
    /**
     * @generated from protobuf field: string server_id = 3;
     */
    serverId: string;
}
/**
 * @generated from protobuf message v1.BlockStore
 */
export interface BlockStore {
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "fs";
        /**
         * @generated from protobuf field: v1.BlockStore.Filesystem fs = 1;
         */
        fs: BlockStore_Filesystem;
    } | {
        oneofKind: "s3";
        /**
         * @generated from protobuf field: v1.BlockStore.S3 s3 = 2;
         */
        s3: BlockStore_S3;
    } | {
        oneofKind: "azure";
        /**
         * @generated from protobuf field: v1.BlockStore.Azure azure = 3;
         */
        azure: BlockStore_Azure;
    } | {
        oneofKind: "bos";
        /**
         * @generated from protobuf field: v1.BlockStore.BOS bos = 4;
         */
        bos: BlockStore_BOS;
    } | {
        oneofKind: "cos";
        /**
         * @generated from protobuf field: v1.BlockStore.COS cos = 5;
         */
        cos: BlockStore_COS;
    } | {
        oneofKind: "gcs";
        /**
         * @generated from protobuf field: v1.BlockStore.GCS gcs = 6;
         */
        gcs: BlockStore_GCS;
    } | {
        oneofKind: "obs";
        /**
         * @generated from protobuf field: v1.BlockStore.OBS obs = 7;
         */
        obs: BlockStore_OBS;
    } | {
        oneofKind: "oss";
        /**
         * @generated from protobuf field: v1.BlockStore.OSS oss = 8;
         */
        oss: BlockStore_OSS;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.BlockStore.OSS
 */
export interface BlockStore_OSS {
    /**
     * @generated from protobuf field: string endpoint = 1;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: string bucket = 2;
     */
    bucket: string;
    /**
     * @generated from protobuf field: string access_key_id = 3;
     */
    accessKeyId: string;
    /**
     * @generated from protobuf field: string access_key_secret = 4;
     */
    accessKeySecret: string;
}
/**
 * @generated from protobuf message v1.BlockStore.OBS
 */
export interface BlockStore_OBS {
    /**
     * @generated from protobuf field: string bucket = 1;
     */
    bucket: string;
    /**
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: string access_key = 3;
     */
    accessKey: string;
    /**
     * @generated from protobuf field: string secret_key = 4;
     */
    secretKey: string;
}
/**
 * @generated from protobuf message v1.BlockStore.GCS
 */
export interface BlockStore_GCS {
    /**
     * @generated from protobuf field: string bucket = 1;
     */
    bucket: string;
    /**
     * @generated from protobuf field: string service_account = 2;
     */
    serviceAccount: string;
}
/**
 * @generated from protobuf message v1.BlockStore.COS
 */
export interface BlockStore_COS {
    /**
     * @generated from protobuf field: string bucket = 1;
     */
    bucket: string;
    /**
     * @generated from protobuf field: string region = 2;
     */
    region: string;
    /**
     * @generated from protobuf field: string app_id = 3;
     */
    appId: string;
    /**
     * @generated from protobuf field: string endpoint = 4;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: string secret_key = 5;
     */
    secretKey: string;
    /**
     * @generated from protobuf field: string secret_id = 6;
     */
    secretId: string;
}
/**
 * @generated from protobuf message v1.BlockStore.BOS
 */
export interface BlockStore_BOS {
    /**
     * @generated from protobuf field: string bucket = 1;
     */
    bucket: string;
    /**
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: string access_key = 3;
     */
    accessKey: string;
    /**
     * @generated from protobuf field: string secret_key = 4;
     */
    secretKey: string;
}
/**
 * @generated from protobuf message v1.BlockStore.Azure
 */
export interface BlockStore_Azure {
    /**
     * @generated from protobuf field: string storage_account = 1;
     */
    storageAccount: string;
    /**
     * @generated from protobuf field: string storage_account_key = 2;
     */
    storageAccountKey: string;
    /**
     * @generated from protobuf field: string storage_connection_string = 3;
     */
    storageConnectionString: string;
    /**
     * @generated from protobuf field: string container = 4;
     */
    container: string;
    /**
     * @generated from protobuf field: string endpoint = 5;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: string user_assigned_id = 6;
     */
    userAssignedId: string;
    /**
     * @generated from protobuf field: int32 max_retries = 7;
     */
    maxRetries: number;
    /**
     * @generated from protobuf field: v1.BlockStore.Azure.Reader reader_config = 8;
     */
    readerConfig?: BlockStore_Azure_Reader;
    /**
     * @generated from protobuf field: v1.BlockStore.Azure.Pipeline pipeline_config = 9;
     */
    pipelineConfig?: BlockStore_Azure_Pipeline;
}
/**
 * @generated from protobuf message v1.BlockStore.Azure.Reader
 */
export interface BlockStore_Azure_Reader {
    /**
     * @generated from protobuf field: int32 max_retry_requests = 1;
     */
    maxRetryRequests: number;
}
/**
 * @generated from protobuf message v1.BlockStore.Azure.Pipeline
 */
export interface BlockStore_Azure_Pipeline {
    /**
     * @generated from protobuf field: int32 max_tries = 1;
     */
    maxTries: number;
    /**
     * @generated from protobuf field: google.protobuf.Duration try_timeout = 2;
     */
    tryTimeout?: Duration;
    /**
     * @generated from protobuf field: google.protobuf.Duration retry_delay = 3;
     */
    retryDelay?: Duration;
    /**
     * @generated from protobuf field: google.protobuf.Duration max_retry_delay = 4;
     */
    maxRetryDelay?: Duration;
}
/**
 * @generated from protobuf message v1.BlockStore.Filesystem
 */
export interface BlockStore_Filesystem {
    /**
     * @generated from protobuf field: string directory = 1;
     */
    directory: string;
}
/**
 * @generated from protobuf message v1.BlockStore.S3
 */
export interface BlockStore_S3 {
    /**
     * @generated from protobuf field: string bucket = 1;
     */
    bucket: string;
    /**
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: string region = 3;
     */
    region: string;
    /**
     * @generated from protobuf field: bool aws_sdk_auth = 4;
     */
    awsSdkAuth: boolean;
    /**
     * @generated from protobuf field: string access_key = 5;
     */
    accessKey: string;
    /**
     * @generated from protobuf field: bool insecure = 6;
     */
    insecure: boolean;
    /**
     * @generated from protobuf field: bool signature_version2 = 7;
     */
    signatureVersion2: boolean;
    /**
     * @generated from protobuf field: string secret_key = 8;
     */
    secretKey: string;
    /**
     * @generated from protobuf field: string session_token = 9;
     */
    sessionToken: string;
    /**
     * @generated from protobuf field: map<string, string> put_user_metadata = 10;
     */
    putUserMetadata: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string list_objects_version = 11;
     */
    listObjectsVersion: string;
    /**
     * @generated from protobuf field: v1.BlockStore.S3.BucketLookupType bucket_lookup_type = 12;
     */
    bucketLookupType: BlockStore_S3_BucketLookupType;
    /**
     * @generated from protobuf field: uint64 part_size = 13;
     */
    partSize: bigint;
    /**
     * @generated from protobuf field: v1.BlockStore.S3.SSE sse_config = 14;
     */
    sseConfig?: BlockStore_S3_SSE;
    /**
     * @generated from protobuf field: string sts_endpoint = 15;
     */
    stsEndpoint: string;
}
/**
 * @generated from protobuf message v1.BlockStore.S3.SSE
 */
export interface BlockStore_S3_SSE {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string kms_key_id = 2;
     */
    kmsKeyId: string;
    /**
     * @generated from protobuf field: map<string, string> kms_encryption_context = 3;
     */
    kmsEncryptionContext: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string encryption_key = 4;
     */
    encryptionKey: string;
}
/**
 * @generated from protobuf enum v1.BlockStore.S3.BucketLookupType
 */
export enum BlockStore_S3_BucketLookupType {
    /**
     * @generated from protobuf enum value: AUTO = 0;
     */
    AUTO = 0,
    /**
     * @generated from protobuf enum value: VIRTUAL_HOSTED = 1;
     */
    VIRTUAL_HOSTED = 1,
    /**
     * @generated from protobuf enum value: PATH = 2;
     */
    PATH = 2
}
/**
 * @generated from protobuf message v1.Build
 */
export interface Build {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("v1.Config", [
            { no: 1, name: "db_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocks_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "listen_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "log_level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "sync_interval", kind: "message", T: () => Duration },
            { no: 6, name: "enable_profile", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "mysql_listen_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tls_cert_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "tls_key_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "events_buffer_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "notifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Config_Notifier },
            { no: 12, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "raft_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "allowed_origins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config>): Config {
        const message = { dbPath: "", blocksPath: "", listenAddress: "", logLevel: "", enableProfile: false, mysqlListenAddress: "", tlsCertFile: "", tlsKeyFile: "", eventsBufferSize: 0n, notifiers: [], serverId: "", raftPath: "", allowedOrigins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string db_path */ 1:
                    message.dbPath = reader.string();
                    break;
                case /* string blocks_path */ 2:
                    message.blocksPath = reader.string();
                    break;
                case /* string listen_address */ 3:
                    message.listenAddress = reader.string();
                    break;
                case /* string log_level */ 4:
                    message.logLevel = reader.string();
                    break;
                case /* google.protobuf.Duration sync_interval */ 5:
                    message.syncInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.syncInterval);
                    break;
                case /* bool enable_profile */ 6:
                    message.enableProfile = reader.bool();
                    break;
                case /* string mysql_listen_address */ 7:
                    message.mysqlListenAddress = reader.string();
                    break;
                case /* string tls_cert_file */ 8:
                    message.tlsCertFile = reader.string();
                    break;
                case /* string tls_key_file */ 9:
                    message.tlsKeyFile = reader.string();
                    break;
                case /* int64 events_buffer_size */ 10:
                    message.eventsBufferSize = reader.int64().toBigInt();
                    break;
                case /* repeated v1.Config.Notifier notifiers */ 11:
                    message.notifiers.push(Config_Notifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string server_id */ 12:
                    message.serverId = reader.string();
                    break;
                case /* string raft_path */ 13:
                    message.raftPath = reader.string();
                    break;
                case /* repeated string allowed_origins */ 14:
                    message.allowedOrigins.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string db_path = 1; */
        if (message.dbPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dbPath);
        /* string blocks_path = 2; */
        if (message.blocksPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.blocksPath);
        /* string listen_address = 3; */
        if (message.listenAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.listenAddress);
        /* string log_level = 4; */
        if (message.logLevel !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.logLevel);
        /* google.protobuf.Duration sync_interval = 5; */
        if (message.syncInterval)
            Duration.internalBinaryWrite(message.syncInterval, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_profile = 6; */
        if (message.enableProfile !== false)
            writer.tag(6, WireType.Varint).bool(message.enableProfile);
        /* string mysql_listen_address = 7; */
        if (message.mysqlListenAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.mysqlListenAddress);
        /* string tls_cert_file = 8; */
        if (message.tlsCertFile !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tlsCertFile);
        /* string tls_key_file = 9; */
        if (message.tlsKeyFile !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.tlsKeyFile);
        /* int64 events_buffer_size = 10; */
        if (message.eventsBufferSize !== 0n)
            writer.tag(10, WireType.Varint).int64(message.eventsBufferSize);
        /* repeated v1.Config.Notifier notifiers = 11; */
        for (let i = 0; i < message.notifiers.length; i++)
            Config_Notifier.internalBinaryWrite(message.notifiers[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string server_id = 12; */
        if (message.serverId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.serverId);
        /* string raft_path = 13; */
        if (message.raftPath !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.raftPath);
        /* repeated string allowed_origins = 14; */
        for (let i = 0; i < message.allowedOrigins.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.allowedOrigins[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config
 */
export const Config = new Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Notifier$Type extends MessageType<Config_Notifier> {
    constructor() {
        super("v1.Config.Notifier", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "message", oneof: "provider", T: () => Config_Email },
            { no: 3, name: "webhook", kind: "message", oneof: "provider", T: () => Config_Webhook }
        ]);
    }
    create(value?: PartialMessage<Config_Notifier>): Config_Notifier {
        const message = { name: "", provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Notifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Notifier): Config_Notifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* v1.Config.Email email */ 2:
                    message.provider = {
                        oneofKind: "email",
                        email: Config_Email.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).email)
                    };
                    break;
                case /* v1.Config.Webhook webhook */ 3:
                    message.provider = {
                        oneofKind: "webhook",
                        webhook: Config_Webhook.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).webhook)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_Notifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* v1.Config.Email email = 2; */
        if (message.provider.oneofKind === "email")
            Config_Email.internalBinaryWrite(message.provider.email, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.Webhook webhook = 3; */
        if (message.provider.oneofKind === "webhook")
            Config_Webhook.internalBinaryWrite(message.provider.webhook, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Notifier
 */
export const Config_Notifier = new Config_Notifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Email$Type extends MessageType<Config_Email> {
    constructor() {
        super("v1.Config.Email", [
            { no: 1, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hello", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "host_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "auth_username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "auth_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "auth_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "auth_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 10, name: "html", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "require_tls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_Email>): Config_Email {
        const message = { to: "", from: "", hello: "", hostPort: "", authUsername: "", authPassword: "", authSecret: "", authIdentity: "", headers: {}, html: "", text: "", requireTls: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Email>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Email): Config_Email {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string to */ 1:
                    message.to = reader.string();
                    break;
                case /* string from */ 2:
                    message.from = reader.string();
                    break;
                case /* string hello */ 3:
                    message.hello = reader.string();
                    break;
                case /* string host_port */ 4:
                    message.hostPort = reader.string();
                    break;
                case /* string auth_username */ 5:
                    message.authUsername = reader.string();
                    break;
                case /* string auth_password */ 6:
                    message.authPassword = reader.string();
                    break;
                case /* string auth_secret */ 7:
                    message.authSecret = reader.string();
                    break;
                case /* string auth_identity */ 8:
                    message.authIdentity = reader.string();
                    break;
                case /* map<string, string> headers */ 9:
                    this.binaryReadMap9(message.headers, reader, options);
                    break;
                case /* string html */ 10:
                    message.html = reader.string();
                    break;
                case /* string text */ 11:
                    message.text = reader.string();
                    break;
                case /* bool require_tls */ 12:
                    message.requireTls = reader.bool();
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 13:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: Config_Email["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Config_Email["headers"] | undefined, val: Config_Email["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Config.Email.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Config_Email, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string to = 1; */
        if (message.to !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.to);
        /* string from = 2; */
        if (message.from !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.from);
        /* string hello = 3; */
        if (message.hello !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hello);
        /* string host_port = 4; */
        if (message.hostPort !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hostPort);
        /* string auth_username = 5; */
        if (message.authUsername !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.authUsername);
        /* string auth_password = 6; */
        if (message.authPassword !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.authPassword);
        /* string auth_secret = 7; */
        if (message.authSecret !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.authSecret);
        /* string auth_identity = 8; */
        if (message.authIdentity !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.authIdentity);
        /* map<string, string> headers = 9; */
        for (let k of Object.keys(message.headers))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* string html = 10; */
        if (message.html !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.html);
        /* string text = 11; */
        if (message.text !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.text);
        /* bool require_tls = 12; */
        if (message.requireTls !== false)
            writer.tag(12, WireType.Varint).bool(message.requireTls);
        /* v1.Config.HTTP.TLSConfig tls_config = 13; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Email
 */
export const Config_Email = new Config_Email$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Webhook$Type extends MessageType<Config_Webhook> {
    constructor() {
        super("v1.Config.Webhook", [
            { no: 1, name: "http_config", kind: "message", T: () => Config_HTTP },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_Webhook>): Config_Webhook {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Webhook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Webhook): Config_Webhook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Config.HTTP http_config */ 1:
                    message.httpConfig = Config_HTTP.internalBinaryRead(reader, reader.uint32(), options, message.httpConfig);
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_Webhook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Config.HTTP http_config = 1; */
        if (message.httpConfig)
            Config_HTTP.internalBinaryWrite(message.httpConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Webhook
 */
export const Config_Webhook = new Config_Webhook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP$Type extends MessageType<Config_HTTP> {
    constructor() {
        super("v1.Config.HTTP", [
            { no: 1, name: "basic_auth", kind: "message", T: () => Config_HTTP_BasicAuth },
            { no: 2, name: "authorization", kind: "message", T: () => Config_HTTP_Authorization },
            { no: 3, name: "pauth2", kind: "message", T: () => Config_HTTP_OAuth2 },
            { no: 4, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP>): Config_HTTP {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP): Config_HTTP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Config.HTTP.BasicAuth basic_auth */ 1:
                    message.basicAuth = Config_HTTP_BasicAuth.internalBinaryRead(reader, reader.uint32(), options, message.basicAuth);
                    break;
                case /* v1.Config.HTTP.Authorization authorization */ 2:
                    message.authorization = Config_HTTP_Authorization.internalBinaryRead(reader, reader.uint32(), options, message.authorization);
                    break;
                case /* v1.Config.HTTP.OAuth2 pauth2 */ 3:
                    message.pauth2 = Config_HTTP_OAuth2.internalBinaryRead(reader, reader.uint32(), options, message.pauth2);
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 4:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Config.HTTP.BasicAuth basic_auth = 1; */
        if (message.basicAuth)
            Config_HTTP_BasicAuth.internalBinaryWrite(message.basicAuth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.Authorization authorization = 2; */
        if (message.authorization)
            Config_HTTP_Authorization.internalBinaryWrite(message.authorization, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.OAuth2 pauth2 = 3; */
        if (message.pauth2)
            Config_HTTP_OAuth2.internalBinaryWrite(message.pauth2, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.TLSConfig tls_config = 4; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP
 */
export const Config_HTTP = new Config_HTTP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_BasicAuth$Type extends MessageType<Config_HTTP_BasicAuth> {
    constructor() {
        super("v1.Config.HTTP.BasicAuth", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_BasicAuth>): Config_HTTP_BasicAuth {
        const message = { username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_BasicAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_BasicAuth): Config_HTTP_BasicAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_BasicAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.BasicAuth
 */
export const Config_HTTP_BasicAuth = new Config_HTTP_BasicAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_Authorization$Type extends MessageType<Config_HTTP_Authorization> {
    constructor() {
        super("v1.Config.HTTP.Authorization", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "credentials", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_Authorization>): Config_HTTP_Authorization {
        const message = { type: "", credentials: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_Authorization>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_Authorization): Config_HTTP_Authorization {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string credentials */ 2:
                    message.credentials = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_Authorization, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string credentials = 2; */
        if (message.credentials !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentials);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.Authorization
 */
export const Config_HTTP_Authorization = new Config_HTTP_Authorization$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_OAuth2$Type extends MessageType<Config_HTTP_OAuth2> {
    constructor() {
        super("v1.Config.HTTP.OAuth2", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_scopes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "endpoint_params", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_OAuth2>): Config_HTTP_OAuth2 {
        const message = { clientId: "", clientSecret: "", clientScopes: [], tokenUrl: "", endpointParams: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_OAuth2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_OAuth2): Config_HTTP_OAuth2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string client_secret */ 2:
                    message.clientSecret = reader.string();
                    break;
                case /* repeated string client_scopes */ 3:
                    message.clientScopes.push(reader.string());
                    break;
                case /* string token_url */ 4:
                    message.tokenUrl = reader.string();
                    break;
                case /* map<string, string> endpoint_params */ 5:
                    this.binaryReadMap5(message.endpointParams, reader, options);
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 6:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Config_HTTP_OAuth2["endpointParams"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Config_HTTP_OAuth2["endpointParams"] | undefined, val: Config_HTTP_OAuth2["endpointParams"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Config.HTTP.OAuth2.endpoint_params");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Config_HTTP_OAuth2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string client_secret = 2; */
        if (message.clientSecret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientSecret);
        /* repeated string client_scopes = 3; */
        for (let i = 0; i < message.clientScopes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.clientScopes[i]);
        /* string token_url = 4; */
        if (message.tokenUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenUrl);
        /* map<string, string> endpoint_params = 5; */
        for (let k of Object.keys(message.endpointParams))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.endpointParams[k]).join();
        /* v1.Config.HTTP.TLSConfig tls_config = 6; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.OAuth2
 */
export const Config_HTTP_OAuth2 = new Config_HTTP_OAuth2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_TLSConfig$Type extends MessageType<Config_HTTP_TLSConfig> {
    constructor() {
        super("v1.Config.HTTP.TLSConfig", [
            { no: 1, name: "key_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cert_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "insecure_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_TLSConfig>): Config_HTTP_TLSConfig {
        const message = { keyFile: "", certFile: "", insecureSkipVerify: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_TLSConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_TLSConfig): Config_HTTP_TLSConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key_file */ 1:
                    message.keyFile = reader.string();
                    break;
                case /* string cert_file */ 2:
                    message.certFile = reader.string();
                    break;
                case /* bool insecure_skip_verify */ 3:
                    message.insecureSkipVerify = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_TLSConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key_file = 1; */
        if (message.keyFile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyFile);
        /* string cert_file = 2; */
        if (message.certFile !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.certFile);
        /* bool insecure_skip_verify = 3; */
        if (message.insecureSkipVerify !== false)
            writer.tag(3, WireType.Varint).bool(message.insecureSkipVerify);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.TLSConfig
 */
export const Config_HTTP_TLSConfig = new Config_HTTP_TLSConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster$Type extends MessageType<Cluster> {
    constructor() {
        super("v1.Cluster", []);
    }
    create(value?: PartialMessage<Cluster>): Cluster {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster): Cluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster
 */
export const Cluster = new Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Config$Type extends MessageType<Cluster_Config> {
    constructor() {
        super("v1.Cluster.Config", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nodes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Cluster_Config_Node } }
        ]);
    }
    create(value?: PartialMessage<Cluster_Config>): Cluster_Config {
        const message = { name: "", nodes: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Config): Cluster_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, v1.Cluster.Config.Node> nodes */ 2:
                    this.binaryReadMap2(message.nodes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Cluster_Config["nodes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Cluster_Config["nodes"] | undefined, val: Cluster_Config["nodes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Cluster_Config_Node.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Cluster.Config.nodes");
            }
        }
        map[key ?? ""] = val ?? Cluster_Config_Node.create();
    }
    internalBinaryWrite(message: Cluster_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, v1.Cluster.Config.Node> nodes = 2; */
        for (let k of Object.keys(message.nodes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Cluster_Config_Node.internalBinaryWrite(message.nodes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Config
 */
export const Cluster_Config = new Cluster_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Config_Node$Type extends MessageType<Cluster_Config_Node> {
    constructor() {
        super("v1.Cluster.Config.Node", [
            { no: 1, name: "account", kind: "message", T: () => Client_Auth },
            { no: 2, name: "bootstrap", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cluster_Config_Node>): Cluster_Config_Node {
        const message = { bootstrap: false, address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Config_Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Config_Node): Cluster_Config_Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Client.Auth account */ 1:
                    message.account = Client_Auth.internalBinaryRead(reader, reader.uint32(), options, message.account);
                    break;
                case /* bool bootstrap */ 2:
                    message.bootstrap = reader.bool();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_Config_Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Client.Auth account = 1; */
        if (message.account)
            Client_Auth.internalBinaryWrite(message.account, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool bootstrap = 2; */
        if (message.bootstrap !== false)
            writer.tag(2, WireType.Varint).bool(message.bootstrap);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Config.Node
 */
export const Cluster_Config_Node = new Cluster_Config_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client$Type extends MessageType<Client> {
    constructor() {
        super("v1.Client", [
            { no: 1, name: "private_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "instance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Client_Instance } },
            { no: 3, name: "server_id", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "active", kind: "message", T: () => Client_Active },
            { no: 5, name: "clusters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Cluster_Config } }
        ]);
    }
    create(value?: PartialMessage<Client>): Client {
        const message = { privateKey: new Uint8Array(0), instance: {}, serverId: {}, clusters: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client): Client {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes private_key */ 1:
                    message.privateKey = reader.bytes();
                    break;
                case /* map<string, v1.Client.Instance> instance */ 2:
                    this.binaryReadMap2(message.instance, reader, options);
                    break;
                case /* map<string, string> server_id */ 3:
                    this.binaryReadMap3(message.serverId, reader, options);
                    break;
                case /* v1.Client.Active active */ 4:
                    message.active = Client_Active.internalBinaryRead(reader, reader.uint32(), options, message.active);
                    break;
                case /* map<string, v1.Cluster.Config> clusters */ 5:
                    this.binaryReadMap5(message.clusters, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Client["instance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["instance"] | undefined, val: Client["instance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Client_Instance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.instance");
            }
        }
        map[key ?? ""] = val ?? Client_Instance.create();
    }
    private binaryReadMap3(map: Client["serverId"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["serverId"] | undefined, val: Client["serverId"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.server_id");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: Client["clusters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["clusters"] | undefined, val: Client["clusters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Cluster_Config.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.clusters");
            }
        }
        map[key ?? ""] = val ?? Cluster_Config.create();
    }
    internalBinaryWrite(message: Client, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes private_key = 1; */
        if (message.privateKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.privateKey);
        /* map<string, v1.Client.Instance> instance = 2; */
        for (let k of Object.keys(message.instance)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Client_Instance.internalBinaryWrite(message.instance[k], writer, options);
            writer.join().join();
        }
        /* map<string, string> server_id = 3; */
        for (let k of Object.keys(message.serverId))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.serverId[k]).join();
        /* v1.Client.Active active = 4; */
        if (message.active)
            Client_Active.internalBinaryWrite(message.active, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, v1.Cluster.Config> clusters = 5; */
        for (let k of Object.keys(message.clusters)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Cluster_Config.internalBinaryWrite(message.clusters[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client
 */
export const Client = new Client$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Instance$Type extends MessageType<Client_Instance> {
    constructor() {
        super("v1.Client.Instance", [
            { no: 1, name: "accounts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Client_Auth } }
        ]);
    }
    create(value?: PartialMessage<Client_Instance>): Client_Instance {
        const message = { accounts: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Instance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Instance): Client_Instance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, v1.Client.Auth> accounts */ 1:
                    this.binaryReadMap1(message.accounts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Client_Instance["accounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client_Instance["accounts"] | undefined, val: Client_Instance["accounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Client_Auth.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.Instance.accounts");
            }
        }
        map[key ?? ""] = val ?? Client_Auth.create();
    }
    internalBinaryWrite(message: Client_Instance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, v1.Client.Auth> accounts = 1; */
        for (let k of Object.keys(message.accounts)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Client_Auth.internalBinaryWrite(message.accounts[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Instance
 */
export const Client_Instance = new Client_Instance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Active$Type extends MessageType<Client_Active> {
    constructor() {
        super("v1.Client.Active", [
            { no: 1, name: "instance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client_Active>): Client_Active {
        const message = { instance: "", account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Active>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Active): Client_Active {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instance */ 1:
                    message.instance = reader.string();
                    break;
                case /* string account */ 2:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client_Active, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instance = 1; */
        if (message.instance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instance);
        /* string account = 2; */
        if (message.account !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Active
 */
export const Client_Active = new Client_Active$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Auth$Type extends MessageType<Client_Auth> {
    constructor() {
        super("v1.Client.Auth", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client_Auth>): Client_Auth {
        const message = { name: "", token: "", serverId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Auth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Auth): Client_Auth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                case /* string server_id */ 3:
                    message.serverId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client_Auth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* string server_id = 3; */
        if (message.serverId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Auth
 */
export const Client_Auth = new Client_Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore$Type extends MessageType<BlockStore> {
    constructor() {
        super("v1.BlockStore", [
            { no: 1, name: "fs", kind: "message", oneof: "provider", T: () => BlockStore_Filesystem },
            { no: 2, name: "s3", kind: "message", oneof: "provider", T: () => BlockStore_S3 },
            { no: 3, name: "azure", kind: "message", oneof: "provider", T: () => BlockStore_Azure },
            { no: 4, name: "bos", kind: "message", oneof: "provider", T: () => BlockStore_BOS },
            { no: 5, name: "cos", kind: "message", oneof: "provider", T: () => BlockStore_COS },
            { no: 6, name: "gcs", kind: "message", oneof: "provider", T: () => BlockStore_GCS },
            { no: 7, name: "obs", kind: "message", oneof: "provider", T: () => BlockStore_OBS },
            { no: 8, name: "oss", kind: "message", oneof: "provider", T: () => BlockStore_OSS }
        ]);
    }
    create(value?: PartialMessage<BlockStore>): BlockStore {
        const message = { provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore): BlockStore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.BlockStore.Filesystem fs */ 1:
                    message.provider = {
                        oneofKind: "fs",
                        fs: BlockStore_Filesystem.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).fs)
                    };
                    break;
                case /* v1.BlockStore.S3 s3 */ 2:
                    message.provider = {
                        oneofKind: "s3",
                        s3: BlockStore_S3.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).s3)
                    };
                    break;
                case /* v1.BlockStore.Azure azure */ 3:
                    message.provider = {
                        oneofKind: "azure",
                        azure: BlockStore_Azure.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).azure)
                    };
                    break;
                case /* v1.BlockStore.BOS bos */ 4:
                    message.provider = {
                        oneofKind: "bos",
                        bos: BlockStore_BOS.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).bos)
                    };
                    break;
                case /* v1.BlockStore.COS cos */ 5:
                    message.provider = {
                        oneofKind: "cos",
                        cos: BlockStore_COS.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).cos)
                    };
                    break;
                case /* v1.BlockStore.GCS gcs */ 6:
                    message.provider = {
                        oneofKind: "gcs",
                        gcs: BlockStore_GCS.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).gcs)
                    };
                    break;
                case /* v1.BlockStore.OBS obs */ 7:
                    message.provider = {
                        oneofKind: "obs",
                        obs: BlockStore_OBS.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).obs)
                    };
                    break;
                case /* v1.BlockStore.OSS oss */ 8:
                    message.provider = {
                        oneofKind: "oss",
                        oss: BlockStore_OSS.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).oss)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.BlockStore.Filesystem fs = 1; */
        if (message.provider.oneofKind === "fs")
            BlockStore_Filesystem.internalBinaryWrite(message.provider.fs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.S3 s3 = 2; */
        if (message.provider.oneofKind === "s3")
            BlockStore_S3.internalBinaryWrite(message.provider.s3, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.Azure azure = 3; */
        if (message.provider.oneofKind === "azure")
            BlockStore_Azure.internalBinaryWrite(message.provider.azure, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.BOS bos = 4; */
        if (message.provider.oneofKind === "bos")
            BlockStore_BOS.internalBinaryWrite(message.provider.bos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.COS cos = 5; */
        if (message.provider.oneofKind === "cos")
            BlockStore_COS.internalBinaryWrite(message.provider.cos, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.GCS gcs = 6; */
        if (message.provider.oneofKind === "gcs")
            BlockStore_GCS.internalBinaryWrite(message.provider.gcs, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.OBS obs = 7; */
        if (message.provider.oneofKind === "obs")
            BlockStore_OBS.internalBinaryWrite(message.provider.obs, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.OSS oss = 8; */
        if (message.provider.oneofKind === "oss")
            BlockStore_OSS.internalBinaryWrite(message.provider.oss, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore
 */
export const BlockStore = new BlockStore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_OSS$Type extends MessageType<BlockStore_OSS> {
    constructor() {
        super("v1.BlockStore.OSS", [
            { no: 1, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "access_key_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access_key_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_OSS>): BlockStore_OSS {
        const message = { endpoint: "", bucket: "", accessKeyId: "", accessKeySecret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_OSS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_OSS): BlockStore_OSS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string endpoint */ 1:
                    message.endpoint = reader.string();
                    break;
                case /* string bucket */ 2:
                    message.bucket = reader.string();
                    break;
                case /* string access_key_id */ 3:
                    message.accessKeyId = reader.string();
                    break;
                case /* string access_key_secret */ 4:
                    message.accessKeySecret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_OSS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string endpoint = 1; */
        if (message.endpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.endpoint);
        /* string bucket = 2; */
        if (message.bucket !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bucket);
        /* string access_key_id = 3; */
        if (message.accessKeyId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accessKeyId);
        /* string access_key_secret = 4; */
        if (message.accessKeySecret !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessKeySecret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.OSS
 */
export const BlockStore_OSS = new BlockStore_OSS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_OBS$Type extends MessageType<BlockStore_OBS> {
    constructor() {
        super("v1.BlockStore.OBS", [
            { no: 1, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "access_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_OBS>): BlockStore_OBS {
        const message = { bucket: "", endpoint: "", accessKey: "", secretKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_OBS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_OBS): BlockStore_OBS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket */ 1:
                    message.bucket = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* string access_key */ 3:
                    message.accessKey = reader.string();
                    break;
                case /* string secret_key */ 4:
                    message.secretKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_OBS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket = 1; */
        if (message.bucket !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucket);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* string access_key = 3; */
        if (message.accessKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accessKey);
        /* string secret_key = 4; */
        if (message.secretKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.secretKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.OBS
 */
export const BlockStore_OBS = new BlockStore_OBS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_GCS$Type extends MessageType<BlockStore_GCS> {
    constructor() {
        super("v1.BlockStore.GCS", [
            { no: 1, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "service_account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_GCS>): BlockStore_GCS {
        const message = { bucket: "", serviceAccount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_GCS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_GCS): BlockStore_GCS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket */ 1:
                    message.bucket = reader.string();
                    break;
                case /* string service_account */ 2:
                    message.serviceAccount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_GCS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket = 1; */
        if (message.bucket !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucket);
        /* string service_account = 2; */
        if (message.serviceAccount !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceAccount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.GCS
 */
export const BlockStore_GCS = new BlockStore_GCS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_COS$Type extends MessageType<BlockStore_COS> {
    constructor() {
        super("v1.BlockStore.COS", [
            { no: 1, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "secret_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_COS>): BlockStore_COS {
        const message = { bucket: "", region: "", appId: "", endpoint: "", secretKey: "", secretId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_COS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_COS): BlockStore_COS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket */ 1:
                    message.bucket = reader.string();
                    break;
                case /* string region */ 2:
                    message.region = reader.string();
                    break;
                case /* string app_id */ 3:
                    message.appId = reader.string();
                    break;
                case /* string endpoint */ 4:
                    message.endpoint = reader.string();
                    break;
                case /* string secret_key */ 5:
                    message.secretKey = reader.string();
                    break;
                case /* string secret_id */ 6:
                    message.secretId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_COS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket = 1; */
        if (message.bucket !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucket);
        /* string region = 2; */
        if (message.region !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.region);
        /* string app_id = 3; */
        if (message.appId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appId);
        /* string endpoint = 4; */
        if (message.endpoint !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endpoint);
        /* string secret_key = 5; */
        if (message.secretKey !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.secretKey);
        /* string secret_id = 6; */
        if (message.secretId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.secretId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.COS
 */
export const BlockStore_COS = new BlockStore_COS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_BOS$Type extends MessageType<BlockStore_BOS> {
    constructor() {
        super("v1.BlockStore.BOS", [
            { no: 1, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "access_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_BOS>): BlockStore_BOS {
        const message = { bucket: "", endpoint: "", accessKey: "", secretKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_BOS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_BOS): BlockStore_BOS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket */ 1:
                    message.bucket = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* string access_key */ 3:
                    message.accessKey = reader.string();
                    break;
                case /* string secret_key */ 4:
                    message.secretKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_BOS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket = 1; */
        if (message.bucket !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucket);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* string access_key = 3; */
        if (message.accessKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accessKey);
        /* string secret_key = 4; */
        if (message.secretKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.secretKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.BOS
 */
export const BlockStore_BOS = new BlockStore_BOS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_Azure$Type extends MessageType<BlockStore_Azure> {
    constructor() {
        super("v1.BlockStore.Azure", [
            { no: 1, name: "storage_account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "storage_account_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "storage_connection_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "container", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "user_assigned_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "max_retries", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "reader_config", kind: "message", T: () => BlockStore_Azure_Reader },
            { no: 9, name: "pipeline_config", kind: "message", T: () => BlockStore_Azure_Pipeline }
        ]);
    }
    create(value?: PartialMessage<BlockStore_Azure>): BlockStore_Azure {
        const message = { storageAccount: "", storageAccountKey: "", storageConnectionString: "", container: "", endpoint: "", userAssignedId: "", maxRetries: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_Azure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_Azure): BlockStore_Azure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string storage_account */ 1:
                    message.storageAccount = reader.string();
                    break;
                case /* string storage_account_key */ 2:
                    message.storageAccountKey = reader.string();
                    break;
                case /* string storage_connection_string */ 3:
                    message.storageConnectionString = reader.string();
                    break;
                case /* string container */ 4:
                    message.container = reader.string();
                    break;
                case /* string endpoint */ 5:
                    message.endpoint = reader.string();
                    break;
                case /* string user_assigned_id */ 6:
                    message.userAssignedId = reader.string();
                    break;
                case /* int32 max_retries */ 7:
                    message.maxRetries = reader.int32();
                    break;
                case /* v1.BlockStore.Azure.Reader reader_config */ 8:
                    message.readerConfig = BlockStore_Azure_Reader.internalBinaryRead(reader, reader.uint32(), options, message.readerConfig);
                    break;
                case /* v1.BlockStore.Azure.Pipeline pipeline_config */ 9:
                    message.pipelineConfig = BlockStore_Azure_Pipeline.internalBinaryRead(reader, reader.uint32(), options, message.pipelineConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_Azure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string storage_account = 1; */
        if (message.storageAccount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.storageAccount);
        /* string storage_account_key = 2; */
        if (message.storageAccountKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.storageAccountKey);
        /* string storage_connection_string = 3; */
        if (message.storageConnectionString !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.storageConnectionString);
        /* string container = 4; */
        if (message.container !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.container);
        /* string endpoint = 5; */
        if (message.endpoint !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.endpoint);
        /* string user_assigned_id = 6; */
        if (message.userAssignedId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userAssignedId);
        /* int32 max_retries = 7; */
        if (message.maxRetries !== 0)
            writer.tag(7, WireType.Varint).int32(message.maxRetries);
        /* v1.BlockStore.Azure.Reader reader_config = 8; */
        if (message.readerConfig)
            BlockStore_Azure_Reader.internalBinaryWrite(message.readerConfig, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* v1.BlockStore.Azure.Pipeline pipeline_config = 9; */
        if (message.pipelineConfig)
            BlockStore_Azure_Pipeline.internalBinaryWrite(message.pipelineConfig, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.Azure
 */
export const BlockStore_Azure = new BlockStore_Azure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_Azure_Reader$Type extends MessageType<BlockStore_Azure_Reader> {
    constructor() {
        super("v1.BlockStore.Azure.Reader", [
            { no: 1, name: "max_retry_requests", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_Azure_Reader>): BlockStore_Azure_Reader {
        const message = { maxRetryRequests: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_Azure_Reader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_Azure_Reader): BlockStore_Azure_Reader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 max_retry_requests */ 1:
                    message.maxRetryRequests = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_Azure_Reader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 max_retry_requests = 1; */
        if (message.maxRetryRequests !== 0)
            writer.tag(1, WireType.Varint).int32(message.maxRetryRequests);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.Azure.Reader
 */
export const BlockStore_Azure_Reader = new BlockStore_Azure_Reader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_Azure_Pipeline$Type extends MessageType<BlockStore_Azure_Pipeline> {
    constructor() {
        super("v1.BlockStore.Azure.Pipeline", [
            { no: 1, name: "max_tries", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "try_timeout", kind: "message", T: () => Duration },
            { no: 3, name: "retry_delay", kind: "message", T: () => Duration },
            { no: 4, name: "max_retry_delay", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<BlockStore_Azure_Pipeline>): BlockStore_Azure_Pipeline {
        const message = { maxTries: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_Azure_Pipeline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_Azure_Pipeline): BlockStore_Azure_Pipeline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 max_tries */ 1:
                    message.maxTries = reader.int32();
                    break;
                case /* google.protobuf.Duration try_timeout */ 2:
                    message.tryTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.tryTimeout);
                    break;
                case /* google.protobuf.Duration retry_delay */ 3:
                    message.retryDelay = Duration.internalBinaryRead(reader, reader.uint32(), options, message.retryDelay);
                    break;
                case /* google.protobuf.Duration max_retry_delay */ 4:
                    message.maxRetryDelay = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxRetryDelay);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_Azure_Pipeline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 max_tries = 1; */
        if (message.maxTries !== 0)
            writer.tag(1, WireType.Varint).int32(message.maxTries);
        /* google.protobuf.Duration try_timeout = 2; */
        if (message.tryTimeout)
            Duration.internalBinaryWrite(message.tryTimeout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration retry_delay = 3; */
        if (message.retryDelay)
            Duration.internalBinaryWrite(message.retryDelay, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_retry_delay = 4; */
        if (message.maxRetryDelay)
            Duration.internalBinaryWrite(message.maxRetryDelay, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.Azure.Pipeline
 */
export const BlockStore_Azure_Pipeline = new BlockStore_Azure_Pipeline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_Filesystem$Type extends MessageType<BlockStore_Filesystem> {
    constructor() {
        super("v1.BlockStore.Filesystem", [
            { no: 1, name: "directory", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_Filesystem>): BlockStore_Filesystem {
        const message = { directory: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_Filesystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_Filesystem): BlockStore_Filesystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string directory */ 1:
                    message.directory = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockStore_Filesystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string directory = 1; */
        if (message.directory !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.directory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.Filesystem
 */
export const BlockStore_Filesystem = new BlockStore_Filesystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_S3$Type extends MessageType<BlockStore_S3> {
    constructor() {
        super("v1.BlockStore.S3", [
            { no: 1, name: "bucket", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "aws_sdk_auth", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "access_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "insecure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "signature_version2", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "session_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "put_user_metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 11, name: "list_objects_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "bucket_lookup_type", kind: "enum", T: () => ["v1.BlockStore.S3.BucketLookupType", BlockStore_S3_BucketLookupType] },
            { no: 13, name: "part_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "sse_config", kind: "message", T: () => BlockStore_S3_SSE },
            { no: 15, name: "sts_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_S3>): BlockStore_S3 {
        const message = { bucket: "", endpoint: "", region: "", awsSdkAuth: false, accessKey: "", insecure: false, signatureVersion2: false, secretKey: "", sessionToken: "", putUserMetadata: {}, listObjectsVersion: "", bucketLookupType: 0, partSize: 0n, stsEndpoint: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_S3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_S3): BlockStore_S3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket */ 1:
                    message.bucket = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* string region */ 3:
                    message.region = reader.string();
                    break;
                case /* bool aws_sdk_auth */ 4:
                    message.awsSdkAuth = reader.bool();
                    break;
                case /* string access_key */ 5:
                    message.accessKey = reader.string();
                    break;
                case /* bool insecure */ 6:
                    message.insecure = reader.bool();
                    break;
                case /* bool signature_version2 */ 7:
                    message.signatureVersion2 = reader.bool();
                    break;
                case /* string secret_key */ 8:
                    message.secretKey = reader.string();
                    break;
                case /* string session_token */ 9:
                    message.sessionToken = reader.string();
                    break;
                case /* map<string, string> put_user_metadata */ 10:
                    this.binaryReadMap10(message.putUserMetadata, reader, options);
                    break;
                case /* string list_objects_version */ 11:
                    message.listObjectsVersion = reader.string();
                    break;
                case /* v1.BlockStore.S3.BucketLookupType bucket_lookup_type */ 12:
                    message.bucketLookupType = reader.int32();
                    break;
                case /* uint64 part_size */ 13:
                    message.partSize = reader.uint64().toBigInt();
                    break;
                case /* v1.BlockStore.S3.SSE sse_config */ 14:
                    message.sseConfig = BlockStore_S3_SSE.internalBinaryRead(reader, reader.uint32(), options, message.sseConfig);
                    break;
                case /* string sts_endpoint */ 15:
                    message.stsEndpoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: BlockStore_S3["putUserMetadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof BlockStore_S3["putUserMetadata"] | undefined, val: BlockStore_S3["putUserMetadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.BlockStore.S3.put_user_metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: BlockStore_S3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket = 1; */
        if (message.bucket !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucket);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* string region = 3; */
        if (message.region !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.region);
        /* bool aws_sdk_auth = 4; */
        if (message.awsSdkAuth !== false)
            writer.tag(4, WireType.Varint).bool(message.awsSdkAuth);
        /* string access_key = 5; */
        if (message.accessKey !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accessKey);
        /* bool insecure = 6; */
        if (message.insecure !== false)
            writer.tag(6, WireType.Varint).bool(message.insecure);
        /* bool signature_version2 = 7; */
        if (message.signatureVersion2 !== false)
            writer.tag(7, WireType.Varint).bool(message.signatureVersion2);
        /* string secret_key = 8; */
        if (message.secretKey !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.secretKey);
        /* string session_token = 9; */
        if (message.sessionToken !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.sessionToken);
        /* map<string, string> put_user_metadata = 10; */
        for (let k of Object.keys(message.putUserMetadata))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.putUserMetadata[k]).join();
        /* string list_objects_version = 11; */
        if (message.listObjectsVersion !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.listObjectsVersion);
        /* v1.BlockStore.S3.BucketLookupType bucket_lookup_type = 12; */
        if (message.bucketLookupType !== 0)
            writer.tag(12, WireType.Varint).int32(message.bucketLookupType);
        /* uint64 part_size = 13; */
        if (message.partSize !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.partSize);
        /* v1.BlockStore.S3.SSE sse_config = 14; */
        if (message.sseConfig)
            BlockStore_S3_SSE.internalBinaryWrite(message.sseConfig, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string sts_endpoint = 15; */
        if (message.stsEndpoint !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.stsEndpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.S3
 */
export const BlockStore_S3 = new BlockStore_S3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockStore_S3_SSE$Type extends MessageType<BlockStore_S3_SSE> {
    constructor() {
        super("v1.BlockStore.S3.SSE", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kms_key_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "kms_encryption_context", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "encryption_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockStore_S3_SSE>): BlockStore_S3_SSE {
        const message = { type: "", kmsKeyId: "", kmsEncryptionContext: {}, encryptionKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockStore_S3_SSE>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockStore_S3_SSE): BlockStore_S3_SSE {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string kms_key_id */ 2:
                    message.kmsKeyId = reader.string();
                    break;
                case /* map<string, string> kms_encryption_context */ 3:
                    this.binaryReadMap3(message.kmsEncryptionContext, reader, options);
                    break;
                case /* string encryption_key */ 4:
                    message.encryptionKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: BlockStore_S3_SSE["kmsEncryptionContext"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof BlockStore_S3_SSE["kmsEncryptionContext"] | undefined, val: BlockStore_S3_SSE["kmsEncryptionContext"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.BlockStore.S3.SSE.kms_encryption_context");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: BlockStore_S3_SSE, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string kms_key_id = 2; */
        if (message.kmsKeyId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kmsKeyId);
        /* map<string, string> kms_encryption_context = 3; */
        for (let k of Object.keys(message.kmsEncryptionContext))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.kmsEncryptionContext[k]).join();
        /* string encryption_key = 4; */
        if (message.encryptionKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.encryptionKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.BlockStore.S3.SSE
 */
export const BlockStore_S3_SSE = new BlockStore_S3_SSE$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Build$Type extends MessageType<Build> {
    constructor() {
        super("v1.Build", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Build>): Build {
        const message = { version: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Build>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Build): Build {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Build, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Build
 */
export const Build = new Build$Type();
