// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "vince/config/v1/config.proto" (package "v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../google/protobuf/duration";
/**
 * Configuration object for vince instance
 *
 * @generated from protobuf message v1.Config
 */
export interface Config {
    /**
     * Path to the main badger database.
     *
     * @generated from protobuf field: string db_path = 1;
     */
    dbPath: string;
    /**
     * Path to where block files are stored. Blocks are stored as files with ULID
     * as filenames
     *
     * @generated from protobuf field: string blocks_path = 2;
     */
    blocksPath: string;
    /**
     * host:port to bind for http api. This is used by serve command. The server
     * serves ui console
     *
     * @generated from protobuf field: string listen_address = 3;
     */
    listenAddress: string;
    /**
     * Control how much is logged options are
     * trace,debug,info,warn,error,fatal,panic
     *
     * @generated from protobuf field: string log_level = 4;
     */
    logLevel: string;
    /**
     * Interval for syncing buffered entries. By default events are buffered and
     * periodically saved.
     *
     * @generated from protobuf field: google.protobuf.Duration sync_interval = 5;
     */
    syncInterval?: Duration;
    /**
     * Expose /debug/pprof endpoint when serving
     *
     * @generated from protobuf field: bool enable_profile = 6;
     */
    enableProfile: boolean;
    /**
     * host:port to bind myslq server. Serves web analytics via MySQL compliant
     * wire protocol.
     *
     * @generated from protobuf field: string mysql_listen_address = 7;
     */
    mysqlListenAddress: string;
    /**
     * @generated from protobuf field: string tls_cert_file = 8;
     */
    tlsCertFile: string;
    /**
     * @generated from protobuf field: string tls_key_file = 9;
     */
    tlsKeyFile: string;
    /**
     * @generated from protobuf field: int64 events_buffer_size = 10;
     */
    eventsBufferSize: bigint;
    /**
     * @generated from protobuf field: repeated v1.Config.Notifier notifiers = 11;
     */
    notifiers: Config_Notifier[];
    /**
     * @generated from protobuf field: string server_id = 12;
     */
    serverId: string;
    /**
     * @generated from protobuf field: string raft_path = 13;
     */
    raftPath: string;
    /**
     * @generated from protobuf field: repeated string allowed_origins = 14;
     */
    allowedOrigins: string[];
}
/**
 * @generated from protobuf message v1.Config.Notifier
 */
export interface Config_Notifier {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: provider
     */
    provider: {
        oneofKind: "email";
        /**
         * @generated from protobuf field: v1.Config.Email email = 2;
         */
        email: Config_Email;
    } | {
        oneofKind: "webhook";
        /**
         * @generated from protobuf field: v1.Config.Webhook webhook = 3;
         */
        webhook: Config_Webhook;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.Config.Email
 */
export interface Config_Email {
    /**
     * @generated from protobuf field: string to = 1;
     */
    to: string;
    /**
     * @generated from protobuf field: string from = 2;
     */
    from: string;
    /**
     * @generated from protobuf field: string hello = 3;
     */
    hello: string;
    /**
     * @generated from protobuf field: string host_port = 4;
     */
    hostPort: string;
    /**
     * @generated from protobuf field: string auth_username = 5;
     */
    authUsername: string;
    /**
     * @generated from protobuf field: string auth_password = 6;
     */
    authPassword: string;
    /**
     * @generated from protobuf field: string auth_secret = 7;
     */
    authSecret: string;
    /**
     * @generated from protobuf field: string auth_identity = 8;
     */
    authIdentity: string;
    /**
     * @generated from protobuf field: map<string, string> headers = 9;
     */
    headers: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: string html = 10;
     */
    html: string;
    /**
     * @generated from protobuf field: string text = 11;
     */
    text: string;
    /**
     * @generated from protobuf field: bool require_tls = 12;
     */
    requireTls: boolean;
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 13;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.Webhook
 */
export interface Config_Webhook {
    /**
     * @generated from protobuf field: v1.Config.HTTP http_config = 1;
     */
    httpConfig?: Config_HTTP;
    /**
     * @generated from protobuf field: string url = 2;
     */
    url: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP
 */
export interface Config_HTTP {
    /**
     * @generated from protobuf field: v1.Config.HTTP.BasicAuth basic_auth = 1;
     */
    basicAuth?: Config_HTTP_BasicAuth;
    /**
     * @generated from protobuf field: v1.Config.HTTP.Authorization authorization = 2;
     */
    authorization?: Config_HTTP_Authorization;
    /**
     * @generated from protobuf field: v1.Config.HTTP.OAuth2 pauth2 = 3;
     */
    pauth2?: Config_HTTP_OAuth2;
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 4;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.HTTP.BasicAuth
 */
export interface Config_HTTP_BasicAuth {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP.Authorization
 */
export interface Config_HTTP_Authorization {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string credentials = 2;
     */
    credentials: string;
}
/**
 * @generated from protobuf message v1.Config.HTTP.OAuth2
 */
export interface Config_HTTP_OAuth2 {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string client_secret = 2;
     */
    clientSecret: string;
    /**
     * @generated from protobuf field: repeated string client_scopes = 3;
     */
    clientScopes: string[];
    /**
     * @generated from protobuf field: string token_url = 4;
     */
    tokenUrl: string;
    /**
     * @generated from protobuf field: map<string, string> endpoint_params = 5;
     */
    endpointParams: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: v1.Config.HTTP.TLSConfig tls_config = 6;
     */
    tlsConfig?: Config_HTTP_TLSConfig;
}
/**
 * @generated from protobuf message v1.Config.HTTP.TLSConfig
 */
export interface Config_HTTP_TLSConfig {
    /**
     * @generated from protobuf field: string key_file = 1;
     */
    keyFile: string;
    /**
     * @generated from protobuf field: string cert_file = 2;
     */
    certFile: string;
    /**
     * @generated from protobuf field: bool insecure_skip_verify = 3;
     */
    insecureSkipVerify: boolean;
}
/**
 * @generated from protobuf message v1.Cluster
 */
export interface Cluster {
}
/**
 * @generated from protobuf message v1.Cluster.Config
 */
export interface Cluster_Config {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: map<string, v1.Cluster.Config.Node> nodes = 2;
     */
    nodes: {
        [key: string]: Cluster_Config_Node;
    };
}
/**
 * @generated from protobuf message v1.Cluster.Config.Node
 */
export interface Cluster_Config_Node {
    /**
     * @generated from protobuf field: v1.Client.Auth account = 1;
     */
    account?: Client_Auth;
    /**
     * True if this node is used to bootstrap the cluster.
     *
     * @generated from protobuf field: bool bootstrap = 2;
     */
    bootstrap: boolean;
    /**
     * @generated from protobuf field: string address = 3;
     */
    address: string;
}
/**
 * @generated from protobuf message v1.Client
 */
export interface Client {
    /**
     * @generated from protobuf field: bytes private_key = 1;
     */
    privateKey: Uint8Array;
    /**
     * Authentication details of vince instances
     *
     * @generated from protobuf field: map<string, v1.Client.Instance> instance = 2;
     */
    instance: {
        [key: string]: Client_Instance;
    };
    /**
     * Map of server_id to instance
     *
     * @generated from protobuf field: map<string, string> server_id = 3;
     */
    serverId: {
        [key: string]: string;
    };
    /**
     * The default auth name to use.
     *
     * @generated from protobuf field: v1.Client.Active active = 4;
     */
    active?: Client_Active;
    /**
     * @generated from protobuf field: map<string, v1.Cluster.Config> clusters = 5;
     */
    clusters: {
        [key: string]: Cluster_Config;
    };
}
/**
 * @generated from protobuf message v1.Client.Instance
 */
export interface Client_Instance {
    /**
     * @generated from protobuf field: map<string, v1.Client.Auth> accounts = 1;
     */
    accounts: {
        [key: string]: Client_Auth;
    };
}
/**
 * @generated from protobuf message v1.Client.Active
 */
export interface Client_Active {
    /**
     * @generated from protobuf field: string instance = 1;
     */
    instance: string;
    /**
     * @generated from protobuf field: string account = 2;
     */
    account: string;
}
/**
 * @generated from protobuf message v1.Client.Auth
 */
export interface Client_Auth {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string token = 2;
     */
    token: string;
    /**
     * @generated from protobuf field: string server_id = 3;
     */
    serverId: string;
}
/**
 * @generated from protobuf message v1.Build
 */
export interface Build {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("v1.Config", [
            { no: 1, name: "db_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocks_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "listen_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "log_level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "sync_interval", kind: "message", T: () => Duration },
            { no: 6, name: "enable_profile", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "mysql_listen_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tls_cert_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "tls_key_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "events_buffer_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "notifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Config_Notifier },
            { no: 12, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "raft_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "allowed_origins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config>): Config {
        const message = { dbPath: "", blocksPath: "", listenAddress: "", logLevel: "", enableProfile: false, mysqlListenAddress: "", tlsCertFile: "", tlsKeyFile: "", eventsBufferSize: 0n, notifiers: [], serverId: "", raftPath: "", allowedOrigins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string db_path */ 1:
                    message.dbPath = reader.string();
                    break;
                case /* string blocks_path */ 2:
                    message.blocksPath = reader.string();
                    break;
                case /* string listen_address */ 3:
                    message.listenAddress = reader.string();
                    break;
                case /* string log_level */ 4:
                    message.logLevel = reader.string();
                    break;
                case /* google.protobuf.Duration sync_interval */ 5:
                    message.syncInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.syncInterval);
                    break;
                case /* bool enable_profile */ 6:
                    message.enableProfile = reader.bool();
                    break;
                case /* string mysql_listen_address */ 7:
                    message.mysqlListenAddress = reader.string();
                    break;
                case /* string tls_cert_file */ 8:
                    message.tlsCertFile = reader.string();
                    break;
                case /* string tls_key_file */ 9:
                    message.tlsKeyFile = reader.string();
                    break;
                case /* int64 events_buffer_size */ 10:
                    message.eventsBufferSize = reader.int64().toBigInt();
                    break;
                case /* repeated v1.Config.Notifier notifiers */ 11:
                    message.notifiers.push(Config_Notifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string server_id */ 12:
                    message.serverId = reader.string();
                    break;
                case /* string raft_path */ 13:
                    message.raftPath = reader.string();
                    break;
                case /* repeated string allowed_origins */ 14:
                    message.allowedOrigins.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string db_path = 1; */
        if (message.dbPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dbPath);
        /* string blocks_path = 2; */
        if (message.blocksPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.blocksPath);
        /* string listen_address = 3; */
        if (message.listenAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.listenAddress);
        /* string log_level = 4; */
        if (message.logLevel !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.logLevel);
        /* google.protobuf.Duration sync_interval = 5; */
        if (message.syncInterval)
            Duration.internalBinaryWrite(message.syncInterval, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_profile = 6; */
        if (message.enableProfile !== false)
            writer.tag(6, WireType.Varint).bool(message.enableProfile);
        /* string mysql_listen_address = 7; */
        if (message.mysqlListenAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.mysqlListenAddress);
        /* string tls_cert_file = 8; */
        if (message.tlsCertFile !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tlsCertFile);
        /* string tls_key_file = 9; */
        if (message.tlsKeyFile !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.tlsKeyFile);
        /* int64 events_buffer_size = 10; */
        if (message.eventsBufferSize !== 0n)
            writer.tag(10, WireType.Varint).int64(message.eventsBufferSize);
        /* repeated v1.Config.Notifier notifiers = 11; */
        for (let i = 0; i < message.notifiers.length; i++)
            Config_Notifier.internalBinaryWrite(message.notifiers[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string server_id = 12; */
        if (message.serverId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.serverId);
        /* string raft_path = 13; */
        if (message.raftPath !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.raftPath);
        /* repeated string allowed_origins = 14; */
        for (let i = 0; i < message.allowedOrigins.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.allowedOrigins[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config
 */
export const Config = new Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Notifier$Type extends MessageType<Config_Notifier> {
    constructor() {
        super("v1.Config.Notifier", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "message", oneof: "provider", T: () => Config_Email },
            { no: 3, name: "webhook", kind: "message", oneof: "provider", T: () => Config_Webhook }
        ]);
    }
    create(value?: PartialMessage<Config_Notifier>): Config_Notifier {
        const message = { name: "", provider: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Notifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Notifier): Config_Notifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* v1.Config.Email email */ 2:
                    message.provider = {
                        oneofKind: "email",
                        email: Config_Email.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).email)
                    };
                    break;
                case /* v1.Config.Webhook webhook */ 3:
                    message.provider = {
                        oneofKind: "webhook",
                        webhook: Config_Webhook.internalBinaryRead(reader, reader.uint32(), options, (message.provider as any).webhook)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_Notifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* v1.Config.Email email = 2; */
        if (message.provider.oneofKind === "email")
            Config_Email.internalBinaryWrite(message.provider.email, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.Webhook webhook = 3; */
        if (message.provider.oneofKind === "webhook")
            Config_Webhook.internalBinaryWrite(message.provider.webhook, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Notifier
 */
export const Config_Notifier = new Config_Notifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Email$Type extends MessageType<Config_Email> {
    constructor() {
        super("v1.Config.Email", [
            { no: 1, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hello", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "host_port", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "auth_username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "auth_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "auth_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "auth_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 10, name: "html", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "require_tls", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_Email>): Config_Email {
        const message = { to: "", from: "", hello: "", hostPort: "", authUsername: "", authPassword: "", authSecret: "", authIdentity: "", headers: {}, html: "", text: "", requireTls: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Email>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Email): Config_Email {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string to */ 1:
                    message.to = reader.string();
                    break;
                case /* string from */ 2:
                    message.from = reader.string();
                    break;
                case /* string hello */ 3:
                    message.hello = reader.string();
                    break;
                case /* string host_port */ 4:
                    message.hostPort = reader.string();
                    break;
                case /* string auth_username */ 5:
                    message.authUsername = reader.string();
                    break;
                case /* string auth_password */ 6:
                    message.authPassword = reader.string();
                    break;
                case /* string auth_secret */ 7:
                    message.authSecret = reader.string();
                    break;
                case /* string auth_identity */ 8:
                    message.authIdentity = reader.string();
                    break;
                case /* map<string, string> headers */ 9:
                    this.binaryReadMap9(message.headers, reader, options);
                    break;
                case /* string html */ 10:
                    message.html = reader.string();
                    break;
                case /* string text */ 11:
                    message.text = reader.string();
                    break;
                case /* bool require_tls */ 12:
                    message.requireTls = reader.bool();
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 13:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: Config_Email["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Config_Email["headers"] | undefined, val: Config_Email["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Config.Email.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Config_Email, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string to = 1; */
        if (message.to !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.to);
        /* string from = 2; */
        if (message.from !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.from);
        /* string hello = 3; */
        if (message.hello !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hello);
        /* string host_port = 4; */
        if (message.hostPort !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hostPort);
        /* string auth_username = 5; */
        if (message.authUsername !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.authUsername);
        /* string auth_password = 6; */
        if (message.authPassword !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.authPassword);
        /* string auth_secret = 7; */
        if (message.authSecret !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.authSecret);
        /* string auth_identity = 8; */
        if (message.authIdentity !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.authIdentity);
        /* map<string, string> headers = 9; */
        for (let k of Object.keys(message.headers))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        /* string html = 10; */
        if (message.html !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.html);
        /* string text = 11; */
        if (message.text !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.text);
        /* bool require_tls = 12; */
        if (message.requireTls !== false)
            writer.tag(12, WireType.Varint).bool(message.requireTls);
        /* v1.Config.HTTP.TLSConfig tls_config = 13; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Email
 */
export const Config_Email = new Config_Email$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_Webhook$Type extends MessageType<Config_Webhook> {
    constructor() {
        super("v1.Config.Webhook", [
            { no: 1, name: "http_config", kind: "message", T: () => Config_HTTP },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_Webhook>): Config_Webhook {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_Webhook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_Webhook): Config_Webhook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Config.HTTP http_config */ 1:
                    message.httpConfig = Config_HTTP.internalBinaryRead(reader, reader.uint32(), options, message.httpConfig);
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_Webhook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Config.HTTP http_config = 1; */
        if (message.httpConfig)
            Config_HTTP.internalBinaryWrite(message.httpConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.Webhook
 */
export const Config_Webhook = new Config_Webhook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP$Type extends MessageType<Config_HTTP> {
    constructor() {
        super("v1.Config.HTTP", [
            { no: 1, name: "basic_auth", kind: "message", T: () => Config_HTTP_BasicAuth },
            { no: 2, name: "authorization", kind: "message", T: () => Config_HTTP_Authorization },
            { no: 3, name: "pauth2", kind: "message", T: () => Config_HTTP_OAuth2 },
            { no: 4, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP>): Config_HTTP {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP): Config_HTTP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Config.HTTP.BasicAuth basic_auth */ 1:
                    message.basicAuth = Config_HTTP_BasicAuth.internalBinaryRead(reader, reader.uint32(), options, message.basicAuth);
                    break;
                case /* v1.Config.HTTP.Authorization authorization */ 2:
                    message.authorization = Config_HTTP_Authorization.internalBinaryRead(reader, reader.uint32(), options, message.authorization);
                    break;
                case /* v1.Config.HTTP.OAuth2 pauth2 */ 3:
                    message.pauth2 = Config_HTTP_OAuth2.internalBinaryRead(reader, reader.uint32(), options, message.pauth2);
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 4:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Config.HTTP.BasicAuth basic_auth = 1; */
        if (message.basicAuth)
            Config_HTTP_BasicAuth.internalBinaryWrite(message.basicAuth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.Authorization authorization = 2; */
        if (message.authorization)
            Config_HTTP_Authorization.internalBinaryWrite(message.authorization, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.OAuth2 pauth2 = 3; */
        if (message.pauth2)
            Config_HTTP_OAuth2.internalBinaryWrite(message.pauth2, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Config.HTTP.TLSConfig tls_config = 4; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP
 */
export const Config_HTTP = new Config_HTTP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_BasicAuth$Type extends MessageType<Config_HTTP_BasicAuth> {
    constructor() {
        super("v1.Config.HTTP.BasicAuth", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_BasicAuth>): Config_HTTP_BasicAuth {
        const message = { username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_BasicAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_BasicAuth): Config_HTTP_BasicAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_BasicAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.BasicAuth
 */
export const Config_HTTP_BasicAuth = new Config_HTTP_BasicAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_Authorization$Type extends MessageType<Config_HTTP_Authorization> {
    constructor() {
        super("v1.Config.HTTP.Authorization", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "credentials", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_Authorization>): Config_HTTP_Authorization {
        const message = { type: "", credentials: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_Authorization>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_Authorization): Config_HTTP_Authorization {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string credentials */ 2:
                    message.credentials = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_Authorization, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string credentials = 2; */
        if (message.credentials !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentials);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.Authorization
 */
export const Config_HTTP_Authorization = new Config_HTTP_Authorization$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_OAuth2$Type extends MessageType<Config_HTTP_OAuth2> {
    constructor() {
        super("v1.Config.HTTP.OAuth2", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_scopes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "endpoint_params", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "tls_config", kind: "message", T: () => Config_HTTP_TLSConfig }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_OAuth2>): Config_HTTP_OAuth2 {
        const message = { clientId: "", clientSecret: "", clientScopes: [], tokenUrl: "", endpointParams: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_OAuth2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_OAuth2): Config_HTTP_OAuth2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string client_secret */ 2:
                    message.clientSecret = reader.string();
                    break;
                case /* repeated string client_scopes */ 3:
                    message.clientScopes.push(reader.string());
                    break;
                case /* string token_url */ 4:
                    message.tokenUrl = reader.string();
                    break;
                case /* map<string, string> endpoint_params */ 5:
                    this.binaryReadMap5(message.endpointParams, reader, options);
                    break;
                case /* v1.Config.HTTP.TLSConfig tls_config */ 6:
                    message.tlsConfig = Config_HTTP_TLSConfig.internalBinaryRead(reader, reader.uint32(), options, message.tlsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Config_HTTP_OAuth2["endpointParams"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Config_HTTP_OAuth2["endpointParams"] | undefined, val: Config_HTTP_OAuth2["endpointParams"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Config.HTTP.OAuth2.endpoint_params");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Config_HTTP_OAuth2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string client_secret = 2; */
        if (message.clientSecret !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientSecret);
        /* repeated string client_scopes = 3; */
        for (let i = 0; i < message.clientScopes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.clientScopes[i]);
        /* string token_url = 4; */
        if (message.tokenUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenUrl);
        /* map<string, string> endpoint_params = 5; */
        for (let k of Object.keys(message.endpointParams))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.endpointParams[k]).join();
        /* v1.Config.HTTP.TLSConfig tls_config = 6; */
        if (message.tlsConfig)
            Config_HTTP_TLSConfig.internalBinaryWrite(message.tlsConfig, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.OAuth2
 */
export const Config_HTTP_OAuth2 = new Config_HTTP_OAuth2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config_HTTP_TLSConfig$Type extends MessageType<Config_HTTP_TLSConfig> {
    constructor() {
        super("v1.Config.HTTP.TLSConfig", [
            { no: 1, name: "key_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cert_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "insecure_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Config_HTTP_TLSConfig>): Config_HTTP_TLSConfig {
        const message = { keyFile: "", certFile: "", insecureSkipVerify: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config_HTTP_TLSConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config_HTTP_TLSConfig): Config_HTTP_TLSConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key_file */ 1:
                    message.keyFile = reader.string();
                    break;
                case /* string cert_file */ 2:
                    message.certFile = reader.string();
                    break;
                case /* bool insecure_skip_verify */ 3:
                    message.insecureSkipVerify = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config_HTTP_TLSConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key_file = 1; */
        if (message.keyFile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyFile);
        /* string cert_file = 2; */
        if (message.certFile !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.certFile);
        /* bool insecure_skip_verify = 3; */
        if (message.insecureSkipVerify !== false)
            writer.tag(3, WireType.Varint).bool(message.insecureSkipVerify);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Config.HTTP.TLSConfig
 */
export const Config_HTTP_TLSConfig = new Config_HTTP_TLSConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster$Type extends MessageType<Cluster> {
    constructor() {
        super("v1.Cluster", []);
    }
    create(value?: PartialMessage<Cluster>): Cluster {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster): Cluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster
 */
export const Cluster = new Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Config$Type extends MessageType<Cluster_Config> {
    constructor() {
        super("v1.Cluster.Config", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nodes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Cluster_Config_Node } }
        ]);
    }
    create(value?: PartialMessage<Cluster_Config>): Cluster_Config {
        const message = { name: "", nodes: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Config): Cluster_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, v1.Cluster.Config.Node> nodes */ 2:
                    this.binaryReadMap2(message.nodes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Cluster_Config["nodes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Cluster_Config["nodes"] | undefined, val: Cluster_Config["nodes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Cluster_Config_Node.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Cluster.Config.nodes");
            }
        }
        map[key ?? ""] = val ?? Cluster_Config_Node.create();
    }
    internalBinaryWrite(message: Cluster_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, v1.Cluster.Config.Node> nodes = 2; */
        for (let k of Object.keys(message.nodes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Cluster_Config_Node.internalBinaryWrite(message.nodes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Config
 */
export const Cluster_Config = new Cluster_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cluster_Config_Node$Type extends MessageType<Cluster_Config_Node> {
    constructor() {
        super("v1.Cluster.Config.Node", [
            { no: 1, name: "account", kind: "message", T: () => Client_Auth },
            { no: 2, name: "bootstrap", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cluster_Config_Node>): Cluster_Config_Node {
        const message = { bootstrap: false, address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cluster_Config_Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster_Config_Node): Cluster_Config_Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Client.Auth account */ 1:
                    message.account = Client_Auth.internalBinaryRead(reader, reader.uint32(), options, message.account);
                    break;
                case /* bool bootstrap */ 2:
                    message.bootstrap = reader.bool();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster_Config_Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Client.Auth account = 1; */
        if (message.account)
            Client_Auth.internalBinaryWrite(message.account, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool bootstrap = 2; */
        if (message.bootstrap !== false)
            writer.tag(2, WireType.Varint).bool(message.bootstrap);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Cluster.Config.Node
 */
export const Cluster_Config_Node = new Cluster_Config_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client$Type extends MessageType<Client> {
    constructor() {
        super("v1.Client", [
            { no: 1, name: "private_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "instance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Client_Instance } },
            { no: 3, name: "server_id", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "active", kind: "message", T: () => Client_Active },
            { no: 5, name: "clusters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Cluster_Config } }
        ]);
    }
    create(value?: PartialMessage<Client>): Client {
        const message = { privateKey: new Uint8Array(0), instance: {}, serverId: {}, clusters: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client): Client {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes private_key */ 1:
                    message.privateKey = reader.bytes();
                    break;
                case /* map<string, v1.Client.Instance> instance */ 2:
                    this.binaryReadMap2(message.instance, reader, options);
                    break;
                case /* map<string, string> server_id */ 3:
                    this.binaryReadMap3(message.serverId, reader, options);
                    break;
                case /* v1.Client.Active active */ 4:
                    message.active = Client_Active.internalBinaryRead(reader, reader.uint32(), options, message.active);
                    break;
                case /* map<string, v1.Cluster.Config> clusters */ 5:
                    this.binaryReadMap5(message.clusters, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Client["instance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["instance"] | undefined, val: Client["instance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Client_Instance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.instance");
            }
        }
        map[key ?? ""] = val ?? Client_Instance.create();
    }
    private binaryReadMap3(map: Client["serverId"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["serverId"] | undefined, val: Client["serverId"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.server_id");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: Client["clusters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client["clusters"] | undefined, val: Client["clusters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Cluster_Config.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.clusters");
            }
        }
        map[key ?? ""] = val ?? Cluster_Config.create();
    }
    internalBinaryWrite(message: Client, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes private_key = 1; */
        if (message.privateKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.privateKey);
        /* map<string, v1.Client.Instance> instance = 2; */
        for (let k of Object.keys(message.instance)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Client_Instance.internalBinaryWrite(message.instance[k], writer, options);
            writer.join().join();
        }
        /* map<string, string> server_id = 3; */
        for (let k of Object.keys(message.serverId))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.serverId[k]).join();
        /* v1.Client.Active active = 4; */
        if (message.active)
            Client_Active.internalBinaryWrite(message.active, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, v1.Cluster.Config> clusters = 5; */
        for (let k of Object.keys(message.clusters)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Cluster_Config.internalBinaryWrite(message.clusters[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client
 */
export const Client = new Client$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Instance$Type extends MessageType<Client_Instance> {
    constructor() {
        super("v1.Client.Instance", [
            { no: 1, name: "accounts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Client_Auth } }
        ]);
    }
    create(value?: PartialMessage<Client_Instance>): Client_Instance {
        const message = { accounts: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Instance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Instance): Client_Instance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, v1.Client.Auth> accounts */ 1:
                    this.binaryReadMap1(message.accounts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Client_Instance["accounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Client_Instance["accounts"] | undefined, val: Client_Instance["accounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Client_Auth.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field v1.Client.Instance.accounts");
            }
        }
        map[key ?? ""] = val ?? Client_Auth.create();
    }
    internalBinaryWrite(message: Client_Instance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, v1.Client.Auth> accounts = 1; */
        for (let k of Object.keys(message.accounts)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Client_Auth.internalBinaryWrite(message.accounts[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Instance
 */
export const Client_Instance = new Client_Instance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Active$Type extends MessageType<Client_Active> {
    constructor() {
        super("v1.Client.Active", [
            { no: 1, name: "instance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client_Active>): Client_Active {
        const message = { instance: "", account: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Active>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Active): Client_Active {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instance */ 1:
                    message.instance = reader.string();
                    break;
                case /* string account */ 2:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client_Active, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instance = 1; */
        if (message.instance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instance);
        /* string account = 2; */
        if (message.account !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Active
 */
export const Client_Active = new Client_Active$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client_Auth$Type extends MessageType<Client_Auth> {
    constructor() {
        super("v1.Client.Auth", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client_Auth>): Client_Auth {
        const message = { name: "", token: "", serverId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Client_Auth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client_Auth): Client_Auth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                case /* string server_id */ 3:
                    message.serverId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client_Auth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* string server_id = 3; */
        if (message.serverId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Client.Auth
 */
export const Client_Auth = new Client_Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Build$Type extends MessageType<Build> {
    constructor() {
        super("v1.Build", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Build>): Build {
        const message = { version: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Build>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Build): Build {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Build, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Build
 */
export const Build = new Build$Type();
