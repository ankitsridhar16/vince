// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "vince/raft/v1/raft.proto" (package "v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Duration } from "../../../google/protobuf/duration";
/**
 * @generated from protobuf message v1.RaftConfig
 */
export interface RaftConfig {
    /**
     * @generated from protobuf field: repeated v1.RaftServer servers = 1;
     */
    servers: RaftServer[];
}
/**
 * @generated from protobuf message v1.RaftServer
 */
export interface RaftServer {
    /**
     * @generated from protobuf field: v1.RaftServer.Suffrage suffrage = 1;
     */
    suffrage: RaftServer_Suffrage;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * @generated from protobuf field: string token = 4;
     */
    token: string;
}
/**
 * @generated from protobuf enum v1.RaftServer.Suffrage
 */
export enum RaftServer_Suffrage {
    /**
     * @generated from protobuf enum value: Voter = 0;
     */
    Voter = 0,
    /**
     * @generated from protobuf enum value: Nonvoter = 1;
     */
    Nonvoter = 1,
    /**
     * @generated from protobuf enum value: Staging = 2;
     */
    Staging = 2
}
/**
 * @generated from protobuf message v1.RaftEntry
 */
export interface RaftEntry {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Duration expires = 3;
     */
    expires?: Duration;
}
/**
 * @generated from protobuf message v1.AppendEntriesRequest
 */
export interface AppendEntriesRequest {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 prev_log_entry = 4;
     */
    prevLogEntry: bigint;
    /**
     * @generated from protobuf field: uint64 prev_log_term = 5;
     */
    prevLogTerm: bigint;
    /**
     * @generated from protobuf field: repeated v1.RaftLog entries = 6;
     */
    entries: RaftLog[];
    /**
     * @generated from protobuf field: uint64 leader_commit_index = 7;
     */
    leaderCommitIndex: bigint;
}
/**
 * @generated from protobuf message v1.RaftLog
 */
export interface RaftLog {
    /**
     * @generated from protobuf field: uint64 index = 1;
     */
    index: bigint;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: v1.RaftLog.Type type = 3;
     */
    type: RaftLog_Type;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes extensions = 5;
     */
    extensions: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp appended_at = 6;
     */
    appendedAt?: Timestamp;
}
/**
 * @generated from protobuf enum v1.RaftLog.Type
 */
export enum RaftLog_Type {
    /**
     * @generated from protobuf enum value: Command = 0;
     */
    Command = 0,
    /**
     * @generated from protobuf enum value: Noop = 1;
     */
    Noop = 1,
    /**
     * @generated from protobuf enum value: AddPeerDeprecated = 2;
     */
    AddPeerDeprecated = 2,
    /**
     * @generated from protobuf enum value: RemovePeerDeprecated = 3;
     */
    RemovePeerDeprecated = 3,
    /**
     * @generated from protobuf enum value: Barrier = 4;
     */
    Barrier = 4,
    /**
     * @generated from protobuf enum value: Configuration = 5;
     */
    Configuration = 5
}
/**
 * @generated from protobuf message v1.AppendEntriesResponse
 */
export interface AppendEntriesResponse {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 last_log = 3;
     */
    lastLog: bigint;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
    /**
     * @generated from protobuf field: bool no_retry_backoff = 5;
     */
    noRetryBackoff: boolean;
}
/**
 * @generated from protobuf message v1.RequestVoteRequest
 */
export interface RequestVoteRequest {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_index = 3;
     */
    lastLogIndex: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_term = 4;
     */
    lastLogTerm: bigint;
    /**
     * @generated from protobuf field: bool leadership_transfer = 5;
     */
    leadershipTransfer: boolean;
}
/**
 * @generated from protobuf message v1.RequestVoteResponse
 */
export interface RequestVoteResponse {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bool granted = 3;
     */
    granted: boolean;
}
/**
 * @generated from protobuf message v1.InstallSnapshotRequest
 */
export interface InstallSnapshotRequest {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: v1.InstallSnapshotRequest.Version snapshot_version = 2;
     */
    snapshotVersion: InstallSnapshotRequest_Version;
    /**
     * @generated from protobuf field: uint64 term = 3;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bytes leader = 4;
     */
    leader: Uint8Array;
    /**
     * @generated from protobuf field: uint64 last_log_index = 5;
     */
    lastLogIndex: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_term = 6;
     */
    lastLogTerm: bigint;
    /**
     * @generated from protobuf field: bytes configuration = 7;
     */
    configuration: Uint8Array;
    /**
     * @generated from protobuf field: uint64 configuration_index = 8;
     */
    configurationIndex: bigint;
    /**
     * @generated from protobuf field: int64 size = 9;
     */
    size: bigint;
    /**
     * @generated from protobuf field: bytes data = 10;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf enum v1.InstallSnapshotRequest.Version
 */
export enum InstallSnapshotRequest_Version {
    /**
     * @generated from protobuf enum value: Min = 0;
     */
    Min = 0,
    /**
     * @generated from protobuf enum value: Max = 1;
     */
    Max = 1
}
/**
 * @generated from protobuf message v1.InstallSnapshotResponse
 */
export interface InstallSnapshotResponse {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bool success = 3;
     */
    success: boolean;
}
/**
 * @generated from protobuf message v1.TimeoutNowRequest
 */
export interface TimeoutNowRequest {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
}
/**
 * @generated from protobuf message v1.TimeoutNowResponse
 */
export interface TimeoutNowResponse {
    /**
     * @generated from protobuf field: v1.Header header = 1;
     */
    header?: Header;
}
/**
 * @generated from protobuf message v1.Header
 */
export interface Header {
    /**
     * @generated from protobuf field: v1.Header.Version version = 1;
     */
    version: Header_Version;
    /**
     * @generated from protobuf field: bytes id = 2;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: bytes addr = 3;
     */
    addr: Uint8Array;
}
/**
 * @generated from protobuf enum v1.Header.Version
 */
export enum Header_Version {
    /**
     * @generated from protobuf enum value: Min = 0;
     */
    Min = 0,
    /**
     * @generated from protobuf enum value: Max = 1;
     */
    Max = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class RaftConfig$Type extends MessageType<RaftConfig> {
    constructor() {
        super("v1.RaftConfig", [
            { no: 1, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RaftServer }
        ]);
    }
    create(value?: PartialMessage<RaftConfig>): RaftConfig {
        const message = { servers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RaftConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaftConfig): RaftConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated v1.RaftServer servers */ 1:
                    message.servers.push(RaftServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaftConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated v1.RaftServer servers = 1; */
        for (let i = 0; i < message.servers.length; i++)
            RaftServer.internalBinaryWrite(message.servers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.RaftConfig
 */
export const RaftConfig = new RaftConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaftServer$Type extends MessageType<RaftServer> {
    constructor() {
        super("v1.RaftServer", [
            { no: 1, name: "suffrage", kind: "enum", T: () => ["v1.RaftServer.Suffrage", RaftServer_Suffrage] },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RaftServer>): RaftServer {
        const message = { suffrage: 0, id: "", address: "", token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RaftServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaftServer): RaftServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.RaftServer.Suffrage suffrage */ 1:
                    message.suffrage = reader.int32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* string token */ 4:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaftServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.RaftServer.Suffrage suffrage = 1; */
        if (message.suffrage !== 0)
            writer.tag(1, WireType.Varint).int32(message.suffrage);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* string token = 4; */
        if (message.token !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.RaftServer
 */
export const RaftServer = new RaftServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaftEntry$Type extends MessageType<RaftEntry> {
    constructor() {
        super("v1.RaftEntry", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "expires", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<RaftEntry>): RaftEntry {
        const message = { key: new Uint8Array(0), value: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RaftEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaftEntry): RaftEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* google.protobuf.Duration expires */ 3:
                    message.expires = Duration.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaftEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* google.protobuf.Duration expires = 3; */
        if (message.expires)
            Duration.internalBinaryWrite(message.expires, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.RaftEntry
 */
export const RaftEntry = new RaftEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppendEntriesRequest$Type extends MessageType<AppendEntriesRequest> {
    constructor() {
        super("v1.AppendEntriesRequest", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "prev_log_entry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "prev_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RaftLog },
            { no: 7, name: "leader_commit_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AppendEntriesRequest>): AppendEntriesRequest {
        const message = { term: 0n, prevLogEntry: 0n, prevLogTerm: 0n, entries: [], leaderCommitIndex: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppendEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppendEntriesRequest): AppendEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 prev_log_entry */ 4:
                    message.prevLogEntry = reader.uint64().toBigInt();
                    break;
                case /* uint64 prev_log_term */ 5:
                    message.prevLogTerm = reader.uint64().toBigInt();
                    break;
                case /* repeated v1.RaftLog entries */ 6:
                    message.entries.push(RaftLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 leader_commit_index */ 7:
                    message.leaderCommitIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppendEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 prev_log_entry = 4; */
        if (message.prevLogEntry !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.prevLogEntry);
        /* uint64 prev_log_term = 5; */
        if (message.prevLogTerm !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.prevLogTerm);
        /* repeated v1.RaftLog entries = 6; */
        for (let i = 0; i < message.entries.length; i++)
            RaftLog.internalBinaryWrite(message.entries[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 leader_commit_index = 7; */
        if (message.leaderCommitIndex !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.leaderCommitIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.AppendEntriesRequest
 */
export const AppendEntriesRequest = new AppendEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaftLog$Type extends MessageType<RaftLog> {
    constructor() {
        super("v1.RaftLog", [
            { no: 1, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["v1.RaftLog.Type", RaftLog_Type] },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "extensions", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "appended_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<RaftLog>): RaftLog {
        const message = { index: 0n, term: 0n, type: 0, data: new Uint8Array(0), extensions: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RaftLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaftLog): RaftLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 index */ 1:
                    message.index = reader.uint64().toBigInt();
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* v1.RaftLog.Type type */ 3:
                    message.type = reader.int32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* bytes extensions */ 5:
                    message.extensions = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp appended_at */ 6:
                    message.appendedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.appendedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaftLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 index = 1; */
        if (message.index !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.index);
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* v1.RaftLog.Type type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* bytes extensions = 5; */
        if (message.extensions.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.extensions);
        /* google.protobuf.Timestamp appended_at = 6; */
        if (message.appendedAt)
            Timestamp.internalBinaryWrite(message.appendedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.RaftLog
 */
export const RaftLog = new RaftLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppendEntriesResponse$Type extends MessageType<AppendEntriesResponse> {
    constructor() {
        super("v1.AppendEntriesResponse", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_log", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "no_retry_backoff", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppendEntriesResponse>): AppendEntriesResponse {
        const message = { term: 0n, lastLog: 0n, success: false, noRetryBackoff: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppendEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppendEntriesResponse): AppendEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log */ 3:
                    message.lastLog = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                case /* bool no_retry_backoff */ 5:
                    message.noRetryBackoff = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppendEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 last_log = 3; */
        if (message.lastLog !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastLog);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        /* bool no_retry_backoff = 5; */
        if (message.noRetryBackoff !== false)
            writer.tag(5, WireType.Varint).bool(message.noRetryBackoff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.AppendEntriesResponse
 */
export const AppendEntriesResponse = new AppendEntriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestVoteRequest$Type extends MessageType<RequestVoteRequest> {
    constructor() {
        super("v1.RequestVoteRequest", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_log_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "leadership_transfer", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RequestVoteRequest>): RequestVoteRequest {
        const message = { term: 0n, lastLogIndex: 0n, lastLogTerm: 0n, leadershipTransfer: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestVoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestVoteRequest): RequestVoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_index */ 3:
                    message.lastLogIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_term */ 4:
                    message.lastLogTerm = reader.uint64().toBigInt();
                    break;
                case /* bool leadership_transfer */ 5:
                    message.leadershipTransfer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestVoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 last_log_index = 3; */
        if (message.lastLogIndex !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastLogIndex);
        /* uint64 last_log_term = 4; */
        if (message.lastLogTerm !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.lastLogTerm);
        /* bool leadership_transfer = 5; */
        if (message.leadershipTransfer !== false)
            writer.tag(5, WireType.Varint).bool(message.leadershipTransfer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.RequestVoteRequest
 */
export const RequestVoteRequest = new RequestVoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestVoteResponse$Type extends MessageType<RequestVoteResponse> {
    constructor() {
        super("v1.RequestVoteResponse", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "granted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RequestVoteResponse>): RequestVoteResponse {
        const message = { term: 0n, granted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestVoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestVoteResponse): RequestVoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bool granted */ 3:
                    message.granted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestVoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* bool granted = 3; */
        if (message.granted !== false)
            writer.tag(3, WireType.Varint).bool(message.granted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.RequestVoteResponse
 */
export const RequestVoteResponse = new RequestVoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstallSnapshotRequest$Type extends MessageType<InstallSnapshotRequest> {
    constructor() {
        super("v1.InstallSnapshotRequest", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "snapshot_version", kind: "enum", T: () => ["v1.InstallSnapshotRequest.Version", InstallSnapshotRequest_Version] },
            { no: 3, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "leader", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "last_log_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "last_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "configuration", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "configuration_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<InstallSnapshotRequest>): InstallSnapshotRequest {
        const message = { snapshotVersion: 0, term: 0n, leader: new Uint8Array(0), lastLogIndex: 0n, lastLogTerm: 0n, configuration: new Uint8Array(0), configurationIndex: 0n, size: 0n, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstallSnapshotRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstallSnapshotRequest): InstallSnapshotRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* v1.InstallSnapshotRequest.Version snapshot_version */ 2:
                    message.snapshotVersion = reader.int32();
                    break;
                case /* uint64 term */ 3:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bytes leader */ 4:
                    message.leader = reader.bytes();
                    break;
                case /* uint64 last_log_index */ 5:
                    message.lastLogIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_term */ 6:
                    message.lastLogTerm = reader.uint64().toBigInt();
                    break;
                case /* bytes configuration */ 7:
                    message.configuration = reader.bytes();
                    break;
                case /* uint64 configuration_index */ 8:
                    message.configurationIndex = reader.uint64().toBigInt();
                    break;
                case /* int64 size */ 9:
                    message.size = reader.int64().toBigInt();
                    break;
                case /* bytes data */ 10:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstallSnapshotRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.InstallSnapshotRequest.Version snapshot_version = 2; */
        if (message.snapshotVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.snapshotVersion);
        /* uint64 term = 3; */
        if (message.term !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.term);
        /* bytes leader = 4; */
        if (message.leader.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.leader);
        /* uint64 last_log_index = 5; */
        if (message.lastLogIndex !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.lastLogIndex);
        /* uint64 last_log_term = 6; */
        if (message.lastLogTerm !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.lastLogTerm);
        /* bytes configuration = 7; */
        if (message.configuration.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.configuration);
        /* uint64 configuration_index = 8; */
        if (message.configurationIndex !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.configurationIndex);
        /* int64 size = 9; */
        if (message.size !== 0n)
            writer.tag(9, WireType.Varint).int64(message.size);
        /* bytes data = 10; */
        if (message.data.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.InstallSnapshotRequest
 */
export const InstallSnapshotRequest = new InstallSnapshotRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstallSnapshotResponse$Type extends MessageType<InstallSnapshotResponse> {
    constructor() {
        super("v1.InstallSnapshotResponse", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InstallSnapshotResponse>): InstallSnapshotResponse {
        const message = { term: 0n, success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstallSnapshotResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstallSnapshotResponse): InstallSnapshotResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 3:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstallSnapshotResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* bool success = 3; */
        if (message.success !== false)
            writer.tag(3, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.InstallSnapshotResponse
 */
export const InstallSnapshotResponse = new InstallSnapshotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeoutNowRequest$Type extends MessageType<TimeoutNowRequest> {
    constructor() {
        super("v1.TimeoutNowRequest", [
            { no: 1, name: "header", kind: "message", T: () => Header }
        ]);
    }
    create(value?: PartialMessage<TimeoutNowRequest>): TimeoutNowRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeoutNowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeoutNowRequest): TimeoutNowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeoutNowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.TimeoutNowRequest
 */
export const TimeoutNowRequest = new TimeoutNowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeoutNowResponse$Type extends MessageType<TimeoutNowResponse> {
    constructor() {
        super("v1.TimeoutNowResponse", [
            { no: 1, name: "header", kind: "message", T: () => Header }
        ]);
    }
    create(value?: PartialMessage<TimeoutNowResponse>): TimeoutNowResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeoutNowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeoutNowResponse): TimeoutNowResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeoutNowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.TimeoutNowResponse
 */
export const TimeoutNowResponse = new TimeoutNowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType<Header> {
    constructor() {
        super("v1.Header", [
            { no: 1, name: "version", kind: "enum", T: () => ["v1.Header.Version", Header_Version] },
            { no: 2, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = { version: 0, id: new Uint8Array(0), addr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Header.Version version */ 1:
                    message.version = reader.int32();
                    break;
                case /* bytes id */ 2:
                    message.id = reader.bytes();
                    break;
                case /* bytes addr */ 3:
                    message.addr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Header.Version version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).int32(message.version);
        /* bytes id = 2; */
        if (message.id.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.id);
        /* bytes addr = 3; */
        if (message.addr.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Header
 */
export const Header = new Header$Type();
/**
 * @generated ServiceType for protobuf service v1.Transport
 */
export const Transport = new ServiceType("v1.Transport", [
    { name: "AppendEntriesPipeline", serverStreaming: true, clientStreaming: true, options: {}, I: AppendEntriesRequest, O: AppendEntriesResponse },
    { name: "AppendEntries", options: {}, I: AppendEntriesRequest, O: AppendEntriesResponse },
    { name: "RequestVote", options: {}, I: RequestVoteRequest, O: RequestVoteResponse },
    { name: "TimeoutNow", options: {}, I: TimeoutNowRequest, O: TimeoutNowResponse },
    { name: "InstallSnapshot", clientStreaming: true, options: {}, I: InstallSnapshotRequest, O: InstallSnapshotResponse }
]);
