// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "vince/raft/v1/raft.proto" (package "v1", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Duration } from "../../../google/protobuf/duration";
/**
 * @generated from protobuf message v1.Raft
 */
export interface Raft {
}
/**
 * @generated from protobuf message v1.Raft.Entry
 */
export interface Raft_Entry {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Duration expires = 3;
     */
    expires?: Duration;
}
/**
 * @generated from protobuf message v1.Raft.Log
 */
export interface Raft_Log {
    /**
     * @generated from protobuf field: uint64 index = 1;
     */
    index: bigint;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: v1.Raft.Log.Type type = 3;
     */
    type: Raft_Log_Type;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes extensions = 5;
     */
    extensions: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp appended_at = 6;
     */
    appendedAt?: Timestamp;
}
/**
 * @generated from protobuf enum v1.Raft.Log.Type
 */
export enum Raft_Log_Type {
    /**
     * @generated from protobuf enum value: Command = 0;
     */
    Command = 0,
    /**
     * @generated from protobuf enum value: Noop = 1;
     */
    Noop = 1,
    /**
     * @generated from protobuf enum value: AddPeerDeprecated = 2;
     */
    AddPeerDeprecated = 2,
    /**
     * @generated from protobuf enum value: RemovePeerDeprecated = 3;
     */
    RemovePeerDeprecated = 3,
    /**
     * @generated from protobuf enum value: Barrier = 4;
     */
    Barrier = 4,
    /**
     * @generated from protobuf enum value: Configuration = 5;
     */
    Configuration = 5
}
/**
 * @generated from protobuf message v1.Raft.Config
 */
export interface Raft_Config {
    /**
     * @generated from protobuf field: repeated v1.Raft.Config.Server servers = 1;
     */
    servers: Raft_Config_Server[];
}
/**
 * @generated from protobuf message v1.Raft.Config.Server
 */
export interface Raft_Config_Server {
    /**
     * @generated from protobuf field: v1.Raft.Config.Server.Suffrage suffrage = 1;
     */
    suffrage: Raft_Config_Server_Suffrage;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * @generated from protobuf field: string token = 4;
     */
    token: string;
}
/**
 * @generated from protobuf enum v1.Raft.Config.Server.Suffrage
 */
export enum Raft_Config_Server_Suffrage {
    /**
     * @generated from protobuf enum value: Voter = 0;
     */
    Voter = 0,
    /**
     * @generated from protobuf enum value: Nonvoter = 1;
     */
    Nonvoter = 1,
    /**
     * @generated from protobuf enum value: Staging = 2;
     */
    Staging = 2
}
/**
 * @generated from protobuf message v1.Raft.RPC
 */
export interface Raft_RPC {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Call
 */
export interface Raft_RPC_Call {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Call.Request
 */
export interface Raft_RPC_Call_Request {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "appendEntries";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.AppendEntries.Request append_entries = 1;
         */
        appendEntries: Raft_RPC_Command_AppendEntries_Request;
    } | {
        oneofKind: "vote";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.Vote.Request vote = 2;
         */
        vote: Raft_RPC_Command_Vote_Request;
    } | {
        oneofKind: "installSnapshot";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.InstallSnapshot.Request install_snapshot = 3;
         */
        installSnapshot: Raft_RPC_Command_InstallSnapshot_Request;
    } | {
        oneofKind: "timeoutNow";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.TimeoutNow.Request timeout_now = 4;
         */
        timeoutNow: Raft_RPC_Command_TimeoutNow_Request;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message v1.Raft.RPC.Call.Response
 */
export interface Raft_RPC_Call_Response {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "appendEntries";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.AppendEntries.Response append_entries = 1;
         */
        appendEntries: Raft_RPC_Command_AppendEntries_Response;
    } | {
        oneofKind: "vote";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.Vote.Response vote = 2;
         */
        vote: Raft_RPC_Command_Vote_Response;
    } | {
        oneofKind: "installSnapshot";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.InstallSnapshot.Response install_snapshot = 3;
         */
        installSnapshot: Raft_RPC_Command_InstallSnapshot_Response;
    } | {
        oneofKind: "timeoutNow";
        /**
         * @generated from protobuf field: v1.Raft.RPC.Command.TimeoutNow.Response timeout_now = 4;
         */
        timeoutNow: Raft_RPC_Command_TimeoutNow_Response;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string error = 5;
     */
    error: string;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command
 */
export interface Raft_RPC_Command {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.AppendEntries
 */
export interface Raft_RPC_Command_AppendEntries {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.AppendEntries.Request
 */
export interface Raft_RPC_Command_AppendEntries_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 prev_log_entry = 4;
     */
    prevLogEntry: bigint;
    /**
     * @generated from protobuf field: uint64 prev_log_term = 5;
     */
    prevLogTerm: bigint;
    /**
     * @generated from protobuf field: repeated v1.Raft.Log entries = 6;
     */
    entries: Raft_Log[];
    /**
     * @generated from protobuf field: uint64 leader_commit_index = 7;
     */
    leaderCommitIndex: bigint;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.AppendEntries.Response
 */
export interface Raft_RPC_Command_AppendEntries_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 last_log = 3;
     */
    lastLog: bigint;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
    /**
     * @generated from protobuf field: bool no_retry_backoff = 5;
     */
    noRetryBackoff: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Vote
 */
export interface Raft_RPC_Command_Vote {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Vote.Request
 */
export interface Raft_RPC_Command_Vote_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_index = 3;
     */
    lastLogIndex: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_term = 4;
     */
    lastLogTerm: bigint;
    /**
     * @generated from protobuf field: bool leadership_transfer = 5;
     */
    leadershipTransfer: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Vote.Response
 */
export interface Raft_RPC_Command_Vote_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bool granted = 3;
     */
    granted: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.InstallSnapshot
 */
export interface Raft_RPC_Command_InstallSnapshot {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.InstallSnapshot.Request
 */
export interface Raft_RPC_Command_InstallSnapshot_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.InstallSnapshot.Request.Version snapshot_version = 2;
     */
    snapshotVersion: Raft_RPC_Command_InstallSnapshot_Request_Version;
    /**
     * @generated from protobuf field: uint64 term = 3;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bytes leader = 4;
     */
    leader: Uint8Array;
    /**
     * @generated from protobuf field: uint64 last_log_index = 5;
     */
    lastLogIndex: bigint;
    /**
     * @generated from protobuf field: uint64 last_log_term = 6;
     */
    lastLogTerm: bigint;
    /**
     * @generated from protobuf field: bytes configuration = 7;
     */
    configuration: Uint8Array;
    /**
     * @generated from protobuf field: uint64 configuration_index = 8;
     */
    configurationIndex: bigint;
    /**
     * @generated from protobuf field: int64 size = 9;
     */
    size: bigint;
}
/**
 * @generated from protobuf enum v1.Raft.RPC.Command.InstallSnapshot.Request.Version
 */
export enum Raft_RPC_Command_InstallSnapshot_Request_Version {
    /**
     * @generated from protobuf enum value: Min = 0;
     */
    Min = 0,
    /**
     * @generated from protobuf enum value: Max = 1;
     */
    Max = 1
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.InstallSnapshot.Response
 */
export interface Raft_RPC_Command_InstallSnapshot_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
    /**
     * @generated from protobuf field: uint64 term = 2;
     */
    term: bigint;
    /**
     * @generated from protobuf field: bool success = 3;
     */
    success: boolean;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.TimeoutNow
 */
export interface Raft_RPC_Command_TimeoutNow {
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.TimeoutNow.Request
 */
export interface Raft_RPC_Command_TimeoutNow_Request {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.TimeoutNow.Response
 */
export interface Raft_RPC_Command_TimeoutNow_Response {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header header = 1;
     */
    header?: Raft_RPC_Command_Header;
}
/**
 * @generated from protobuf message v1.Raft.RPC.Command.Header
 */
export interface Raft_RPC_Command_Header {
    /**
     * @generated from protobuf field: v1.Raft.RPC.Command.Header.Version version = 1;
     */
    version: Raft_RPC_Command_Header_Version;
    /**
     * @generated from protobuf field: bytes id = 2;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: bytes addr = 3;
     */
    addr: Uint8Array;
}
/**
 * @generated from protobuf enum v1.Raft.RPC.Command.Header.Version
 */
export enum Raft_RPC_Command_Header_Version {
    /**
     * @generated from protobuf enum value: Min = 0;
     */
    Min = 0,
    /**
     * @generated from protobuf enum value: Max = 1;
     */
    Max = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Raft$Type extends MessageType<Raft> {
    constructor() {
        super("v1.Raft", []);
    }
    create(value?: PartialMessage<Raft>): Raft {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft): Raft {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft
 */
export const Raft = new Raft$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Entry$Type extends MessageType<Raft_Entry> {
    constructor() {
        super("v1.Raft.Entry", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "expires", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<Raft_Entry>): Raft_Entry {
        const message = { key: new Uint8Array(0), value: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Entry): Raft_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* google.protobuf.Duration expires */ 3:
                    message.expires = Duration.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* google.protobuf.Duration expires = 3; */
        if (message.expires)
            Duration.internalBinaryWrite(message.expires, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Entry
 */
export const Raft_Entry = new Raft_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Log$Type extends MessageType<Raft_Log> {
    constructor() {
        super("v1.Raft.Log", [
            { no: 1, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["v1.Raft.Log.Type", Raft_Log_Type] },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "extensions", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "appended_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Raft_Log>): Raft_Log {
        const message = { index: 0n, term: 0n, type: 0, data: new Uint8Array(0), extensions: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Log>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Log): Raft_Log {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 index */ 1:
                    message.index = reader.uint64().toBigInt();
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* v1.Raft.Log.Type type */ 3:
                    message.type = reader.int32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* bytes extensions */ 5:
                    message.extensions = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp appended_at */ 6:
                    message.appendedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.appendedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Log, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 index = 1; */
        if (message.index !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.index);
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* v1.Raft.Log.Type type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* bytes extensions = 5; */
        if (message.extensions.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.extensions);
        /* google.protobuf.Timestamp appended_at = 6; */
        if (message.appendedAt)
            Timestamp.internalBinaryWrite(message.appendedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Log
 */
export const Raft_Log = new Raft_Log$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Config$Type extends MessageType<Raft_Config> {
    constructor() {
        super("v1.Raft.Config", [
            { no: 1, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Raft_Config_Server }
        ]);
    }
    create(value?: PartialMessage<Raft_Config>): Raft_Config {
        const message = { servers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Config): Raft_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated v1.Raft.Config.Server servers */ 1:
                    message.servers.push(Raft_Config_Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated v1.Raft.Config.Server servers = 1; */
        for (let i = 0; i < message.servers.length; i++)
            Raft_Config_Server.internalBinaryWrite(message.servers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Config
 */
export const Raft_Config = new Raft_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_Config_Server$Type extends MessageType<Raft_Config_Server> {
    constructor() {
        super("v1.Raft.Config.Server", [
            { no: 1, name: "suffrage", kind: "enum", T: () => ["v1.Raft.Config.Server.Suffrage", Raft_Config_Server_Suffrage] },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_Config_Server>): Raft_Config_Server {
        const message = { suffrage: 0, id: "", address: "", token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_Config_Server>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_Config_Server): Raft_Config_Server {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.Config.Server.Suffrage suffrage */ 1:
                    message.suffrage = reader.int32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* string token */ 4:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_Config_Server, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.Config.Server.Suffrage suffrage = 1; */
        if (message.suffrage !== 0)
            writer.tag(1, WireType.Varint).int32(message.suffrage);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* string token = 4; */
        if (message.token !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.Config.Server
 */
export const Raft_Config_Server = new Raft_Config_Server$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC$Type extends MessageType<Raft_RPC> {
    constructor() {
        super("v1.Raft.RPC", []);
    }
    create(value?: PartialMessage<Raft_RPC>): Raft_RPC {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC): Raft_RPC {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC
 */
export const Raft_RPC = new Raft_RPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Call$Type extends MessageType<Raft_RPC_Call> {
    constructor() {
        super("v1.Raft.RPC.Call", []);
    }
    create(value?: PartialMessage<Raft_RPC_Call>): Raft_RPC_Call {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Call): Raft_RPC_Call {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Call
 */
export const Raft_RPC_Call = new Raft_RPC_Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Call_Request$Type extends MessageType<Raft_RPC_Call_Request> {
    constructor() {
        super("v1.Raft.RPC.Call.Request", [
            { no: 1, name: "append_entries", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_AppendEntries_Request },
            { no: 2, name: "vote", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_Vote_Request },
            { no: 3, name: "install_snapshot", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_InstallSnapshot_Request },
            { no: 4, name: "timeout_now", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_TimeoutNow_Request }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Call_Request>): Raft_RPC_Call_Request {
        const message = { kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Call_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Call_Request): Raft_RPC_Call_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.AppendEntries.Request append_entries */ 1:
                    message.kind = {
                        oneofKind: "appendEntries",
                        appendEntries: Raft_RPC_Command_AppendEntries_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).appendEntries)
                    };
                    break;
                case /* v1.Raft.RPC.Command.Vote.Request vote */ 2:
                    message.kind = {
                        oneofKind: "vote",
                        vote: Raft_RPC_Command_Vote_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).vote)
                    };
                    break;
                case /* v1.Raft.RPC.Command.InstallSnapshot.Request install_snapshot */ 3:
                    message.kind = {
                        oneofKind: "installSnapshot",
                        installSnapshot: Raft_RPC_Command_InstallSnapshot_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).installSnapshot)
                    };
                    break;
                case /* v1.Raft.RPC.Command.TimeoutNow.Request timeout_now */ 4:
                    message.kind = {
                        oneofKind: "timeoutNow",
                        timeoutNow: Raft_RPC_Command_TimeoutNow_Request.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timeoutNow)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Call_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.AppendEntries.Request append_entries = 1; */
        if (message.kind.oneofKind === "appendEntries")
            Raft_RPC_Command_AppendEntries_Request.internalBinaryWrite(message.kind.appendEntries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.Vote.Request vote = 2; */
        if (message.kind.oneofKind === "vote")
            Raft_RPC_Command_Vote_Request.internalBinaryWrite(message.kind.vote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.InstallSnapshot.Request install_snapshot = 3; */
        if (message.kind.oneofKind === "installSnapshot")
            Raft_RPC_Command_InstallSnapshot_Request.internalBinaryWrite(message.kind.installSnapshot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.TimeoutNow.Request timeout_now = 4; */
        if (message.kind.oneofKind === "timeoutNow")
            Raft_RPC_Command_TimeoutNow_Request.internalBinaryWrite(message.kind.timeoutNow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Call.Request
 */
export const Raft_RPC_Call_Request = new Raft_RPC_Call_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Call_Response$Type extends MessageType<Raft_RPC_Call_Response> {
    constructor() {
        super("v1.Raft.RPC.Call.Response", [
            { no: 1, name: "append_entries", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_AppendEntries_Response },
            { no: 2, name: "vote", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_Vote_Response },
            { no: 3, name: "install_snapshot", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_InstallSnapshot_Response },
            { no: 4, name: "timeout_now", kind: "message", oneof: "kind", T: () => Raft_RPC_Command_TimeoutNow_Response },
            { no: 5, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Call_Response>): Raft_RPC_Call_Response {
        const message = { kind: { oneofKind: undefined }, error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Call_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Call_Response): Raft_RPC_Call_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.AppendEntries.Response append_entries */ 1:
                    message.kind = {
                        oneofKind: "appendEntries",
                        appendEntries: Raft_RPC_Command_AppendEntries_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).appendEntries)
                    };
                    break;
                case /* v1.Raft.RPC.Command.Vote.Response vote */ 2:
                    message.kind = {
                        oneofKind: "vote",
                        vote: Raft_RPC_Command_Vote_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).vote)
                    };
                    break;
                case /* v1.Raft.RPC.Command.InstallSnapshot.Response install_snapshot */ 3:
                    message.kind = {
                        oneofKind: "installSnapshot",
                        installSnapshot: Raft_RPC_Command_InstallSnapshot_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).installSnapshot)
                    };
                    break;
                case /* v1.Raft.RPC.Command.TimeoutNow.Response timeout_now */ 4:
                    message.kind = {
                        oneofKind: "timeoutNow",
                        timeoutNow: Raft_RPC_Command_TimeoutNow_Response.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timeoutNow)
                    };
                    break;
                case /* string error */ 5:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Call_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.AppendEntries.Response append_entries = 1; */
        if (message.kind.oneofKind === "appendEntries")
            Raft_RPC_Command_AppendEntries_Response.internalBinaryWrite(message.kind.appendEntries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.Vote.Response vote = 2; */
        if (message.kind.oneofKind === "vote")
            Raft_RPC_Command_Vote_Response.internalBinaryWrite(message.kind.vote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.InstallSnapshot.Response install_snapshot = 3; */
        if (message.kind.oneofKind === "installSnapshot")
            Raft_RPC_Command_InstallSnapshot_Response.internalBinaryWrite(message.kind.installSnapshot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.TimeoutNow.Response timeout_now = 4; */
        if (message.kind.oneofKind === "timeoutNow")
            Raft_RPC_Command_TimeoutNow_Response.internalBinaryWrite(message.kind.timeoutNow, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string error = 5; */
        if (message.error !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Call.Response
 */
export const Raft_RPC_Call_Response = new Raft_RPC_Call_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command$Type extends MessageType<Raft_RPC_Command> {
    constructor() {
        super("v1.Raft.RPC.Command", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command>): Raft_RPC_Command {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command): Raft_RPC_Command {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command
 */
export const Raft_RPC_Command = new Raft_RPC_Command$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_AppendEntries$Type extends MessageType<Raft_RPC_Command_AppendEntries> {
    constructor() {
        super("v1.Raft.RPC.Command.AppendEntries", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_AppendEntries>): Raft_RPC_Command_AppendEntries {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_AppendEntries>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_AppendEntries): Raft_RPC_Command_AppendEntries {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_AppendEntries, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.AppendEntries
 */
export const Raft_RPC_Command_AppendEntries = new Raft_RPC_Command_AppendEntries$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_AppendEntries_Request$Type extends MessageType<Raft_RPC_Command_AppendEntries_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.AppendEntries.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "prev_log_entry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "prev_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Raft_Log },
            { no: 7, name: "leader_commit_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_AppendEntries_Request>): Raft_RPC_Command_AppendEntries_Request {
        const message = { term: 0n, prevLogEntry: 0n, prevLogTerm: 0n, entries: [], leaderCommitIndex: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_AppendEntries_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_AppendEntries_Request): Raft_RPC_Command_AppendEntries_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 prev_log_entry */ 4:
                    message.prevLogEntry = reader.uint64().toBigInt();
                    break;
                case /* uint64 prev_log_term */ 5:
                    message.prevLogTerm = reader.uint64().toBigInt();
                    break;
                case /* repeated v1.Raft.Log entries */ 6:
                    message.entries.push(Raft_Log.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 leader_commit_index */ 7:
                    message.leaderCommitIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_AppendEntries_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 prev_log_entry = 4; */
        if (message.prevLogEntry !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.prevLogEntry);
        /* uint64 prev_log_term = 5; */
        if (message.prevLogTerm !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.prevLogTerm);
        /* repeated v1.Raft.Log entries = 6; */
        for (let i = 0; i < message.entries.length; i++)
            Raft_Log.internalBinaryWrite(message.entries[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 leader_commit_index = 7; */
        if (message.leaderCommitIndex !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.leaderCommitIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.AppendEntries.Request
 */
export const Raft_RPC_Command_AppendEntries_Request = new Raft_RPC_Command_AppendEntries_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_AppendEntries_Response$Type extends MessageType<Raft_RPC_Command_AppendEntries_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.AppendEntries.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_log", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "no_retry_backoff", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_AppendEntries_Response>): Raft_RPC_Command_AppendEntries_Response {
        const message = { term: 0n, lastLog: 0n, success: false, noRetryBackoff: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_AppendEntries_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_AppendEntries_Response): Raft_RPC_Command_AppendEntries_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log */ 3:
                    message.lastLog = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                case /* bool no_retry_backoff */ 5:
                    message.noRetryBackoff = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_AppendEntries_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 last_log = 3; */
        if (message.lastLog !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastLog);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        /* bool no_retry_backoff = 5; */
        if (message.noRetryBackoff !== false)
            writer.tag(5, WireType.Varint).bool(message.noRetryBackoff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.AppendEntries.Response
 */
export const Raft_RPC_Command_AppendEntries_Response = new Raft_RPC_Command_AppendEntries_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Vote$Type extends MessageType<Raft_RPC_Command_Vote> {
    constructor() {
        super("v1.Raft.RPC.Command.Vote", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Vote>): Raft_RPC_Command_Vote {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Vote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Vote): Raft_RPC_Command_Vote {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_Vote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Vote
 */
export const Raft_RPC_Command_Vote = new Raft_RPC_Command_Vote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Vote_Request$Type extends MessageType<Raft_RPC_Command_Vote_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.Vote.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_log_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "last_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "leadership_transfer", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Vote_Request>): Raft_RPC_Command_Vote_Request {
        const message = { term: 0n, lastLogIndex: 0n, lastLogTerm: 0n, leadershipTransfer: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Vote_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Vote_Request): Raft_RPC_Command_Vote_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_index */ 3:
                    message.lastLogIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_term */ 4:
                    message.lastLogTerm = reader.uint64().toBigInt();
                    break;
                case /* bool leadership_transfer */ 5:
                    message.leadershipTransfer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_Vote_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* uint64 last_log_index = 3; */
        if (message.lastLogIndex !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastLogIndex);
        /* uint64 last_log_term = 4; */
        if (message.lastLogTerm !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.lastLogTerm);
        /* bool leadership_transfer = 5; */
        if (message.leadershipTransfer !== false)
            writer.tag(5, WireType.Varint).bool(message.leadershipTransfer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Vote.Request
 */
export const Raft_RPC_Command_Vote_Request = new Raft_RPC_Command_Vote_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Vote_Response$Type extends MessageType<Raft_RPC_Command_Vote_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.Vote.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "granted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Vote_Response>): Raft_RPC_Command_Vote_Response {
        const message = { term: 0n, granted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Vote_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Vote_Response): Raft_RPC_Command_Vote_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bool granted */ 3:
                    message.granted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_Vote_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* bool granted = 3; */
        if (message.granted !== false)
            writer.tag(3, WireType.Varint).bool(message.granted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Vote.Response
 */
export const Raft_RPC_Command_Vote_Response = new Raft_RPC_Command_Vote_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_InstallSnapshot$Type extends MessageType<Raft_RPC_Command_InstallSnapshot> {
    constructor() {
        super("v1.Raft.RPC.Command.InstallSnapshot", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_InstallSnapshot>): Raft_RPC_Command_InstallSnapshot {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_InstallSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_InstallSnapshot): Raft_RPC_Command_InstallSnapshot {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_InstallSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.InstallSnapshot
 */
export const Raft_RPC_Command_InstallSnapshot = new Raft_RPC_Command_InstallSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_InstallSnapshot_Request$Type extends MessageType<Raft_RPC_Command_InstallSnapshot_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.InstallSnapshot.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "snapshot_version", kind: "enum", T: () => ["v1.Raft.RPC.Command.InstallSnapshot.Request.Version", Raft_RPC_Command_InstallSnapshot_Request_Version] },
            { no: 3, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "leader", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "last_log_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "last_log_term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "configuration", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "configuration_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_InstallSnapshot_Request>): Raft_RPC_Command_InstallSnapshot_Request {
        const message = { snapshotVersion: 0, term: 0n, leader: new Uint8Array(0), lastLogIndex: 0n, lastLogTerm: 0n, configuration: new Uint8Array(0), configurationIndex: 0n, size: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_InstallSnapshot_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_InstallSnapshot_Request): Raft_RPC_Command_InstallSnapshot_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* v1.Raft.RPC.Command.InstallSnapshot.Request.Version snapshot_version */ 2:
                    message.snapshotVersion = reader.int32();
                    break;
                case /* uint64 term */ 3:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bytes leader */ 4:
                    message.leader = reader.bytes();
                    break;
                case /* uint64 last_log_index */ 5:
                    message.lastLogIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_log_term */ 6:
                    message.lastLogTerm = reader.uint64().toBigInt();
                    break;
                case /* bytes configuration */ 7:
                    message.configuration = reader.bytes();
                    break;
                case /* uint64 configuration_index */ 8:
                    message.configurationIndex = reader.uint64().toBigInt();
                    break;
                case /* int64 size */ 9:
                    message.size = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_InstallSnapshot_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* v1.Raft.RPC.Command.InstallSnapshot.Request.Version snapshot_version = 2; */
        if (message.snapshotVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.snapshotVersion);
        /* uint64 term = 3; */
        if (message.term !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.term);
        /* bytes leader = 4; */
        if (message.leader.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.leader);
        /* uint64 last_log_index = 5; */
        if (message.lastLogIndex !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.lastLogIndex);
        /* uint64 last_log_term = 6; */
        if (message.lastLogTerm !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.lastLogTerm);
        /* bytes configuration = 7; */
        if (message.configuration.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.configuration);
        /* uint64 configuration_index = 8; */
        if (message.configurationIndex !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.configurationIndex);
        /* int64 size = 9; */
        if (message.size !== 0n)
            writer.tag(9, WireType.Varint).int64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.InstallSnapshot.Request
 */
export const Raft_RPC_Command_InstallSnapshot_Request = new Raft_RPC_Command_InstallSnapshot_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_InstallSnapshot_Response$Type extends MessageType<Raft_RPC_Command_InstallSnapshot_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.InstallSnapshot.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header },
            { no: 2, name: "term", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_InstallSnapshot_Response>): Raft_RPC_Command_InstallSnapshot_Response {
        const message = { term: 0n, success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_InstallSnapshot_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_InstallSnapshot_Response): Raft_RPC_Command_InstallSnapshot_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* uint64 term */ 2:
                    message.term = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 3:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_InstallSnapshot_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 term = 2; */
        if (message.term !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.term);
        /* bool success = 3; */
        if (message.success !== false)
            writer.tag(3, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.InstallSnapshot.Response
 */
export const Raft_RPC_Command_InstallSnapshot_Response = new Raft_RPC_Command_InstallSnapshot_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_TimeoutNow$Type extends MessageType<Raft_RPC_Command_TimeoutNow> {
    constructor() {
        super("v1.Raft.RPC.Command.TimeoutNow", []);
    }
    create(value?: PartialMessage<Raft_RPC_Command_TimeoutNow>): Raft_RPC_Command_TimeoutNow {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_TimeoutNow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_TimeoutNow): Raft_RPC_Command_TimeoutNow {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Raft_RPC_Command_TimeoutNow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.TimeoutNow
 */
export const Raft_RPC_Command_TimeoutNow = new Raft_RPC_Command_TimeoutNow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_TimeoutNow_Request$Type extends MessageType<Raft_RPC_Command_TimeoutNow_Request> {
    constructor() {
        super("v1.Raft.RPC.Command.TimeoutNow.Request", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_TimeoutNow_Request>): Raft_RPC_Command_TimeoutNow_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_TimeoutNow_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_TimeoutNow_Request): Raft_RPC_Command_TimeoutNow_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_TimeoutNow_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.TimeoutNow.Request
 */
export const Raft_RPC_Command_TimeoutNow_Request = new Raft_RPC_Command_TimeoutNow_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_TimeoutNow_Response$Type extends MessageType<Raft_RPC_Command_TimeoutNow_Response> {
    constructor() {
        super("v1.Raft.RPC.Command.TimeoutNow.Response", [
            { no: 1, name: "header", kind: "message", T: () => Raft_RPC_Command_Header }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_TimeoutNow_Response>): Raft_RPC_Command_TimeoutNow_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_TimeoutNow_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_TimeoutNow_Response): Raft_RPC_Command_TimeoutNow_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header header */ 1:
                    message.header = Raft_RPC_Command_Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_TimeoutNow_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header header = 1; */
        if (message.header)
            Raft_RPC_Command_Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.TimeoutNow.Response
 */
export const Raft_RPC_Command_TimeoutNow_Response = new Raft_RPC_Command_TimeoutNow_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raft_RPC_Command_Header$Type extends MessageType<Raft_RPC_Command_Header> {
    constructor() {
        super("v1.Raft.RPC.Command.Header", [
            { no: 1, name: "version", kind: "enum", T: () => ["v1.Raft.RPC.Command.Header.Version", Raft_RPC_Command_Header_Version] },
            { no: 2, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Raft_RPC_Command_Header>): Raft_RPC_Command_Header {
        const message = { version: 0, id: new Uint8Array(0), addr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Raft_RPC_Command_Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raft_RPC_Command_Header): Raft_RPC_Command_Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* v1.Raft.RPC.Command.Header.Version version */ 1:
                    message.version = reader.int32();
                    break;
                case /* bytes id */ 2:
                    message.id = reader.bytes();
                    break;
                case /* bytes addr */ 3:
                    message.addr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raft_RPC_Command_Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* v1.Raft.RPC.Command.Header.Version version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).int32(message.version);
        /* bytes id = 2; */
        if (message.id.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.id);
        /* bytes addr = 3; */
        if (message.addr.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.addr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message v1.Raft.RPC.Command.Header
 */
export const Raft_RPC_Command_Header = new Raft_RPC_Command_Header$Type();
