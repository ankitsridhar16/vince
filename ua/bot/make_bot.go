package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp/syntax"
	"sort"
	"strings"

	regexp2 "github.com/dlclark/regexp2"
	"gopkg.in/yaml.v2"
)

func main() {
	err := genBot()
	if err != nil {
		log.Fatal(err)
	}
}

type Producer struct {
	Name string `yaml:"name" json:"name"`
	Url  string `yaml:"url" json:"url"`
}

type Bot struct {
	Regex    string   `yaml:"regex" json:"regex"`
	Name     string   `yaml:"name" json:"name"`
	Category string   `yaml:"category" json:"category"`
	Url      string   `yaml:"url" json:"url"`
	Producer Producer `yaml:"producer" json:"producer"`
}

type BotSlice []*Bot

func (x BotSlice) Len() int           { return len(x) }
func (x BotSlice) Less(i, j int) bool { return x[i].Name < x[j].Name }
func (x BotSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

func genBot() error {
	var r []*Bot
	b, err := os.ReadFile("ua/data/bots.yml")
	if err != nil {
		// do nothing if we can't find data file
		return nil
	}
	err = yaml.Unmarshal(b, &r)
	if err != nil {
		return err
	}
	sort.Sort(BotSlice(r))
	var exactMatch []*Bot
	var reStandard []*Bot
	var re2 []*Bot

	for _, x := range r {
		if isRe(x.Regex) {
			_, err = syntax.Parse(cleanRegexString(x.Regex), syntax.Perl)
			if err == nil {
				reStandard = append(reStandard, x)
			} else {
				_ = regexp2.MustCompile(cleanRegexString(x.Regex), regexp2.IgnoreCase)
				re2 = append(re2, x)
			}
		} else {
			exactMatch = append(exactMatch, x)
		}
	}
	sort.Sort(BotSlice(exactMatch))
	sort.Sort(BotSlice(reStandard))
	sort.Sort(BotSlice(re2))

	var s strings.Builder

	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// DO NOT EDIT Code generated by ua/bot/make_bot.go")
	fmt.Fprintln(&buf, " package vince")
	fmt.Fprintln(&buf, `
	import (
		"regexp"
		re2 "github.com/dlclark/regexp2"
	)
	`)
	for i, x := range reStandard {
		if i != 0 {
			s.WriteByte('|')
		}
		s.WriteString(x.Regex)
	}

	fmt.Fprintf(&buf, " var allBotsReStandardMatch= regexp.MustCompile(`%s`)\n", cleanRegexString(s.String()))
	s.Reset()
	for i, x := range re2 {
		if i != 0 {
			s.WriteByte('|')
		}
		s.WriteString(x.Regex)
	}

	fmt.Fprintf(&buf, " var allBotsRe2Match= re2.MustCompile(`%s`,re2.IgnoreCase)\n", cleanRegexString(s.String()))
	fmt.Fprintln(&buf, `
	type botRe struct{
		re *regexp.Regexp
		name     string   
		category string   
		url      string 
		producerName string  
		producerURL string  
	}
	type botRe2 struct{
		re *re2.Regexp
		name     string   
		category string   
		url      string 
		producerName string  
		producerURL string  
	}
	type botMatch struct {
		name     string   
		category string   
		url      string 
		producerName string  
		producerURL string  
	}
	`)
	fmt.Fprintln(&buf, "var botsReList=[]*botRe{")
	for _, m := range reStandard {
		fmt.Fprintf(&buf, "{re:regexp.MustCompile(`%s`), name:%q,category:%q,url:%q,producerName:%q,producerURL:%q, },\n",
			cleanRegexString(m.Regex), m.Name, m.Category, m.Url, m.Producer.Name, m.Producer.Url,
		)
	}
	fmt.Fprintln(&buf, "}")
	fmt.Fprintln(&buf, "var botsRe2List=[]*botRe2{")
	for _, m := range re2 {
		fmt.Fprintf(&buf, "{re:re2.MustCompile(`%s`,re2.IgnoreCase), name:%q,category:%q,url:%q,producerName:%q,producerURL:%q, },\n",
			cleanRegexString(m.Regex), m.Name, m.Category, m.Url, m.Producer.Name, m.Producer.Url,
		)
	}
	fmt.Fprintln(&buf, "}")
	fmt.Fprintln(&buf, "var botsExactMatchMap=map[string]*botMatch{")
	for _, m := range exactMatch {
		fmt.Fprintf(&buf, "%q:{name:%q,category:%q,url:%q,producerName:%q,producerURL:%q, },\n", strings.ToLower(m.Regex),
			m.Name, m.Category, m.Url, m.Producer.Name, m.Producer.Url,
		)
	}
	fmt.Fprintln(&buf, "}")

	f, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return os.WriteFile("ua_bots.go", f, 0600)
}

const meta = "\\.+*?()|[]{}^$#"

func isRe(s string) bool {
	return strings.ContainsAny(s, meta)
}

// Make some adjustments for a different regex engine than upstream matomo
func cleanRegexString(re string) string {
	rg := strings.Replace(re, `/`, `\/`, -1)
	rg = strings.Replace(rg, `++`, `+`, -1)
	rg = strings.Replace(rg, `\_`, `_`, -1)
	// if we find `\_` again, the original was `\\_`,
	// so restore that so the regex engine does not attempt to escape `_`
	rg = strings.Replace(rg, `\_`, `\\_`, -1)

	// only match if useragent begins with given regex or there is no letter before it
	return `(?:^|[^A-Z0-9-_]|[^A-Z0-9-]_|sprd-)(?:` + rg + ")"
}
