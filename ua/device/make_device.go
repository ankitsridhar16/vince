package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp/syntax"
	"sort"
	"strings"

	re2 "github.com/dlclark/regexp2"
	"github.com/gernest/vince/ua"
	"gopkg.in/yaml.v2"
)

func main() {
	var b bytes.Buffer

	fmt.Fprintln(&b, "// DO NOT EDIT Code generated by ua/device/make_device.go")
	fmt.Fprintln(&b, " package vince")
	fmt.Fprintln(&b, `
import (
    "regexp"
	re2 "github.com/dlclark/regexp2"
)


type deviceRe struct{
	re *regexp.Regexp
	re2 *re2.Regexp
	model        string  
	device       string 
	company      string   
	models       []*deviceModel
}

type deviceModel struct {
	model  string
	exact string
	re  *regexp.Regexp
	re2 *re2.Regexp
}

type deviceResult struct {
	model        string  
	device       string 
	company      string   
}

`)

	err := genCamera(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genCar(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genConsole(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genTV(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genMobile(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genNotebook(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genPortableMediaPlayer(&b)
	if err != nil {
		log.Fatal(err)
	}
	err = genShell(&b)
	if err != nil {
		log.Fatal(err)
	}

	r, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.WriteFile("ua_device.go", r, 0600)
}

type Model struct {
	Regex  string `yaml:"regex" json:"regex"`
	Model  string `yaml:"model" json:"model"`
	Device string `yaml:"device" json:"device"` //mobile
	Brand  string `yaml:"brand" json:"brand"`   //mobile
}

type DeviceReg struct {
	Regex        string   `yaml:"regex" json:"regex"`
	Model        string   `yaml:"model" json:"model"`
	Device       string   `yaml:"device" json:"device"`
	Manufacturer string   `yaml:"-" json:"-"`
	Models       []*Model `yaml:"models" json:"models"`
}

type DeviceRegSlice []*DeviceReg

func (x DeviceRegSlice) Len() int           { return len(x) }
func (x DeviceRegSlice) Less(i, j int) bool { return x[i].Manufacturer < x[j].Manufacturer }
func (x DeviceRegSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

func genCamera(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	return generic(b, "Camera", "ua/data/device/cameras.yml")
}

func genCar(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	return generic(b, "Car", "ua/data/device/car_browsers.yml")
}

func genConsole(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	return generic(b, "Console", "ua/data/device/consoles.yml")
}

func genTV(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	fmt.Fprintf(b, " var deviceIsTVRe= regexp.MustCompile(`%s`)\n", ua.Clean(`HbbTV/([1-9]{1}(?:.[0-9]{1}){1,2})`))
	return generic(b, "TV", "ua/data/device/televisions.yml")
}

func genMobile(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	return generic(b, "Mobile", "ua/data/device/mobiles.yml")
}

func genNotebook(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	return generic(b, "Notebook", "ua/data/device/notebooks.yml")
}
func genPortableMediaPlayer(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	return generic(b, "PortableMediaPlayer", "ua/data/device/portable_media_player.yml")
}

func genShell(b *bytes.Buffer) error {
	fmt.Fprintln(b)
	fmt.Fprintf(b, " var deviceShellRe= regexp.MustCompile(`%s`)\n", ua.Clean(`[a-z]+[ _]Shell[ _]\w{6}`))
	return generic(b, "Shell", "ua/data/device/shell_tv.yml")
}
func generic(b *bytes.Buffer, name string, path string) error {
	items, err := loadDevice(path)
	if err != nil {
		return err
	}
	var s strings.Builder
	for i, d := range items {
		if i != 0 {
			s.WriteByte('|')
		}
		s.WriteString(d.Regex)
		r := ua.Clean(d.Regex)

		_, err = syntax.Parse(r, syntax.Perl)
		if err != nil {
			_, err = re2.Compile(r, re2.IgnoreCase)
			if err != nil {
				return fmt.Errorf("bad regex %s", r)
			}
		}
	}
	var buf bytes.Buffer

	if ua.IsStdRe(s.String()) {
		fmt.Fprintf(b, " var device%sAllRe= regexp.MustCompile(`%s`)\n", name, ua.Clean(s.String()))
	} else {
		fmt.Fprintf(b, " var device%sAllRe= re2.MustCompile(`%s`,re2.IgnoreCase)\n", name, ua.Clean(s.String()))
	}
	fmt.Fprintf(b, "var device%sAll=[]*deviceRe{\n", name)
	for _, d := range items {
		buf.Reset()
		r := ua.Clean(d.Regex)
		if ua.IsStdRe(d.Regex) {
			fmt.Fprintf(&buf, "re:regexp.MustCompile(`%s`)", r)
		} else {
			fmt.Fprintf(&buf, "re2: re2.MustCompile(`%s`,re2.IgnoreCase)", r)
		}
		fmt.Fprintf(b, "{%s,company:%q, ", &buf, d.Manufacturer)
		if d.Model != "" {
			fmt.Fprintf(b, "model:%q},\n", d.Model)
		} else {
			if len(d.Models) > 0 {
				fmt.Fprintf(b, "models:[]*deviceModel{")
				for _, m := range d.Models {

					fmt.Fprintf(b, "{model:%q,", m.Model)
					if ua.IsRe(m.Regex) {
						buf.Reset()
						r = ua.Clean(m.Regex)
						if ua.IsStdRe(m.Regex) {
							fmt.Fprintf(&buf, "re:regexp.MustCompile(`%s`)", r)
						} else {
							fmt.Fprintf(&buf, "re2: re2.MustCompile(`%s`,re2.IgnoreCase)", r)
						}
						fmt.Fprintf(b, "%s},\n", &buf)
					} else {
						fmt.Fprintf(b, "exact:%q},\n", m.Regex)
					}
				}
				fmt.Fprintf(b, "},")
			}
			fmt.Fprintf(b, "},\n")
		}

	}
	fmt.Fprintln(b, "}")

	return nil
}

func loadDevice(path string) ([]*DeviceReg, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var v map[string]*DeviceReg
	err = yaml.Unmarshal(b, &v)
	if err != nil {
		return nil, err
	}

	var items []*DeviceReg
	for key, value := range v {
		value.Manufacturer = key
		items = append(items, value)
	}
	sort.Sort(DeviceRegSlice(items))
	return items, nil
}
